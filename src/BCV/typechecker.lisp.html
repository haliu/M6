<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01//EN">
<!-- Created by htmlize-1.16 in css mode. -->
<html>
  <head>
    <title>typechecker.lisp</title>
    <style type="text/css">
    <!--
      body {
        color: #f5deb3;
        background-color: #000000;
      }
      .builtin {
        /* font-lock-builtin-face */
        color: #b0c4de;
      }
      .comment {
        /* font-lock-comment-face */
        color: #ff7f24;
      }
      .function-name {
        /* font-lock-function-name-face */
        color: #87cefa;
      }
      .keyword {
        /* font-lock-keyword-face */
        color: #00ffff;
      }
      .string {
        /* font-lock-string-face */
        color: #ffa07a;
      }
      .type {
        /* font-lock-type-face */
        color: #98fb98;
      }
      a {
        color: inherit;
        background-color: inherit;
        font: inherit;
        text-decoration: inherit;
      }
      a:hover {
        text-decoration: underline;
      }
    -->
    </style>
  </head>
  <body>
    <pre>
(<span class="keyword">in-package</span> <span class="string">"BCV"</span>)
<span class="comment">;----------------------------------------------------
;; (defun mem (c cl)
;;    (if (endp cl)
;;        nil
;;      (or (equal (car cl) c)
;;          (mem c (cdr cl)))))
</span>
<span class="comment">;; (defun notMem (c cl)
;;    (not (mem c cl)))
</span>

<span class="comment">;; (defun subset (s1 s2)
;;    (if (endp s1)
;;        t
;;      (and (mem (car s1) s2)
;;           (subset (cdr s1) s2))))
</span>


<span class="comment">;;  (defun del (a y)
;;    (if (endp y)
;;        nil
;;      (if (equal (car y) a)
;;          (cdr y)
;;        (cons (car y) (del a (cdr y))))))
</span>

<span class="comment">;;  (defun app (a b)
;;    (if (endp a)
;;        b
;;      (cons (car a) (app (cdr a) b))))
;;;
;;; These basic functions are defined in commmon no-dup-facts. 
;;; They are included as part of the BCV pakage definition
</span>(acl2::set-ignore-ok t)


(<span class="keyword">defmacro</span> <span class="function-name">msg</span> (<span class="type">&amp;rest</span> args) 
  (acl2::debug-print args))


<span class="comment">;;------------------------------------------------------------
;;
;;  Class Term Accessors
;;
;;------------------------------------------------------------
</span>
<span class="comment">;;; Thu Jan 15 18:17:53 2004. Note this is different from isClassTerm in
;;; jvm-class-table.lisp
;;;
;;;
</span>
(<span class="keyword">defun</span> <span class="function-name">isClassTerm</span> (Class)
  (and (consp Class)
       (equal (len (cdr Class)) 8)))

<span class="comment">;; Sun Mar 28 15:45:40 2004. A year after!!
;; Fri Apr  8 14:48:42 2005. Yet another year!! 
;; Mon Dec 19 20:28:25 2005. 
</span>
(<span class="keyword">defun</span> <span class="function-name">classClassName</span> (Class)
  (nth 1 Class))

(<span class="keyword">defun</span> <span class="function-name">classIsInterface</span> (Class)
  (nth 2 Class))

(<span class="keyword">defun</span> <span class="function-name">classSuperClassName</span> (Class)
  (nth 3 Class))

(<span class="keyword">defun</span> <span class="function-name">classConstantPool</span> (Class)
  (cdr (nth 4 Class)))

(<span class="keyword">defun</span> <span class="function-name">classInterfaces</span> (Class)
  (cdr (nth 5 Class)))

(<span class="keyword">defun</span> <span class="function-name">classFields</span> (Class)
  (cdr (nth 6 Class)))

(<span class="keyword">defun</span> <span class="function-name">classMethods</span> (Class)
  (cdr (nth 7 Class)))

(<span class="keyword">defun</span> <span class="function-name">classAccessFlags</span> (Class)
  (cdr (nth 8 Class)))


<span class="comment">;; 
;; (defun classAttributes (Class)
;;   (cdr (nth 9 Class)))
;; Wed Jul 13 14:40:28 2005 
;;
;; Get ignore class attributes!! 
;;
;; in CLDC bytecode verifier. 
</span>
(<span class="keyword">defun</span> <span class="function-name">make-class-term</span> 
  (className isInterface superClassName cp interfaces
             fields methods accessflags)
  (list 'class className 
        isInterface 
        superClassName 
        (cons 'constant_pool cp)
        (cons 'interfaces    interfaces)
        (cons 'fields        fields)
        (cons 'methods       methods)
        (cons 'accessflags   accessflags)))


(defthm isClassTerm-make-class-term
  (isClassTerm (make-class-term n i s c is fs ms af)))

(defthm make-class-term-accessor 
  (and (equal (classClassName   (make-class-term n i s c is fs ms af)) n)
       (equal (classIsInterface (make-class-term n i s c is fs ms af)) i)
       (equal (classSuperClassName (make-class-term n i s c is fs ms af)) s)
       (equal (classConstantPool   (make-class-term n i s c is fs ms af)) c)
       (equal (classInterfaces   (make-class-term n i s c is fs ms af)) is)
       (equal (classFields       (make-class-term n i s c is fs ms af)) fs)
       (equal (classMethods      (make-class-term n i s c is fs ms af)) ms)
       (equal (classAccessFlags  (make-class-term n i s c is fs ms af)) af)))


(in-theory (disable classClassName classIsInterface classSuperClassName
                    classConstantPool classInterfaces classFields classMethods
                    classAccessFlags
                    make-class-term))


<span class="comment">;;------------------------------------------------------------
;;
;;  Method Term Accessors
;;
;;------------------------------------------------------------
</span>
(<span class="keyword">defun</span> <span class="function-name">isMethodTerm</span> (Method)
  (and (consp Method)
       (equal (len (cdr Method)) 5)))


(<span class="keyword">defun</span> <span class="function-name">methodName</span>(Method)
  (nth 1 Method))

(<span class="keyword">defun</span> <span class="function-name">methodParameters</span>(Method)
  (cdr (nth 2 Method)))

(<span class="keyword">defun</span> <span class="function-name">methodReturnType</span>(Method)
  (cdr (nth 3 Method)))

(<span class="keyword">defun</span> <span class="function-name">methodAccessFlags</span>(Method)
  (cdr (nth 4 Method)))

(<span class="keyword">defun</span> <span class="function-name">methodCodeAttribute</span>(Method)
  (cdr (nth 5 Method)))

(<span class="keyword">defun</span> <span class="function-name">make-method-term</span> 
  (methodName parameters returnType accessFlags codeAttributes)
  (list 'method methodName 
        (cons 'parameters  parameters)
        (cons 'returntype  returnType)
        (cons 'accessflags accessFlags)
        (cons 'code        codeAttributes)))

(defthm make-method-term-accessor 
  (and (equal (methodName       (make-method-term n p r a c)) n)
       (equal (methodParameters (make-method-term n p r a c)) p)
       (equal (methodReturnType (make-method-term n p r a c)) r)
       (equal (methodAccessFlags (make-method-term n p r a c)) a)
       (equal (methodCodeAttribute (make-method-term n p r a c)) c)))

(in-theory (disable methodName methodParameters methodReturnType
                    methodAccessFlags methodCodeAttribute make-method-term))

<span class="comment">;--------------------------------------------------------
</span>(<span class="keyword">defun</span> <span class="function-name">isFieldTerm</span> (Field)
  (and (consp Field)
       <span class="comment">;;  (equal (car Method) 'method)
</span>       (equal (len (cdr Field)) 5)))

(<span class="keyword">defun</span> <span class="function-name">fieldName</span>(Field)
  (nth 1 Field))

(<span class="keyword">defun</span> <span class="function-name">fieldType</span>(Field)
  (cadr (nth 2 Field)))

(<span class="keyword">defun</span> <span class="function-name">fieldAccessFlags</span>(Field)
  (cdr (nth 3 Field)))

(<span class="keyword">defun</span> <span class="function-name">make-field-term</span> 
  (name type accessFlags)
  (list 'field name 
        (list 'returntype  type)
        (cons 'accessflags accessFlags)))

(defthm make-field-term-accessor 
  (and (equal (fieldName       (make-field-term n p a)) n)
       (equal (fieldType       (make-field-term n p a)) p)
       (equal (fieldAccessFlags (make-field-term n p a)) a)))

(in-theory (disable fieldName fieldType fieldAccessFlags  make-field-term))

<span class="comment">;---------------------------------
</span>(<span class="keyword">defun</span> <span class="function-name">MaxStack1</span> (Method)
  (cdr (nth 0 (methodCodeAttribute Method))))

(<span class="keyword">defun</span> <span class="function-name">FrameSize1</span> (Method)
  (cdr (nth 1 (methodCodeAttribute Method))))

(<span class="keyword">defun</span> <span class="function-name">ByteCodeLength1</span> (Method)
  (cdr (nth 2 (methodCodeAttribute Method))))

(<span class="keyword">defun</span> <span class="function-name">ParsedCode1</span> (Method)
  (cdr (nth 3 (methodCodeAttribute Method))))

(<span class="keyword">defun</span> <span class="function-name">Handlers1</span> (Method)
  (cdr (nth 4 (methodCodeAttribute Method))))

(<span class="keyword">defun</span> <span class="function-name">StackMap1</span> (Method)
  (cdr (nth 5 (methodCodeAttribute Method))))


(<span class="keyword">defun</span> <span class="function-name">MaxStack</span> (Method Class)
  (<span class="keyword">declare</span> (ignore Class))
  (MaxStack1 Method))

(<span class="keyword">defun</span> <span class="function-name">FrameSize</span> (Method Class)
  (<span class="keyword">declare</span> (ignore Class))
  (FrameSize1 Method))

(<span class="keyword">defun</span> <span class="function-name">ByteCodeLength</span> (Method Class)
  (<span class="keyword">declare</span> (ignore Class))
  (ByteCodeLength1 Method))

(<span class="keyword">defun</span> <span class="function-name">ParsedCode</span> (Method Class)
  (<span class="keyword">declare</span> (ignore Class))
  (ParsedCode1 Method))

(<span class="keyword">defun</span> <span class="function-name">Handlers</span> (Method Class)
  (<span class="keyword">declare</span> (ignore Class))
  (Handlers1 Method))

(<span class="keyword">defun</span> <span class="function-name">StackMap</span> (Method Class)
  (<span class="keyword">declare</span> (ignore Class))
  (StackMap1 Method))


(<span class="keyword">defun</span> <span class="function-name">make-code-attribute-term</span> (maxStack frameSize bytecodeLength parsedCode
                                          handlers stackMap)
  (list (list 'max_stack maxStack)
        (list 'max_locals frameSize)
        (list 'code_length bytecodeLength)
        (list 'parsedcode  parsedCode)
        (list 'Exceptions  handlers)
        (list 'StackMap    stackMap)))



<span class="comment">;-------------------------------------------------------
</span>
(<span class="keyword">defun</span> <span class="function-name">make-class-table</span> (cl)
  cl)


(<span class="keyword">defmacro</span> <span class="function-name">make-class-table1</span> (<span class="type">&amp;rest</span> cl)
  (cons 'list cl))

<span class="comment">;---------------------------------------------------------
</span>
(<span class="keyword">defun</span> <span class="function-name">make-sig-frame</span> (Locals Stack Flags) 
  (list 'frame (cons 'locals locals) (cons 'stack stack) Flags))


(<span class="keyword">defun</span> <span class="function-name">frameLocals</span> (frame)
  (cdr (nth 1 frame)))

(<span class="keyword">defun</span> <span class="function-name">frameStack</span>  (frame)
  (cdr (nth 2 frame)))

(<span class="keyword">defun</span> <span class="function-name">frameFlags</span> (frame)
  (nth 3 frame))


(<span class="keyword">defun</span> <span class="function-name">Flags</span> (ThisList)
  (<span class="keyword">if</span> (equal ThisList '(uninitializedThis))
      '(flagThisUninit)
    nil))




<span class="comment">;;--------------------------------------------------------
;;
;;   General comments 
;;
;;--------------------------------------------------------
</span>
<span class="comment">;; Q:  How to deal with the parsing error? 
;;
;; A:  For example, the fact that a static method can't be &lt;init&gt; is
;; encoded as Part of the Prolog version's parser.  Let me seperate
;; those internal constraints into a consistent predicate later
</span>





<span class="comment">;; ------------------------------
;;
;;  Compute the Type of ThisType  
;;
;; -------------------------------
</span>

(<span class="keyword">defun</span> <span class="function-name">prefix-class</span> (typ)
  (list 'CLASS typ))


<span class="comment">;; assume well formed 
</span>(<span class="keyword">defun</span> <span class="function-name">instanceMethodInitialThisType</span> (Class Method) 
  (<span class="keyword">let</span> ((MethodName (methodName Method))
        (ClassName  (classClassName Class)))
    (<span class="keyword">if</span> (not (equal MethodName <span class="string">"&lt;init&gt;"</span>))
        (prefix-class ClassName)
      (<span class="keyword">if</span> (equal ClassName <span class="string">"java.lang.Object"</span>)
          (prefix-class <span class="string">"java.lang.Object"</span>)<span class="comment">;; *1* 
</span>        'uninitializedThis))))

<span class="comment">;; *1* Note:
;;     Assume Object is initialized by default. 
;;     The standard library has only 1 constructor.
;; 
</span>
<span class="comment">;; -- 3 cases  &lt;init&gt;, "java.lang.Object".&lt;init&gt;, not &lt;init&gt;
</span>

(<span class="keyword">defun</span> <span class="function-name">methodInitialThisType</span> (Class Method)       
  (<span class="keyword">let</span> ((AccessFlags (methodAccessFlags Method)))
    (<span class="keyword">if</span> (mem '*static* AccessFlags) nil<span class="comment">;; *2*
</span>      (list (instanceMethodInitialThisType Class Method)))))
      
<span class="comment">;; *2* Note: 
;;     AccessFlags are modeled as list of *static* *native* 
;;     The *public*, *private*, *protected* *final* is not modeled
;;     UPDATE: modeled now. 
</span>



<span class="comment">;; ----- utitilites --------
</span>

(<span class="keyword">defun</span> <span class="function-name">sizeOf</span> (Type) 
  (<span class="keyword">if</span> (or (equal type 'twoword)
          (equal type 'long)
          (equal type 'double)) 2
    1))

(<span class="keyword">defun</span> <span class="function-name">expandTypeList</span> (RawArgs)<span class="comment">;; *3*
</span>  (<span class="keyword">if</span> (endp RawArgs)
      nil
    (<span class="keyword">cond</span> ((equal (sizeOf (car RawArgs)) 1)
           (cons (car RawArgs) (expandTypeList (cdr RawArgs))))
          ((equal (sizeOf (car RawArgs)) 2)
           (cons (car RawArgs) (cons 'topx (expandTypeList (cdr RawArgs)))))
          (t nil))))<span class="comment">;; impossible.
</span>
<span class="comment">;; outdated
;; *3* Note: 
;;     ExpandTypeList expands the raw typelist to type list with     
;;     padding -- so that Double, Long occupy two word. top is 
;;     explictly inserted. 
;;  
;;     In our implementation, we assume jvm2acl2 translator
;;     already does this.
</span>
<span class="comment">;; march 02 we don't assume jvm2acl2 translator does this. 
</span>



<span class="comment">;; ------------------------------
;;
;  Build Initial StackFrame 
;;
;; -------------------------------
</span>
<span class="comment">;; fill up the slot with 'topx type
;; assuming (len Args) &lt;= FrameSize
</span>
(<span class="keyword">defun</span> <span class="function-name">top-list</span> (len)
  (<span class="keyword">if</span> (zp len)
      nil
    (cons 'topx (top-list (- len 1)))))
      

(<span class="keyword">defun</span> <span class="function-name">expandToLength</span> (Args FrameSize)
  (app Args (top-list (- FrameSize (len args)))))


(<span class="keyword">defun</span> <span class="function-name">translate-type</span> (type)<span class="comment">;; *** 
</span>  (<span class="keyword">cond</span> ((equal type 'boolean) 'int)
        ((equal type 'byte)    'int)
        ((equal type 'short)   'int)
        ((equal type 'char)    'int)
        (t type))) 

<span class="comment">;;*** this method corresponds to the special treatment in 
;; signature.pl. util.pl the ----- primitiveArrayInfo
</span>
(<span class="keyword">defun</span> <span class="function-name">translate-types</span> (types)
  (<span class="keyword">if</span> (endp types)
      nil
    (cons (translate-type (car types))
          (translate-types (cdr types)))))

(<span class="keyword">defun</span> <span class="function-name">methodInitialStackFrame</span> (Class Method FrameSize)<span class="comment">;; *4* 
</span>  (<span class="keyword">let*</span> ((RawArgs1 (methodParameters Method))
         (RawArgs  (translate-types RawArgs1))
         (Args     (expandTypeList RawArgs))    
         (ThisList (methodInitialThisType Class Method))
         (Flags    (Flags ThisList))
         (ThisArgs (append ThisList Args))
         (Locals   (expandToLength ThisArgs FrameSize)))
    (make-sig-frame 
     Locals  nil Flags)))


<span class="comment">;; *4* Note: 
;;     Assume Well Formed Stack
;;
</span>


<span class="comment">;;--------------------------------------------------------------
;;
;;  WellFormed Predicates 
;;
;;-------------------------------------------------------------- 
</span>
(<span class="keyword">defun</span> <span class="function-name">isWellFormedCodeAttribute</span> (Class Method) 
  (<span class="keyword">declare</span> (ignore Class Method))
  t)<span class="comment">;; *5* 
</span>
<span class="comment">;; *5* Note:  omitted here.   Feb 23
;;     To prove Properties, we eventually need this predicate 
</span>


<span class="comment">;;-----------------------------------
;;
;;  Create a StackMap 
;;  
;;----------------------------------- 
</span>
<span class="comment">;; &lt;stackmap&gt; ::= (stack_map (&lt;offset&gt; &lt;frame&gt;))
;; 
;; &lt;offset&gt; in bytes.
;; &lt;frame&gt;  refer to (defun make-sig-frame  ...)
</span>
(<span class="keyword">defun</span> <span class="function-name">makeStackMap</span> (map)<span class="comment">;; *6*
</span>  (list 'stack_map map))

<span class="comment">;; the only purpose of makeStackMap is to distinguish StackMap and
;; instructions in a MergedStackMapAndCode.
</span>

<span class="comment">;; ---- StackMap Accessor -----
</span>
(<span class="keyword">defun</span>  <span class="function-name">mapOffset</span> (map)
  (car map))

(<span class="keyword">defun</span>  <span class="function-name">mapFrame</span> (map)
  (cadr map))

(<span class="keyword">defun</span>  <span class="function-name">getMap</span> (StackMapFrame)
  (cadr StackMapFrame))

<span class="comment">;; ---  StackMap Recognizor ---- 
</span>
(<span class="keyword">defun</span> <span class="function-name">isStackMapFrame</span> (StackMapFrame)
  (and (consp StackMapFrame)
       (equal (car StackMapFrame) 'stack_map)))


<span class="comment">;; OUTDATED --- FEB 23.
;;   
;; don't deal with byte offset, assume all reference to the code is in
;; instruction offsets. StackMap's offset is translated into instruction
;; offset. 
;; 
;; UPDATE   --- All offset mentioned is in Bytes. 
;;  including: instruction offset, exception handler offset, stackMap offset
;;  Offset measured in bytes.   
</span>



<span class="comment">;; ---- Instruction Accessor -----
</span>
<span class="comment">;; &lt;instruction&gt; ::= (&lt;offset&gt; (&lt;opcode&gt; [&lt;args&gt;]))
</span>
(<span class="keyword">defun</span> <span class="function-name">instrOffset</span> (instr)
  (car instr))

(<span class="keyword">defun</span> <span class="function-name">instrBody</span> (instr)
  (cadr instr))



<span class="comment">;; ---- Instruction Recognizer ----
</span>
(<span class="keyword">defun</span> <span class="function-name">isInstruction</span> (carMergedCode)<span class="comment">;; *7*
</span>  (and (consp carMergedCode)
       (consp (cadr carMergedCode))
       (integerp (instrOffset carMergedCode))))


(<span class="keyword">defun</span> <span class="function-name">isStackMap</span> (carMergedCode)
  (and (consp carMergedCode)
       (equal (car carMergedCode) 'stack_map)))

<span class="comment">;; *7* Note: 
;;     Called to distinguish from StackMap. 
;;     refer to mergeStackMapAndCode
</span>

<span class="comment">;; ---- endOfCode Recognizer ----
</span>
(<span class="keyword">defun</span> <span class="function-name">isEnd</span> (carMergedCode)
  (and (consp carMergedCode)
       (equal (car carMergedCode) 'endofcode)))



<span class="comment">;;----------------------------------------------
;;
;;  Merge StackMap Attribute with Instructions
;;  
;;---------------------------------------------- 
</span>

<span class="comment">;; (defun mergeStackMapAndCode (maps ParsedCode)
;;   (if (endp maps)
;;       ParsedCode  
;;     (if (endp ParsedCode);; *8*
;;         maps
;;       (let ((mpc (mapOffset (car maps)))
;;             (pc  (instrOffset (car ParsedCode))))
;;         (if (equal mpc pc)
;;             (cons (makeStackMap (car maps))
;;                   (cons (car ParsedCode)
;;                         (mergeStackMapAndCode  (cdr maps)
;;                                                (cdr ParsedCode))))
;;           (if (&lt; pc mpc)
;;               (cons (car ParsedCode)  
;;                     (mergeStackMapAndCode maps (cdr ParsedCode)))
;;             (cons (makeStackMap (car maps))
;;                   (cons (car ParsedCode)
;;                         (mergeStackMapAndCode  (cdr maps)
;;                                                (cdr ParsedCode))))))))))
</span>

<span class="comment">;;; Wed Jul 27 23:58:26 2005
;;; Wed Jul 27 23:58:28 2005
</span>
<span class="comment">;;; Problem
;;; We have to assert that 
;;; If there is StackMap, then next instruction from the code, must be 
;;; at the same PC location!!! 
;;; 
;;; Otherwise, we could not prove the theorem in base-bcv.lisp!! 
;;; 
</span>
(<span class="keyword">defun</span> <span class="function-name">mergeStackMapAndCode</span> (maps ParsedCode)
  (<span class="keyword">if</span> (endp maps)
      ParsedCode  
    (<span class="keyword">if</span> (endp ParsedCode)<span class="comment">;; *8*
</span>        nil <span class="comment">;; second modification ;; Thu Jul 28 00:28:23 2005
</span>      (<span class="keyword">let</span> ((mpc (mapOffset (car maps)))
            (pc  (instrOffset (car ParsedCode))))
        (<span class="keyword">if</span> (equal mpc pc)
            (cons (makeStackMap (car maps))
                  (cons (car ParsedCode)
                        (mergeStackMapAndCode  (cdr maps)
                                               (cdr ParsedCode))))
          (<span class="keyword">if</span> (&lt; pc mpc)
              (cons (car ParsedCode)  
                    (mergeStackMapAndCode maps (cdr ParsedCode)))
            nil)))))) <span class="comment">;; something is wrong here!!!  
</span>            <span class="comment">;;; because we always expect that a stack map appears right before
</span>            <span class="comment">;;; a corresponding code with the same PC!!
</span>            <span class="comment">;;; Thu Jul 28 00:03:39 2005
</span>

<span class="comment">;; unreachable nil if the Class file is well formed. WRONG 
</span>
<span class="comment">;; Assumption ParsedCode is a truelistp
</span>          

<span class="comment">;; *8* Note: 
;;      It is impossible for parsed code to end first?
;;      hanbing -- however for acl2 to admit the function we have to
;;      add this.
</span>


<span class="comment">;;----------------------------------------------
;;
;;  Collect Environment Object
;;  
;;---------------------------------------------- 
</span>

<span class="comment">;; Thu Dec 22 16:03:20 2005. note. the ReturnType is not used in this
;; definition!! 
;; 
</span>(<span class="keyword">defun</span> <span class="function-name">makeEnvironment</span> (Class Method ReturnType MergedCode MaxStack Handlers CL)  
  (list Class Method ReturnType MergedCode MaxStack Handlers CL))

(<span class="keyword">defun</span> <span class="function-name">AllInstructions</span> (Environment)
  (nth 3 Environment))

(<span class="keyword">defun</span> <span class="function-name">exceptionHandlers</span> (Environment)
  (nth 5 Environment))

(<span class="keyword">defun</span> <span class="function-name">classtableEnvironment</span> (Environment)
  (nth 6 Environment))

(<span class="keyword">defun</span> <span class="function-name">maxStackEnvironment</span> (Environment)
  (nth 4 Environment))

(<span class="keyword">defun</span> <span class="function-name">classEnvironment</span> (Environment)
  (nth 0 Environment))

(<span class="keyword">defun</span> <span class="function-name">thisClassEnvironment</span> (Environment)
  (classClassName (classEnvironment Environment)))


(<span class="keyword">defun</span> <span class="function-name">methodEnvironment</span> (Environment)
  (nth 1 Environment))



<span class="comment">;; -------------------------------------------
;;
;;  Type Hierachy 
;;
;; -------------------------------------------
</span>
        
<span class="comment">;; OUTDATED -- Feb 23, ????
;;   how to define isAssignable? without Dynamic Loading?? 
;;   Don't what to deal with long and double, just assuming 
;;
;; UPDATE  
;;   Deal with Long and Double. 
;;   Assuming jvm2acl2 translate the "long" to "long top" etc. 
</span>

<span class="comment">;; (defun isClassType (t1)
;;   (or (equal t1 'null)
;;   (and (consp t1)
;;        (equal (car t1) 'class))))
</span>
<span class="comment">;; Sun Mar 28 15:43:56 2004
</span>
(<span class="keyword">defun</span> <span class="function-name">isNullType</span> (t1)
  (equal t1 'null))

(<span class="keyword">defun</span> <span class="function-name">isClassType</span> (t1)
  (and (consp t1)
       (equal (len t1) 2)
       (true-listp t1)
       (equal (car t1) 'class)))



<span class="comment">;; (defun isClassType (t1)
;;   (and (consp t1)
;;        (equal (car t1) 'class)))
</span>
<span class="comment">;;; Old definition. not enough. 
;;; Thu Apr  7 12:52:05 2005
</span>
  
<span class="comment">;; (defun isArrayType (t1)
;;   (or (equal t1 'null)
;;       (and (consp t1)
;;            (equal (car t1) 'array))))
</span>
<span class="comment">;; Sun Mar 28 15:44:01 2004
</span>
<span class="comment">;; (defun isArrayType (t1)
;;   (and (consp t1)
;;        (equal (car t1) 'array)))
</span>
(<span class="keyword">defun</span> <span class="function-name">isArrayType</span> (t1)
   (and (consp t1)
        (equal (len t1) 2)
        (true-listp t1)
        (equal (car t1) 'array)))


(<span class="keyword">defun</span> <span class="function-name">isUninitializedObject</span> (t1)
  (and (consp t1)
       (equal (car t1) 'uninitialized)))
  

(<span class="keyword">defun</span> <span class="function-name">isAssignableMeasure</span> (t1)
  (<span class="keyword">cond</span> ((equal t1 'oneWord) 1)
        ((equal t1 'twoWord) 1)
        ((equal t1 'int)     2)
        ((equal t1 'float)   2)
        ((equal t1 'long)    2)
        ((equal t1 'double)  2)
        ((equal t1 'reference) 2)
        ((equal t1 'uninitialized) 3)
        ((isClassType t1) 4)
        ((isArrayType t1) 4)
        ((equal t1 'uninitializedThis) 4)
        ((isUninitializedObject t1) 4)
        ((equal t1 'null)  5)
        (t 0)))

<span class="comment">; --- accessor ----
</span>
(<span class="keyword">defun</span> <span class="function-name">name-of</span> (aClassType)
  (cadr aClassType))<span class="comment">;; need to apply on aClassType
</span>
<span class="comment">; --- check if not primitive type ---
</span>(<span class="keyword">defun</span> <span class="function-name">compound</span> (x)
  (consp x))

<span class="comment">; -- used only on arrayType
</span>
<span class="comment">;; (defun component-type (aArrayType)
;;   (if (isArrayType aArrayType)
;;       (cadr aArrayType)
;;     nil));; indicate undefined
</span>

<span class="comment">;;; Thu Apr 14 15:24:35 2005
</span>
(<span class="keyword">defun</span> <span class="function-name">component-type</span> (aArrayType)
  (cadr aArrayType))




<span class="comment">; --- class-by-name ---
</span>
<span class="comment">; &lt;class-table&gt; ::= (&lt;classterm&gt; ... )
</span>
(<span class="keyword">defun</span> <span class="function-name">class-by-name</span> (name classtable)<span class="comment">;; *13*
</span>  (<span class="keyword">if</span> (endp classtable)
      nil
    (<span class="keyword">if</span> (equal (classClassName (car classtable)) name)
        (car classtable)
      (class-by-name name (cdr classtable)))))

<span class="comment">;; *13* Note:: 
;;      like assoc-equal  classtable is a list of classes
;;      to use class-by-name need to check (classClassName Class) 
;; 
;; assuming classtable is well formed, a list of ClassTerm
</span>


<span class="comment">;; -------------------------------------------------------
;;
;;  Proof Script: SuperClass Resolution Process terminate
;; 
;; -------------------------------------------------------
</span>


<span class="comment">;; ;;  ----- Basic Set Theory Stuff ----
</span>
<span class="comment">;; ;----------------------------------------------------------
</span>
<span class="comment">;; (defun set-diff (total seen);; *14* 
;;   (if (endp total)
;;       nil
;;     (if (mem (car total) seen)
;;         (set-diff (cdr total) seen)
;;       (cons (car total) (set-diff (cdr total) (cons (car total) seen))))))
</span>
<span class="comment">;; ;; *14* Note: 
;; ;;       Set-Diff returns a non-duplicated list that represent
;; ;;       the set
</span>
<span class="comment">;; ;; some work  Set Theory stuff
;; ;; mainly about set-diff, nodup-set, the size of the nodup-set
;; ;;
;; ;; this is used for proving termination of class superclass resolution
</span>
<span class="comment">;; ;; Originally. I did somework with permuation. 
;; ;; Later found out Set-equal + Non-Dup suffice.
</span>
<span class="comment">;; (defun set-equal (a b)
;;   (and (subset a b)
;;        (subset b a)))
</span>
<span class="comment">;; (defthm mem-subset
;;   (implies (and (subset a b)
;;                 (mem x a))
;;            (mem x b)))
</span>
<span class="comment">;; (defthm subset-cons 
;;   (implies (subset a b)
;;            (subset a (cons x b))))
</span>
<span class="comment">;; (defthm subset-reflexive 
;;   (subset x x))
</span>
<span class="comment">;; (defthm subset-transitive 
;;   (implies (and (subset a b)
;;                 (subset b c))
;;            (subset a c)))
</span>

<span class="comment">;; (defthm set-equal-transitive
;;   (implies (and (set-equal a b)
;;                 (set-equal b c))
;;            (set-equal a c)))
</span>
<span class="comment">;; (defequiv set-equal)
</span>

<span class="comment">;; (defcong set-equal equal (mem x s) 2
;;   :hints (("Subgoal *1/4" :cases ((mem x (cdr s))))
;;           ("Subgoal *1/4.2'" 
;;            :use (:instance mem-subset  (a s-equiv) (b s))
;;            :in-theory (disable mem-subset))))
</span>


<span class="comment">;; (defthm set-equal-cons
;;   (implies (set-equal a b)
;;            (set-equal (cons x a) (cons x b))))
</span>

<span class="comment">;; (defthm set-equal-mem-cons-2
;;   (implies (mem x l)
;;            (set-equal (cons x l) l)))
</span>                                             
<span class="comment">;; (in-theory (disable set-equal))
</span>

<span class="comment">;; (defun set-diff-cong-induct (s s-equiv total)
;;   (if (endp total)
;;       (cons s s-equiv)
;;     (if (mem (car total) s)
;;         (set-diff-cong-induct s s-equiv (cdr total))
;;       (set-diff-cong-induct (cons (car total) s) (cons (car total) s-equiv) (cdr total)))))
</span>

<span class="comment">;; (defcong set-equal equal (set-diff total seen) 2
;;   :hints (("Goal" :induct (set-diff-cong-induct seen seen-equiv total))))
</span>

<span class="comment">;; (defun subset-set-diff-induct (total a b)
;;   (if (endp total)
;;       (cons a b)
;;     (subset-set-diff-induct (cdr total) (cons (car total) a) (cons (car total) b)))) 
</span>  

<span class="comment">;; (defthm subset-set-diff
;;   (implies (subset a b) 
;;            (subset (set-diff total b) (set-diff total a)))
;;   :hints (("Goal" :induct (subset-set-diff-induct total a b))))
</span>

<span class="comment">;; ;;-------------------------------------------------------------------- 
</span>
<span class="comment">;; ; ---- nodup-set ----- 
</span>
<span class="comment">;; (defun nodup-set (s)
;;   (if (endp s)
;;       t
;;     (and (not (mem (car s) (cdr s)))
;;          (nodup-set (cdr s)))))
</span>

<span class="comment">;; (defthm mem-set-diff
;;   (implies (mem a seen)
;;            (not (mem a (set-diff total seen)))))
</span>

<span class="comment">;; (defthm set-diff-is-a-nodup-set
;;   (nodup-set (set-diff total seen))
;;   :rule-classes :type-prescription)
</span>

<span class="comment">;; (defun subset-nodup-set-size-induct (s1 s2)
;;   (if (endp s1)
;;       s2
;;     (subset-nodup-set-size-induct (cdr s1) (del (car s1) s2))))
</span>
<span class="comment">;; (defthm del-set-len
;;   (implies (mem x s)
;;            (equal (len s)  (+ 1 (len (del x s))))))     
</span>
<span class="comment">;; (defthm mem-del 
;;   (implies (not (equal a b))
;;            (equal (mem a (del b x))
;;                   (mem a x))))
</span>           
<span class="comment">;; (defthm del-nodups
;;   (implies (nodup-set s)
;;            (nodup-set (del x s))))
</span>

<span class="comment">;; (defthm del-nodup-set-subset
;;   (implies (and (subset (cons x s1) s2)
;;                 (nodup-set (cons x s1)))
;;            (subset s1 (del x s2))))
</span>
<span class="comment">;; ; --- to talk about termination, we talk about the number of unseen
;; ; --- classes decrease.
</span>

<span class="comment">;; (defthm subset-nodup-set-size
;;   (implies (and (subset s1 s2)
;;                 (nodup-set s1)
;;                 (nodup-set s2))
;;            (&lt;= (len s1) (len s2)))
;;   :hints (("Goal" :induct (subset-nodup-set-size-induct s1 s2)))
;;   :rule-classes :linear)
</span>

<span class="comment">;; (defun len-set-equal-nodup-set-x-induct (s1 s2)
;;   (if (endp s1)
;;       s2
;;     (len-set-equal-nodup-set-x-induct (cdr s1) (del (car s1) s2))))
</span>
<span class="comment">;; (defthm  len-set-equal-nodup-set-x
;;   (implies (and (mem a s2)
;;                 (not (mem a s1))
;;                 (subset s1 s2)
;;                 (nodup-set s1)
;;                 (nodup-set s2))
;;            (&lt; (len s1) (len s2)))
;;   :hints (("Goal" :induct (len-set-equal-nodup-set-x-induct s1 s2))))
</span>

<span class="comment">;; (defthm mem-set-diff-x
;;   (implies (and (mem a total)
;;                 (not (mem a seen)))
;;            (mem a (set-diff total seen))))
</span>

<span class="comment">;; (defthm len-set-diff-mem
;;   (implies (and (not (mem a seen)) 
;;                 (mem a total))
;;            (&lt; (len (set-diff total (cons a seen)))
;;               (len (set-diff total seen))))
;;   :hints (("Goal" :do-not-induct t
;;            :use ((:instance len-set-equal-nodup-set-x
;;                             (s1 (set-diff total (cons a seen)))
;;                             (s2 (set-diff total seen))))))
;;   :rule-classes :linear)
</span>           
<span class="comment">;; ;; ----------- Above enough rules about set-diff -----------
</span>




<span class="comment">;; --------------------------------------------------------
;;
;;  Well Formed Direct SuperClass Relation Specification 
;;
;; --------------------------------------------------------
</span>

<span class="comment">;; Write out the predicate that ensure that superclass doesn't contain
;; loops.  This requirement is needed to guarantee the superclass
;; resolving won't run forever. 
</span>

<span class="comment">;;; We may want to share the isAssignableTest with DJVM. But for now. We keep
;;; them separate. It is not hard to prove those two are equivalent..  
</span>
(<span class="keyword">defun</span> <span class="function-name">all-class-names</span> (cl)
  (<span class="keyword">if</span> (endp cl)
      nil
    (cons (classClassName (car cl))
          (all-class-names (cdr cl)))))

(<span class="keyword">defun</span> <span class="function-name">unseen-class-measure</span> (seen cl)
  (len (set-diff (all-class-names cl) seen)))

(<span class="keyword">defun</span> <span class="function-name">superclass-no-loop1-measure</span> (seen cl)
  (len (set-diff (all-class-names cl) seen)))

(defthm class-by-name-all-class-names
  (implies (isClassTerm (class-by-name n1 cl)) 
           (mem n1 (all-class-names cl))))

(in-theory (disable isClassTerm class-by-name))

(<span class="keyword">defun</span> <span class="function-name">superclass-no-loop1</span> (n1 cl seen)
  (<span class="keyword">declare</span> (xargs <span class="builtin">:measure</span> (superclass-no-loop1-measure seen cl)))
  (<span class="keyword">let*</span> ((theClass (class-by-name n1 cl))
         (n2 (classSuperClassName theClass)))
    (<span class="keyword">if</span>  (not (isClassTerm theClass)) t
      (<span class="keyword">if</span> (mem n1 seen)
          nil
        (superclass-no-loop1 n2 cl (cons n1 seen))))))


(<span class="keyword">defun</span> <span class="function-name">superclass-no-loop</span> (n1 cl)
  (superclass-no-loop1 n1 cl nil))
   
(<span class="keyword">defun</span> <span class="function-name">collect-superclass-list1</span> (n1 cl ss)
  (<span class="keyword">declare</span> (xargs <span class="builtin">:measure</span> (superclass-no-loop1-measure ss cl)))
  (<span class="keyword">let*</span> ((theClass (class-by-name n1 cl))
         (n2 (classSuperClassName theClass)))
    (<span class="keyword">if</span> (isClassTerm theClass)
        (<span class="keyword">if</span> (mem n1 ss)
            nil
          (cons n1 (collect-superclass-list1 n2 cl (cons n1 ss))))
      nil)))
             
(<span class="keyword">defun</span> <span class="function-name">collect-superclass-list</span> (n1 cl)
  (collect-superclass-list1 n1 cl nil))

<span class="comment">; --- proofs for collect-superclass-list increase --- 
</span>
      
<span class="comment">;; (defcong set-equal equal (collect-superclass-list1 n cl ss) 3)
</span>
(DEFTHM
  SET-EQUAL-IMPLIES-EQUAL-BCV-COLLECT-SUPERCLASS-LIST1-3
  (IMPLIES
   (SET-EQUAL SS SS-EQUIV)
   (EQUAL
    (COLLECT-SUPERCLASS-LIST1 N CL SS)
    (COLLECT-SUPERCLASS-LIST1 N CL SS-EQUIV)))
  <span class="builtin">:RULE-CLASSES</span> (<span class="builtin">:CONGRUENCE</span>))      


(defthm set-equal-cons-cons
  (set-equal (cons x (cons y a))
             (cons y (cons x a)))
  <span class="builtin">:hints</span> ((<span class="string">"Goal"</span> <span class="builtin">:in-theory</span> (enable set-equal))))


<span class="comment">; ---- important observation I  -----
;
; If X doesn't belongs to superclasses of N, add it to SS doesn't matter
;
; SS represents the set that can't be superclasses of N under well formed
; Direct SuperClass Relation.
</span>
(defthm collect-superclass-list1-non-mem-cons
  (implies (and (not (mem x (collect-superclass-list1 n cl ss)))
                (superclass-no-loop1 n cl ss))
           (equal (collect-superclass-list1 n cl (cons x ss))
                  (collect-superclass-list1 n cl ss))))

<span class="comment">;; (defcong set-equal equal (superclass-no-loop1 n cl ss) 3)
</span>
(acl2::set-match-free-default <span class="builtin">:all</span>)

(DEFTHM
  SET-EQUAL-IMPLIES-EQUAL-BCV-SUPERCLASS-NO-LOOP1-3
  (IMPLIES
   (SET-EQUAL SS SS-EQUIV)
   (EQUAL (SUPERCLASS-NO-LOOP1 N CL SS)
          (SUPERCLASS-NO-LOOP1 N CL SS-EQUIV)))
  <span class="builtin">:RULE-CLASSES</span> (<span class="builtin">:CONGRUENCE</span>))


(defthm superclass-no-loop1-cons
  (implies (superclass-no-loop1 n cl (cons x ss))
           (superclass-no-loop1 n cl ss)))


<span class="comment">; ---- important obseration II -----
;
; If superclass-no-loop is true, none of the superclasses of N can
; appear in SS.
</span>(defthm mem-collect-superclass-no-loop
  (implies (mem n (collect-superclass-list1 n1 cl ss))
           (not (superclass-no-loop1 n1 cl (cons n ss)))))




<span class="comment">; --- this also basically
;   (cdr (collect-superclass-list A cl))
;                   = (collect-superclass-list (super A cl))
</span>(defthm collect-superclass-list1-equal-2
  (implies (and (superclass-no-loop1 n1 cl ss)
                (isClassTerm (class-by-name n1 cl)))
           (equal (collect-superclass-list1 (classSuperClassName (class-by-name n1 cl))
                                            cl 
                                            (cons n1 ss))
                  (collect-superclass-list1 (classSuperClassName (class-by-name n1 cl))
                                            cl
                                            ss)))
  <span class="builtin">:hints</span> ((<span class="string">"Goal"</span> <span class="builtin">:in-theory</span> (disable classSuperClassName isClassTerm
                                      collect-superclass-list1-non-mem-cons)
           <span class="builtin">:use</span> ((<span class="builtin">:instance</span> collect-superclass-list1-non-mem-cons
                            (x n1)
                            (n (classSuperClassName (class-by-name n1 cl))))))))


(defthm collect-superclass-list1-equal-1 
  (implies (and (superclass-no-loop1 n1 cl ss)
                (isClassTerm (class-by-name n1 cl)))
           (equal (collect-superclass-list1 n1 cl ss)
                  (cons n1 (collect-superclass-list1 (classSuperClassName (class-by-name n1 cl))
                                                     cl 
                                                     ss))))
  <span class="builtin">:hints</span> ((<span class="string">"Goal"</span> <span class="builtin">:in-theory</span> (disable classSuperClassName)
           <span class="builtin">:use</span> collect-superclass-list1-equal-2)))




<span class="comment">;; termination of superclass resolving LOADING
;------------------------------------------------------------------
</span>
(<span class="keyword">defun</span> <span class="function-name">isJavaSubClassOf-measure</span> (n1 cl)
  (len (collect-superclass-list n1 cl)))



(<span class="keyword">defun</span> <span class="function-name">isJavaSubclassOf</span> (n1 n2 cl)
  (<span class="keyword">declare</span> (xargs <span class="builtin">:measure</span> (isJavaSubClassOf-measure n1 cl)))
  (and (superclass-no-loop n1 cl)<span class="comment">;; *15*
</span>       <span class="comment">;; only need for proving termination.
</span>       (isClassTerm (class-by-name n1 cl))
       (or <span class="comment">;; (equal n2 "java.lang.Object") ;; short cut!! 
</span>           <span class="comment">;; Sun Apr 10 21:39:55 2005
</span>           (equal n1 n2)
           (<span class="keyword">let*</span> ((SubClass (class-by-name n1 cl))
                  (n3 (classSuperClassName SubClass)))
             (isJavaSubclassOf n3 n2 cl)))))

<span class="comment">;; *15* Note:
;;      Add this predicate. So that we can prove 
;;      this resolution process terminate
;; 
;; The isJavaSubclassOf can be proved to terminate if
;; superclass-no-loop n1 is true.
</span>

<span class="comment">#| Superinterface relation is removed from bytecode verifier |#</span>

<span class="comment">#|
(defun isArrayInterface (t1)
  (or (equal t1 '(class "java.lang.Cloneable"))
      (equal t1 '(class "java.util.Serializable"))))

|#</span> 
<span class="comment">;; java.lang.Cloneable, java.util.Serializable does not exists
</span>
(<span class="keyword">defun</span> <span class="function-name">isArrayInterface</span> (t1)
  (<span class="keyword">declare</span> (ignore t1))
  nil)
           

(<span class="keyword">defun</span> <span class="function-name">isJavaAssignable</span> (t1 t2 cl)
  (<span class="keyword">cond</span> ((and (isClassType t1)
              (isClassType t2))
           (or (<span class="keyword">let</span> ((ToClass (class-by-name (name-of t2) cl)))
                 (classIsInterface ToClass))<span class="comment">;; rule 1
</span>                 (isJavaSubClassOf (name-of t1) (name-of t2) cl)))<span class="comment">;; rule 2
</span>        ((and (isArrayType t1)
              (isClassType t2))
         (or (equal '(class <span class="string">"java.lang.Object"</span>) t2)
             (classIsInterface (class-by-name (name-of t2) cl))
             <span class="comment">;; NEW ADDITIONS TO KEEP
</span>             <span class="comment">;; isJavaAssignable Transitive!!  ;;; Thu Apr  7 16:39:45 2005
</span>             <span class="comment">;; NOTE: Deviate from the CLDC BCV SPEC!! 
</span>             (isArrayInterface (name-of t2))))
        ((and (isArrayType t1)
              (isArrayType t2))
         (<span class="keyword">let</span> ((x (component-type t1))
               (y (component-type t2)))
           (or (and (atom x)
                    (atom y)
                    (equal x y))
               (and (compound x)
                    (compound y)
                    (isJavaAssignable x y cl)))))))

<span class="comment">;; Sun Mar 28 16:17:22 2004: not transitive!! fix it to make it transitive.
;; We know array in cldc does not implement any interface. 
;; so the above optimization should be ok. 
</span>
<span class="comment">;;
;; But it change class verificaiton expection into a runtime exception!!
;;
</span>
<span class="comment">;; (defun isJavaAssignable (t1 t2 cl)
;;   (cond ((and (isClassType t1)
;;               (isClassType t2))
;;            (or (let ((ToClass (class-by-name (name-of t2) cl)))
;;                  (classIsInterface ToClass));; rule 1
;;                  (isJavaSubClassOf (name-of t1) (name-of t2) cl)));; rule 2
;;         ((isClassType t2)  ;; new additions to make it transitive!!
;;          (classIsInterface (class-by-name (name-of t2) cl))) 
;;         ((and (isArrayType t1)
;;               (isClassType t2))
;;          (or (equal '(class "java.lang.Object") t2)
;;              (isArrayInterface (name-of t2))))
;;         ((and (isArrayType t1)
;;               (isArrayType t2))
;;          (let ((x (component-type t1))
;;                (y (component-type t2)))
;;            (or (and (atom x)
;;                     (atom y)
;;                     (equal x y))
;;                (and (compound x)
;;                     (compound y)
;;                     (isJavaAssignable x y cl)))))))
</span>

                  
<span class="comment">;; hack for testing the top level program flow
#|  
(defun isAssignable (t1 t2 env)
  (declare (ignore t1 t2 env))
  t)
|#</span>  



(<span class="keyword">defun</span> <span class="function-name">isAssignable</span> (t1 t2 Env)
  <span class="comment">;; complicated
</span>  (<span class="keyword">declare</span> (xargs <span class="builtin">:measure</span> (isAssignableMeasure t1)))
  (<span class="keyword">let</span> ((cl (classtableEnvironment Env)))
    (<span class="keyword">if</span> (equal t1 t2) 
        t
      (<span class="keyword">cond</span> ((and (equal t1 'oneWord)
                  (equal t2 'topx)) t)
            ((and (equal t1 'twoWord) 
                  (equal t2 'topx)) t)
            ((equal t1 'int) 
             (isAssignable 'oneWord t2 Env))
            ((equal t1 'float)
             (isAssignable 'oneWord t2 Env))
            ((equal t1 'long) 
             (isAssignable 'twoWord t2 Env))
            ((equal t1 'double) 
             (isAssignable 'twoWord t2 Env))
            ((equal t1 'reference) 
             (isAssignable 'oneWord t2 Env))
            ((equal 'uninitialized t1)
             (isAssignable 'reference t2 Env))
            ((isClassType t1) 
             (or (isAssignable 'reference t2 Env)
                 (isJavaAssignable t1 t2 cl)))
            ((isArrayType t1)
             (or
              (isAssignable 'reference t2 Env)
              (and (isClassType t2)
                   (isJavaAssignable t1 t2 cl))
              (and (isArrayType t2)
                   (isJavaAssignable t1 t2 cl))))
            ((equal t1 'uninitializedThis)
             (isAssignable 'uninitialized t2 Env))
            ((isUninitializedObject t1)
             (isAssignable 'uninitialized t2 Env))
            ((isNullType t1)
             (or
              (isClassType t2)
              (isArrayType t2)
              (isAssignable
               '(class <span class="string">"java.lang.Object"</span>) t2 Env)))
            (t nil)))))

<span class="comment">;;
;; Guarantee there (Array NULL) is not a valid type!!
</span>
<span class="comment">;; isAssignable(X, X) :- !.
;;
;; isAssignable(oneWord, topx).
;; isAssignable(twoWord, topx).
;;
;; isAssignable(int,           X) :- isAssignable(oneWord, X).
;; isAssignable(float,         X) :- isAssignable(oneWord, X).
;; isAssignable(long,          X) :- isAssignable(twoWord, X).
;; isAssignable(double,        X) :- isAssignable(twoWord, X).
;; isAssignable(reference,     X) :- isAssignable(oneWord, X).
</span>
<span class="comment">;; isAssignable(uninitialized, X) :- isAssignable(reference, X).
</span>
<span class="comment">;; % These rules may seem strange, but in some cases they have advantages.
;; % The rule below allows us to avoid loading classes when comparing
;; % them to the top types in the hierarchy.
</span>
<span class="comment">;; isAssignable(class(_),   X) :- isAssignable(reference, X).
;; isAssignable(arrayOf(_), X) :- isAssignable(reference, X).
</span>
<span class="comment">;; isAssignable(uninitializedThis, X) :- isAssignable(uninitialized, X).
;; isAssignable(uninitialized(_),    X) :- isAssignable(uninitialized, X).
</span>
<span class="comment">;; isAssignable(null, class(_)).
;; isAssignable(null, arrayOf(_)).
;; isAssignable(null, X)  :- isAssignable(class('java/lang/Object'), X).
</span>
<span class="comment">;; isAssignable(class(X), class(Y)) :- isJavaAssignable(class(X), class(Y)).
;; isAssignable(arrayOf(X), class(Y)) :- isJavaAssignable(arrayOf(X), class(Y)).
;; isAssignable(arrayOf(X), arrayOf(Y)) :- isJavaAssignable(arrayOf(X),arrayOf(Y)).
</span>

<span class="comment">;; % For assignments, interface = Object
</span>


<span class="comment">;; (defun typeListAssignable (l1 l2 env)
;;   (cond ((endp l1) (endp l2))
;;         ((endp l2) nil)
;;         (t (and (isAssignable (car l1) (car l2) env)
;;                 (typeListAssignable (cdr l1) (cdr l2) env)))))
</span>
<span class="comment">;; ;;; What would happen if it is size 2 object? Tue Feb  1 13:47:16 2005
;; ;;; proof ... 
</span>

<span class="comment">;; shall we make it more complicated?  Tue Feb  1 13:51:56 2005
;;
</span>
<span class="comment">;; A = (INT LONG ...)
;; B = (TOP LONG ...)
;; A list assignable to B? 
;; This old version: Yes. 
;; 
;; New Version no. 
;; The problem how we differ from OPSTACK list and local list! 
;; 
</span>
(<span class="keyword">defun</span> <span class="function-name">typeListAssignable</span> (l1 l2 env)
   (<span class="keyword">cond</span> ((endp l1) (endp l2))
         ((endp l2) nil)
         (t (and (isAssignable (car l1) (car l2) env)
                 (typeListAssignable (cdr l1) (cdr l2) env)))))



<span class="comment">;; (frame (local &lt;typelist&gt;) (stack &lt;typelist&gt;) (&lt;flags&gt;))
</span>
(<span class="keyword">defun</span> <span class="function-name">frameIsAssignable</span> (Frame1 Frame2 env) 
  (<span class="keyword">let</span> ((Locals1 (frameLocals Frame1))
        (Locals2 (frameLocals Frame2))
        (StackMap1 (frameStack Frame1))
        (StackMap2 (frameStack Frame2))
        (Flags1  (frameFlags Frame1))
        (Flags2  (frameFlags Frame2)))
    (and (equal (len StackMap1) 
                (len StackMap2))
         (typeListAssignable Locals1 Locals2 env)
         (typeListAssignable StackMap1 StackMap2 env)
         (subset Flags1 Flags2))))





<span class="comment">;;----------------------------------------------
;;
;;  Individual Instruction Semantics 
;;  
;;---------------------------------------------- 
</span>
<span class="comment">;--- primitive for operand stack ---
</span>
<span class="comment">;; (defun pop (stack);; safe pop
;;   (if (consp stack)
;;       (cdr stack)
;;     nil));; indicate undefined
</span>
<span class="comment">;; (defun push (value stack)
;;   (cons value stack))
</span>
<span class="comment">;; (defun top (stack);; safe top
;;   (if (consp stack)
;;       (car stack)
;;     nil));; indicate undefined.
</span>
<span class="comment">;;;
;;; Tue Aug 16 15:03:02 2005
;;;
</span>
(<span class="keyword">defun</span> <span class="function-name">top</span> (stack)
  (<span class="keyword">declare</span> (xargs <span class="builtin">:guard</span> (consp stack)))
  (car stack))

(<span class="keyword">defun</span> <span class="function-name">pop</span> (stack)
  (<span class="keyword">declare</span> (xargs <span class="builtin">:guard</span> (consp stack)))
  (cdr stack))

(<span class="keyword">defun</span> <span class="function-name">push</span> (value stack)
  (cons value stack))


<span class="comment">;; Sat May 21 19:40:27 2005
;;
;; I could make this into a shared package!! 
;; (acl2::set-verify-guards-eagerness 0)
</span>
<span class="comment">;; (defun pop (stack)
;;   (DECLARE (XARGS :GUARD (CONSP STACK)))
;;   (cdr stack))
</span>
<span class="comment">;; (defun push (value stack)
;;   (cons value stack))
</span>
<span class="comment">;; (DEFUN TOP (STACK)
;;   (DECLARE (XARGS :GUARD (CONSP STACK)))
;;   (CAR STACK))
</span>

(<span class="keyword">defun</span> <span class="function-name">popn</span> (n stack)
  (<span class="keyword">if</span> (zp n)
      stack
    (popn (- n 1) (pop stack))))

(<span class="keyword">defun</span> <span class="function-name">op-code</span> (<a href="../DJVM/INST/inst.lisp.html">inst</a>) (car (<a href="../DJVM/INST/inst.lisp.html">inst</a>rBody <a href="../DJVM/INST/inst.lisp.html">inst</a>)))
(<span class="keyword">defun</span> <span class="function-name">arg1</span> (<a href="../DJVM/INST/inst.lisp.html">inst</a>) (car (cdr (<a href="../DJVM/INST/inst.lisp.html">inst</a>rBody <a href="../DJVM/INST/inst.lisp.html">inst</a>))))
(<span class="keyword">defun</span> <span class="function-name">arg2</span> (<a href="../DJVM/INST/inst.lisp.html">inst</a>) (car (cdr (cdr (<a href="../DJVM/INST/inst.lisp.html">inst</a>rBody <a href="../DJVM/INST/inst.lisp.html">inst</a>)))))
(<span class="keyword">defun</span> <span class="function-name">arg3</span> (<a href="../DJVM/INST/inst.lisp.html">inst</a>) (car (cdr (cdr (cdr (<a href="../DJVM/INST/inst.lisp.html">inst</a>rBody <a href="../DJVM/INST/inst.lisp.html">inst</a>))))))


(<span class="keyword">defun</span> <span class="function-name"><a href="../DJVM/INST/inst.lisp.html">inst</a></span> (offset <a href="../DJVM/INST/inst.lisp.html">inst</a>rbody)
  (list offset instrbody))

(<span class="keyword">defun</span> <span class="function-name"><a href="../DJVM/INST/inst.lisp.html">inst</a>ructionHasEquivalentTypeRule</span>(<a href="../DJVM/INST/inst.lisp.html">inst</a>)
  (<span class="keyword">let</span> ((op (op-code <a href="../DJVM/INST/inst.lisp.html">inst</a>))
        (pc (<a href="../DJVM/INST/inst.lisp.html">inst</a>rOffset <a href="../DJVM/INST/inst.lisp.html">inst</a>)))
    (<span class="keyword">cond</span> ((equal op 'aload_0) (<a href="../DJVM/INST/inst.lisp.html">inst</a> pc '(aload 0)))
          ((equal op 'aload_1) (<a href="../DJVM/INST/inst.lisp.html">inst</a> pc '(aload 1)))
          ((equal op 'aload_2) (<a href="../DJVM/INST/inst.lisp.html">inst</a> pc '(aload 2)))
          ((equal op 'aload_3) (<a href="../DJVM/INST/inst.lisp.html">inst</a> pc '(aload 3)))
          ((equal op 'astore_0) (<a href="../DJVM/INST/inst.lisp.html">inst</a> pc '(astore 0)))
          ((equal op 'astore_1) (<a href="../DJVM/INST/inst.lisp.html">inst</a> pc '(astore 1)))          
          ((equal op 'astore_2) (<a href="../DJVM/INST/inst.lisp.html">inst</a> pc '(astore 2)))          
          ((equal op 'astore_3) (<a href="../DJVM/INST/inst.lisp.html">inst</a> pc '(astore 3)))
          ((equal op 'bipush)   (<a href="../DJVM/INST/inst.lisp.html">inst</a> pc (list 'sipush (arg1 <a href="../DJVM/INST/inst.lisp.html">inst</a>))))
          ((equal op 'dcmpl)    (<a href="../DJVM/INST/inst.lisp.html">inst</a> pc '(dcmpg)))
          ((equal op 'dconst_1) (<a href="../DJVM/INST/inst.lisp.html">inst</a> pc '(dconst_0)))
          ((equal op 'ddiv)     (<a href="../DJVM/INST/inst.lisp.html">inst</a> pc '(dadd)))
          ((equal op 'dload_0) (<a href="../DJVM/INST/inst.lisp.html">inst</a> pc '(dload 0)))
          ((equal op 'dload_1) (<a href="../DJVM/INST/inst.lisp.html">inst</a> pc '(dload 1)))
          ((equal op 'dload_2) (<a href="../DJVM/INST/inst.lisp.html">inst</a> pc '(dload 2)))
          ((equal op 'dload_3) (<a href="../DJVM/INST/inst.lisp.html">inst</a> pc '(dload 3)))
          ((equal op 'dmul)     (<a href="../DJVM/INST/inst.lisp.html">inst</a> pc '(dadd)))
          ((equal op 'drem)     (<a href="../DJVM/INST/inst.lisp.html">inst</a> pc '(dadd)))
          ((equal op 'dstore_0) (<a href="../DJVM/INST/inst.lisp.html">inst</a> pc '(dstore 0)))
          ((equal op 'dstore_1) (<a href="../DJVM/INST/inst.lisp.html">inst</a> pc '(dstore 1)))          
          ((equal op 'dstore_2) (<a href="../DJVM/INST/inst.lisp.html">inst</a> pc '(dstore 2)))          
          ((equal op 'dstore_3) (<a href="../DJVM/INST/inst.lisp.html">inst</a> pc '(dstore 3)))
          ((equal op 'dsub)     (<a href="../DJVM/INST/inst.lisp.html">inst</a> pc '(dadd)))
          ((equal op 'fcmpl)    (<a href="../DJVM/INST/inst.lisp.html">inst</a> pc '(fcmpg)))
          ((equal op 'fconst_1) (<a href="../DJVM/INST/inst.lisp.html">inst</a> pc '(fconst_0)))
          ((equal op 'fconst_2) (<a href="../DJVM/INST/inst.lisp.html">inst</a> pc '(fconst_0)))
          ((equal op 'fdiv)     (<a href="../DJVM/INST/inst.lisp.html">inst</a> pc '(fadd)))
          ((equal op 'fload_0) (<a href="../DJVM/INST/inst.lisp.html">inst</a> pc '(fload 0)))
          ((equal op 'fload_1) (<a href="../DJVM/INST/inst.lisp.html">inst</a> pc '(fload 1)))
          ((equal op 'fload_2) (<a href="../DJVM/INST/inst.lisp.html">inst</a> pc '(fload 2)))
          ((equal op 'fload_3) (<a href="../DJVM/INST/inst.lisp.html">inst</a> pc '(fload 3)))
          ((equal op 'fmul)     (<a href="../DJVM/INST/inst.lisp.html">inst</a> pc '(fadd)))
          ((equal op 'frem)     (<a href="../DJVM/INST/inst.lisp.html">inst</a> pc '(fadd)))
          ((equal op 'fstore_0) (<a href="../DJVM/INST/inst.lisp.html">inst</a> pc '(fstore 0)))
          ((equal op 'fstore_1) (<a href="../DJVM/INST/inst.lisp.html">inst</a> pc '(fstore 1)))          
          ((equal op 'fstore_2) (<a href="../DJVM/INST/inst.lisp.html">inst</a> pc '(fstore 2)))          
          ((equal op 'fstore_3) (<a href="../DJVM/INST/inst.lisp.html">inst</a> pc '(fstore 3)))
          ((equal op 'fsub)     (<a href="../DJVM/INST/inst.lisp.html">inst</a> pc '(fadd)))
          ((equal op 'i2b)      (<a href="../DJVM/INST/inst.lisp.html">inst</a> pc '(ineg)))
          ((equal op 'i2c)      (<a href="../DJVM/INST/inst.lisp.html">inst</a> pc '(ineg)))
          ((equal op 'i2s)      (<a href="../DJVM/INST/inst.lisp.html">inst</a> pc '(ineg)))
          ((equal op 'iand)      (<a href="../DJVM/INST/inst.lisp.html">inst</a> pc '(iadd)))
          ((equal op 'iconst_0) (<a href="../DJVM/INST/inst.lisp.html">inst</a> pc '(sipush 0)))
          ((equal op 'iconst_1) (<a href="../DJVM/INST/inst.lisp.html">inst</a> pc '(sipush 1)))
          ((equal op 'iconst_2) (<a href="../DJVM/INST/inst.lisp.html">inst</a> pc '(sipush 2)))
          ((equal op 'iconst_3) (<a href="../DJVM/INST/inst.lisp.html">inst</a> pc '(sipush 3)))
          ((equal op 'iconst_4) (<a href="../DJVM/INST/inst.lisp.html">inst</a> pc '(sipush 4)))
          ((equal op 'iconst_5) (<a href="../DJVM/INST/inst.lisp.html">inst</a> pc '(sipush 5)))
          ((equal op 'iconst_m1) (<a href="../DJVM/INST/inst.lisp.html">inst</a> pc '(sipush -1)))
          ((equal op 'idiv)      (<a href="../DJVM/INST/inst.lisp.html">inst</a> pc '(iadd)))
          ((equal op 'if_acmpne) (<a href="../DJVM/INST/inst.lisp.html">inst</a> pc (list 'if_acmpeq (arg1 <a href="../DJVM/INST/inst.lisp.html">inst</a>))))
          ((equal op 'if_icmpge) (<a href="../DJVM/INST/inst.lisp.html">inst</a> pc (list 'if_icmpeq (arg1 <a href="../DJVM/INST/inst.lisp.html">inst</a>))))
          ((equal op 'if_icmpgt) (<a href="../DJVM/INST/inst.lisp.html">inst</a> pc (list 'if_icmpeq (arg1 <a href="../DJVM/INST/inst.lisp.html">inst</a>))))
          ((equal op 'if_icmple) (<a href="../DJVM/INST/inst.lisp.html">inst</a> pc (list 'if_icmpeq (arg1 <a href="../DJVM/INST/inst.lisp.html">inst</a>))))
          ((equal op 'if_icmplt) (<a href="../DJVM/INST/inst.lisp.html">inst</a> pc (list 'if_icmpeq (arg1 <a href="../DJVM/INST/inst.lisp.html">inst</a>))))
          ((equal op 'if_icmpne) (<a href="../DJVM/INST/inst.lisp.html">inst</a> pc (list 'if_icmpeq (arg1 <a href="../DJVM/INST/inst.lisp.html">inst</a>))))
          ((equal op 'ifge)      (<a href="../DJVM/INST/inst.lisp.html">inst</a> pc (list 'ifeq (arg1 <a href="../DJVM/INST/inst.lisp.html">inst</a>))))
          ((equal op 'ifgt)      (<a href="../DJVM/INST/inst.lisp.html">inst</a> pc (list 'ifeq (arg1 <a href="../DJVM/INST/inst.lisp.html">inst</a>))))
          ((equal op 'ifle)      (<a href="../DJVM/INST/inst.lisp.html">inst</a> pc (list 'ifeq (arg1 <a href="../DJVM/INST/inst.lisp.html">inst</a>))))
          ((equal op 'iflt)      (<a href="../DJVM/INST/inst.lisp.html">inst</a> pc (list 'ifeq (arg1 <a href="../DJVM/INST/inst.lisp.html">inst</a>))))
          ((equal op 'ifne)      (<a href="../DJVM/INST/inst.lisp.html">inst</a> pc (list 'ifeq (arg1 <a href="../DJVM/INST/inst.lisp.html">inst</a>))))
          ((equal op 'ifnull)    (<a href="../DJVM/INST/inst.lisp.html">inst</a> pc (list 'ifnonnull (arg1 <a href="../DJVM/INST/inst.lisp.html">inst</a>))))
          ((equal op 'iload_0) (<a href="../DJVM/INST/inst.lisp.html">inst</a> pc '(iload 0)))
          ((equal op 'iload_1) (<a href="../DJVM/INST/inst.lisp.html">inst</a> pc '(iload 1)))
          ((equal op 'iload_2) (<a href="../DJVM/INST/inst.lisp.html">inst</a> pc '(iload 2)))
          ((equal op 'iload_3) (<a href="../DJVM/INST/inst.lisp.html">inst</a> pc '(iload 3)))
          ((equal op 'imul)      (<a href="../DJVM/INST/inst.lisp.html">inst</a> pc '(iadd)))
          ((equal op 'ior)       (<a href="../DJVM/INST/inst.lisp.html">inst</a> pc '(iadd)))
          ((equal op 'irem)      (<a href="../DJVM/INST/inst.lisp.html">inst</a> pc '(iadd)))
          ((equal op 'ishl)      (<a href="../DJVM/INST/inst.lisp.html">inst</a> pc '(iadd)))
          ((equal op 'ishr)      (<a href="../DJVM/INST/inst.lisp.html">inst</a> pc '(iadd)))
          ((equal op 'istore_0) (<a href="../DJVM/INST/inst.lisp.html">inst</a> pc '(istore 0)))
          ((equal op 'istore_1) (<a href="../DJVM/INST/inst.lisp.html">inst</a> pc '(istore 1)))          
          ((equal op 'istore_2) (<a href="../DJVM/INST/inst.lisp.html">inst</a> pc '(istore 2)))          
          ((equal op 'istore_3) (<a href="../DJVM/INST/inst.lisp.html">inst</a> pc '(istore 3)))
          ((equal op 'isub)      (<a href="../DJVM/INST/inst.lisp.html">inst</a> pc '(iadd)))
          ((equal op 'iushr)    (<a href="../DJVM/INST/inst.lisp.html">inst</a> pc '(iadd)))
          ((equal op 'ixor)      (<a href="../DJVM/INST/inst.lisp.html">inst</a> pc '(iadd)))
          ((equal op 'land)      (<a href="../DJVM/INST/inst.lisp.html">inst</a> pc '(ladd)))
          ((equal op 'lconst_1)      (<a href="../DJVM/INST/inst.lisp.html">inst</a> pc '(lconst_0)))
          ((equal op 'ldc_w)      (<a href="../DJVM/INST/inst.lisp.html">inst</a> pc (list 'ldc (arg1 <a href="../DJVM/INST/inst.lisp.html">inst</a>))))
          ((equal op 'ldiv)       (<a href="../DJVM/INST/inst.lisp.html">inst</a> pc '(ladd)))
          ((equal op 'lload_0) (<a href="../DJVM/INST/inst.lisp.html">inst</a> pc '(lload 0)))
          ((equal op 'lload_1) (<a href="../DJVM/INST/inst.lisp.html">inst</a> pc '(lload 1)))
          ((equal op 'lload_2) (<a href="../DJVM/INST/inst.lisp.html">inst</a> pc '(lload 2)))
          ((equal op 'lload_3) (<a href="../DJVM/INST/inst.lisp.html">inst</a> pc '(lload 3)))
          ((equal op 'lmul)      (<a href="../DJVM/INST/inst.lisp.html">inst</a> pc '(ladd)))
          ((equal op 'lor)       (<a href="../DJVM/INST/inst.lisp.html">inst</a> pc '(ladd)))
          ((equal op 'lrem)      (<a href="../DJVM/INST/inst.lisp.html">inst</a> pc '(ladd)))
          ((equal op 'lshr)      (<a href="../DJVM/INST/inst.lisp.html">inst</a> pc '(lshl)))
          ((equal op 'lstore_0) (<a href="../DJVM/INST/inst.lisp.html">inst</a> pc '(lstore 0)))
          ((equal op 'lstore_1) (<a href="../DJVM/INST/inst.lisp.html">inst</a> pc '(lstore 1)))          
          ((equal op 'lstore_2) (<a href="../DJVM/INST/inst.lisp.html">inst</a> pc '(lstore 2)))          
          ((equal op 'lstore_3) (<a href="../DJVM/INST/inst.lisp.html">inst</a> pc '(lstore 3)))
          ((equal op 'lsub)      (<a href="../DJVM/INST/inst.lisp.html">inst</a> pc '(ladd)))
          ((equal op 'lushr)    (<a href="../DJVM/INST/inst.lisp.html">inst</a> pc '(lshl)))
          ((equal op 'lxor)      (<a href="../DJVM/INST/inst.lisp.html">inst</a> pc '(ladd)))
          ((equal op 'monitorexit) (<a href="../DJVM/INST/inst.lisp.html">inst</a> pc '(monitorenter)))
          (t <a href="../DJVM/INST/inst.lisp.html">inst</a>))))


<span class="comment">;  utitlies for change sigstate
</span>
<span class="comment">;--- prefix ---
;
; return the stack after pop out 
; all the matching type. 
;--
</span>
(<span class="keyword">defun</span>  <span class="function-name">convertIfInt</span> (type)
  (<span class="keyword">cond</span> ((equal type 'byte) 'int)
        ((equal type 'short) 'int)
        ((equal type 'boolean) 'int)
        (t type)))
      
<span class="comment">;;; not sure how they avoided 'short 'byte, etc.
</span>
<span class="comment">;;; it is a global invariant that they never test for short and byte. 
;;; when execute-aaload, they push the element type
;;; when execute-saload, they push INT. 
</span>
<span class="comment">;--
</span>(<span class="keyword">defun</span> <span class="function-name">isMatchingType</span> (Type Stack Env)
  (<span class="keyword">cond</span> ((equal (sizeOf Type) 1)  
        <span class="comment">;; (isAssignable (convertIfInt (top Stack))
</span>        <span class="comment">;;               (convertIfInt Type) Env))
</span>        <span class="comment">;; not the same as prolog
</span>        <span class="comment">;; version. hanbing April. 02
</span>        <span class="comment">;;
</span>        <span class="comment">;; WHY??? Wed Nov 19 01:15:37 2003
</span>        <span class="comment">;;
</span>        <span class="comment">;; 
</span>        (isAssignable (top Stack)
                       Type Env))

        ((equal (sizeOf Type) 2)
         <span class="comment">;; need a fix here. to match with DJVM's assumption. 
</span>         <span class="comment">;; 
</span>         <span class="comment">;;(and (equal (top (pop stack)) 'topx) 
</span>         <span class="comment">;;     ;; top stack is the signature the one below 
</span>         <span class="comment">;;     ;; it have to be a top. 
</span>         <span class="comment">;;     (isAssignable (top stack) Type Env)))
</span>         <span class="comment">;;  11/05/03  ;; Thu Dec 16 23:06:10 2004
</span>         <span class="comment">;; We shall fix the untag!!! 
</span>         <span class="comment">;; 
</span>         (and (equal (top stack) 'topx)
              <span class="comment">;; top stack is the signature the one below 
</span>              <span class="comment">;; it have to be a top. 
</span>              (isAssignable (top (pop stack)) Type Env)))
        (t nil)))

(<span class="keyword">defun</span> <span class="function-name">theMatchingType</span> (type Stack)
  (<span class="keyword">cond</span> ((equal (sizeOf type) 1) (top stack))
        <span class="comment">;; ((equal (sizeOf type) 2) (top stack)) ;; Thu Dec 16 23:18:42 2004
</span>        ((equal (sizeOf type) 2) (top (pop stack)))
        (t nil)))


(<span class="keyword">defun</span> <span class="function-name">popMatchingType</span> (Type Stack)
  (<span class="keyword">cond</span> ((equal (sizeOf Type) 1) (pop Stack))
        ((equal (sizeOf Type) 2) (pop (pop Stack)))
        (t nil)))<span class="comment">;; impossible 
</span>

<span class="comment">;--
</span>(<span class="keyword">defun</span> <span class="function-name">CanPop1</span> (prefix Stack Env) 
  (<span class="keyword">if</span> (endp prefix)
      t
    (<span class="keyword">if</span> (endp Stack)
        nil<span class="comment">;; can't pop
</span>      (and (isMatchingType (car prefix) Stack Env)
           (canPop1 (cdr prefix) (popMatchingType (car prefix) Stack) Env)))))

(<span class="keyword">defun</span> <span class="function-name">CanPop</span> (Env StackFrame prefix)
  (CanPop1 prefix (frameStack StackFrame) Env))



(<span class="keyword">defun</span> <span class="function-name">PopMatchingList1</span> (prefix Stack)
  (<span class="keyword">if</span> (endp prefix)
      Stack
    (<span class="keyword">if</span> (endp Stack)
        nil<span class="comment">;; make sure it won't cause hard error.
</span>      <span class="comment">;; indicate undefined 
</span>      (PopMatchingList1 (cdr prefix) 
                        (PopMatchingType (car prefix) Stack)))))

<span class="comment">;; because in some check-xxx we use this it (let* ((...)) body)
;; it may get evaluated before we know CanPop1 prefix...
</span>
(<span class="keyword">defun</span> <span class="function-name">PopMatchingList</span> (prefix curFrame)
  (make-sig-frame 
   (frameLocals curFrame)
   (PopMatchingList1 prefix (frameStack curFrame))
   (frameFlags curFrame)))

<span class="comment">;--
</span>(<span class="keyword">defun</span> <span class="function-name">pushOperandStack</span> (type stack) 
  (<span class="keyword">cond</span> ((equal type 'void)  stack)
        ((equal (sizeOf type) 2) (push 'topx (push Type Stack)))
        <span class="comment">;; ((equal (sizeOf type) 2) (push Type (push 'topx Stack)))
</span>        <span class="comment">;;  11/05/03  fix to match djvm. FIX to match the STACK MAP!! 
</span>        
        ((equal (sizeOf type) 1) (push type Stack))
        (t nil)))<span class="comment">;; impossible
</span>

(<span class="keyword">defun</span> <span class="function-name">operandStackHasLegalLength</span> (env operandstack) 
  (<span class="keyword">let</span> ((MaxStack (maxStackEnvironment env)))
    (&lt;= (len operandStack) MaxStack)))

<span class="comment">;---
</span>(<span class="keyword">defun</span> <span class="function-name">validTypeTransition</span> (Env ExpectedTypesOnStack ResultType curFrame)
  (<span class="keyword">let</span> ((InputOperandStack (frameStack curFrame)))
    (and (canPop1 ExpectedTypesOnStack InputOperandStack Env)
         (operandStackHasLegalLength Env (pushOperandStack ResultType
                                                           (popMatchingList1
                                                            ExpectedTypesOnStack InputOperandStack))))))


(<span class="keyword">defun</span> <span class="function-name">TypeTransition</span> (env toBePoped  ResultType curFrame)
  (<span class="keyword">declare</span> (ignore env))
  (<span class="keyword">let</span> ((locals (frameLocals curFrame))
        (stack  (frameStack  curFrame))
        (flags  (frameFlags  curFrame)))
    (make-sig-frame locals 
                    (pushOperandStack ResultType 
                                      (popMatchingList1 toBePoped stack))
                    flags)))


(<span class="keyword">defun</span> <span class="function-name">exceptionStackFrame</span> (curFrame)
  (<span class="keyword">let</span> ((locals (frameLocals curFrame))
        (flags  (frameFlags  curFrame)))
    (make-sig-frame locals nil flags)))


<span class="comment">;-- 
</span>(<span class="keyword">defun</span> <span class="function-name">nth1OperandStackExist</span> (n curFrame)
  (<span class="keyword">let</span> ((operandStack (frameStack curFrame)))
    (and (&lt;= n (len operandStack))
         (&lt;= 0 n))))

<span class="comment">;; (defun nth1OperandStackIs (n curFrame)
;;   (let ((operandStack (frameStack curFrame)))
;;     (if (nth1OperandStackExist n curFrame)
;;         (nth (- n 1) operandStack)
;;       nil)));; indicate undefined
</span>
(<span class="keyword">defun</span> <span class="function-name">nth1OperandStackIs</span> (n curFrame)
  (<span class="keyword">let</span> ((operandStack (frameStack curFrame)))
    (nth (- n 1) operandStack)))

<span class="comment">;; move the check into the guard!!
</span>


(<span class="keyword">defun</span> <span class="function-name">nthLocalsExist</span> (n type curFrame)
  (<span class="keyword">let</span> ((Locals (frameLocals curFrame)))
    (and (integerp n)
         (&lt;= 0 n)
         (<span class="keyword">if</span> (equal (sizeof type) 2)
             (&lt; (+ n 1) (len Locals))
           (&lt; n (len Locals))))))
<span class="comment">;;
;; more problem with safe index. n &gt; 0 is aways true. 
;; because local is accessed with unsign-int-fix
;;
;; Mon Mar 29 12:26:40 2004
</span>
<span class="comment">;--
; assuming curFrame well formed
; assuming wellformed load instruction ensure index is not negative
</span>
(<span class="keyword">defun</span> <span class="function-name">safe-nth</span> (index lst)
  (nth index lst))

<span class="comment">;; (defun safe-nth (index lst)
;;   (if (and (&lt; index (len lst))
;;            (&lt;= 0 index))
;;       (nth index lst)
;;     nil));; undefined
</span>
<span class="comment">;; problem 0&lt;= index test??
</span>
(<span class="keyword">defun</span> <span class="function-name">loadIsTypeSafe</span> (env index type curFrame)
  (<span class="keyword">let*</span> ((locals (frameLocals curFrame))
         (ActualType (safe-nth index locals)))
    (and (nthLocalsExist index type curFrame)
         (isAssignable ActualType Type env)
         (validTypeTransition env nil ActualType curFrame))))

(<span class="keyword">defun</span> <span class="function-name">do-load</span> (env index type curFrame)
  (<span class="keyword">declare</span> (ignore type))
  (<span class="keyword">let*</span> ((locals (frameLocals curFrame))
         (ActualType (nth index locals)))
    (TypeTransition env nil ActualType curFrame)))

<span class="comment">;;; WE need to fix the load of size two 
;;; 
;;;
</span>

<span class="comment">;--
</span>(<span class="keyword">defun</span> <span class="function-name">storeIsTypeSafe</span> (env index type curFrame)
  (<span class="keyword">let*</span> ((stack  (frameStack  curFrame)))
    (and (nthLocalsExist index type curFrame)
         (isMatchingType type stack env))))

<span class="comment">;;
;; error here. nthLocalExists depends on type. if size 2 we expect two slots.  
;; hanbing April 2003
;;
</span>
(<span class="keyword">defun</span> <span class="function-name">modifyPreIndexVariable</span> (type)
  (<span class="keyword">cond</span> ((equal (sizeOf type) 1) type)
        ((equal (sizeOf type) 2) 'topx)))

(<span class="keyword">defun</span> <span class="function-name">modifyLocalVariable</span> (index type locals)
  (<span class="keyword">if</span> (endp locals)
      nil
    (<span class="keyword">cond</span> ((&lt; 1 index) 
           (cons (car locals) (modifyLocalVariable (- index 1) type
                                                   (cdr locals))))
          ((equal index 1) (cons (modifyPreIndexVariable (car locals))
                                 <span class="comment">;; if we happen to write into a middle of a
</span>                                 <span class="comment">;; two slot value We need to destroy the older
</span>                                 <span class="comment">;; value. Tue Feb  1 14:01:19 2005
</span>                                 (modifyLocalVariable 0 type (cdr
                                                              locals))))
          ((equal index 0)
           (<span class="keyword">cond</span> ((equal (sizeOf type) 1) (cons type (cdr locals)))
                 ((equal (sizeOf type) 2) (cons type (cons 'topx (cddr
                                                                 locals))))
                 (t nil)))<span class="comment">;; impossible
</span>          <span class="comment">;; problem here: Tue Feb  1 13:55:57 2005. We put (type 'topx ...) to
</span>          <span class="comment">;; represent two slot. However in opstack, we use ('topx type) to
</span>          <span class="comment">;; represent LONG! 
</span>          <span class="comment">;; type list assignable needs to be redefined. 
</span>          <span class="comment">;;
</span>          (t nil))))
<span class="comment">;--- 
;; *17* Note: For locals, we don't check whether FrameSize is
;; exceeded? Why? Because in Prolog version, we know the locals is
;; expand to list of length FrameSize in MethodInitialStackFrame
</span>            

(<span class="keyword">defun</span> <span class="function-name">do-store</span> (env index type curFrame)
  (<span class="keyword">declare</span> (ignore env))
  (<span class="keyword">let*</span> ((locals (frameLocals curFrame))
         (stack  (frameStack curFrame))
         (flags  (frameFlags curFrame))
         (ActualType (theMatchingType type stack)))
    (make-sig-frame (modifyLocalVariable index ActualType locals)
                    (popMatchingType type stack)
                    flags)))

<span class="comment">;;;; Thu Dec 16 23:18:03 2004. ActualType .. problem 
</span>
<span class="comment">;--- 
;  
;    aaload :   
;
;  Assumption: all input parameter are well formed.
;              check. Env and curFrame
</span>

(<span class="keyword">defun</span> <span class="function-name">ArrayElementType</span> (ArrayType)
  (<span class="keyword">if</span> (equal ArrayType 'null)
      'null
    (cadr ArrayType)))

<span class="comment">;; we will prove guard!! 
</span>
<span class="comment">;; (defun ArrayElementType (ArrayType)
;;     (if (isArrayType ArrayType);; to guard against hard error
;;       (cadr ArrayType))
;;     nil));; indicate undefined
</span>       

(<span class="keyword">defun</span> <span class="function-name">check-aaload</span> (<a href="../DJVM/INST/inst.lisp.html">inst</a> env curFrame) 
  (<span class="keyword">declare</span> (ignore <a href="../DJVM/INST/inst.lisp.html">inst</a>))
  (mylet* ((ArrayType (nth1OperandStackIs 2 curFrame))
           (ElementType (ArrayElementType ArrayType)))
    (and <span class="comment">;; (nth1OperandStackExist 2 curFrame) ;; Sun Mar 28 20:26:47 2004
</span>         <span class="comment">;; part of the validTypeTransition!!
</span>         <span class="comment">;; (or (isNullType arrayType)    
</span>         <span class="comment">;;     (isArrayType ArrayType)) ;; BCV does not assert this?
</span>         <span class="comment">;; This is not necessary.
</span>         <span class="comment">;; should be derivable from validTypeTransition 'int (array ...)
</span>         <span class="comment">;; Sun Mar 28 17:02:37 2004. Removed. Proof still go through.
</span>         (validtypetransition env  
                              '(int (array (class <span class="string">"java.lang.Object"</span>)))
                              ElementType
                              curFrame))))


<span class="comment">;; (defun check-aaload (<a href="../DJVM/INST/inst.lisp.html">inst</a> env curFrame) 
;;   (declare (ignore <a href="../DJVM/INST/inst.lisp.html">inst</a>))
;;   (mylet* ((ArrayType (nth1OperandStackIs 2 curFrame))
;;            (ElementType (ArrayElementType ArrayType)))
;;     (and (nth1OperandStackExist 2 curFrame)
;;          (or (isNullType arrayType)  
;;              (isArrayType ArrayType)) ;; bcv assert down there ...
;;          (validtypetransition env  
;;                               '(int (array (class "java.lang.Object")))
;;                               ElementType
;;                               curFrame))))
</span>
<span class="comment">;;
;; Allow 
;;
;; execute-XXX return a pair of StackFrame (normal . exception)
</span>


(<span class="keyword">defun</span> <span class="function-name">execute-aaload</span> (<a href="../DJVM/INST/inst.lisp.html">inst</a> env curFrame)
  (<span class="keyword">declare</span> (ignore <a href="../DJVM/INST/inst.lisp.html">inst</a>))
  (mylet* ((ArrayType (nth1OperandStackIs 2 curFrame))
           (ElementType (ArrayElementType ArrayType)))
    (mv  (TypeTransition env
                         '(int (array (class <span class="string">"java.lang.Object"</span>)))
                         ElementType
                         curFrame)
         (exceptionStackFrame curFrame))))

<span class="comment">;--- 
</span>(<span class="keyword">defun</span> <span class="function-name">check-aastore</span> (<a href="../DJVM/INST/inst.lisp.html">inst</a> env curFrame)
  (<span class="keyword">declare</span> (ignore <a href="../DJVM/INST/inst.lisp.html">inst</a>))
  (canPop Env curFrame 
          '((class <span class="string">"java.lang.Object"</span>) int (array (class
                                                   <span class="string">"java.lang.Object"</span>)))))
<span class="comment">;; type check is at runtime. 
</span>
(<span class="keyword">defun</span> <span class="function-name">execute-aastore</span> (<a href="../DJVM/INST/inst.lisp.html">inst</a> env curFrame)
  (<span class="keyword">declare</span> (ignore <a href="../DJVM/INST/inst.lisp.html">inst</a>))
  (mv (TypeTransition env 
                      '((class <span class="string">"java.lang.Object"</span>) 
                        int 
                        (array (class <span class="string">"java.lang.Object"</span>)))
                      'void<span class="comment">;; use void to indicate push nothing.
</span>                      curFrame)
      (exceptionStackFrame curFrame)))

<span class="comment">;---                                    ;; nothing to do with offset 
</span>(<span class="keyword">defun</span> <span class="function-name">check-aconst_null</span> (<a href="../DJVM/INST/inst.lisp.html">inst</a> env curFrame)<span class="comment">;; those <a href="../DJVM/INST/inst.lisp.html">inst</a>ruction has
</span>  (<span class="keyword">declare</span> (ignore <a href="../DJVM/INST/inst.lisp.html">inst</a>))
  (validTypeTransition  env  nil 'null curFrame))

(<span class="keyword">defun</span> <span class="function-name">execute-aconst_null</span> (<a href="../DJVM/INST/inst.lisp.html">inst</a> env curFrame)
  (<span class="keyword">declare</span> (ignore <a href="../DJVM/INST/inst.lisp.html">inst</a>))
  (mv  (TypeTransition env
                       nil
                       'null
                       curFrame)
       (exceptionStackFrame curFrame)))

<span class="comment">;--- ;; assume (aload &lt;arg1&gt;)
</span>(<span class="keyword">defun</span> <span class="function-name">check-aload</span> (<a href="../DJVM/INST/inst.lisp.html">inst</a> env curFrame)
  (<span class="keyword">let</span> ((index (arg1 <a href="../DJVM/INST/inst.lisp.html">inst</a>)))
    (loadIsTypeSafe env index 'reference curFrame)))

<span class="comment">;;;
;;; do we need to check wff-aload? 
;;; Shall we assume that wff-aload!! ;; Wed May 18 13:42:48 2005
;;;
</span>
(<span class="keyword">defun</span> <span class="function-name">execute-aload</span> (<a href="../DJVM/INST/inst.lisp.html">inst</a> env curFrame)
  (mylet* ((index (arg1 <a href="../DJVM/INST/inst.lisp.html">inst</a>)))
          (mv (<span class="keyword">do-load</span> env index 'reference curFrame)
              (exceptionStackFrame curFrame))))

<span class="comment">;;--- 
; missing well formed check ... 
; do-load may need to unsign-int fix it.
;;---
</span> 

(<span class="keyword">defun</span> <span class="function-name">check-anewarray</span> (<a href="../DJVM/INST/inst.lisp.html">inst</a> env curFrame)
  (mylet* ((cp   (arg1 <a href="../DJVM/INST/inst.lisp.html">inst</a>)))
          (and (or (isClassType CP)
                   (isArrayType CP))
               (validTypeTransition env '(int) (list 'array CP) curFrame))))

(<span class="keyword">defun</span> <span class="function-name">execute-anewarray</span> (<a href="../DJVM/INST/inst.lisp.html">inst</a> env curFrame)
  (mylet* ((cp (arg1 <a href="../DJVM/INST/inst.lisp.html">inst</a>)))
          (mv (TypeTransition env '(int) (list 'array CP) curFrame)
              (exceptionStackFrame curFrame))))

<span class="comment">;---
</span>
(<span class="keyword">defun</span> <span class="function-name">check-areturn</span> (<a href="../DJVM/INST/inst.lisp.html">inst</a> env curFrame)
  (<span class="keyword">declare</span> (ignore <a href="../DJVM/INST/inst.lisp.html">inst</a>))
  (<span class="keyword">let*</span> ((method (methodEnvironment env))
         (returnType (methodReturnType method)))
    (and (isAssignable returnType 'reference env)
         (canPop env curFrame (list returnType)))))

<span class="comment">;; note: uninitialized is not assignable to any Java type.
</span>
(<span class="keyword">defun</span> <span class="function-name">execute-areturn</span> (<a href="../DJVM/INST/inst.lisp.html">inst</a> env curFrame)
  (<span class="keyword">declare</span> (ignore <a href="../DJVM/INST/inst.lisp.html">inst</a> env))
  (mv 'aftergoto 
      (exceptionStackFrame curFrame)))

<span class="comment">;--- 
</span>
(<span class="keyword">defun</span> <span class="function-name">check-arraylength</span> (<a href="../DJVM/INST/inst.lisp.html">inst</a> env curFrame)
  (<span class="keyword">declare</span> (ignore <a href="../DJVM/INST/inst.lisp.html">inst</a>))
  (<span class="keyword">let</span> ((ArrayType (nth1OperandStackIs 1 curFrame)))
    (and (nth1OperandStackExist 1 curFrame)
         (isArrayType ArrayType)
         (validTypeTransition env '(topx) 'int curFrame))))

(<span class="keyword">defun</span> <span class="function-name">execute-arraylength</span> (<a href="../DJVM/INST/inst.lisp.html">inst</a> env curFrame)
  (<span class="keyword">declare</span> (ignore <a href="../DJVM/INST/inst.lisp.html">inst</a>))
  (mv (TypeTransition env '(topx) 'int curFrame)
      (exceptionStackFrame curFrame)))
<span class="comment">;---
</span>
(<span class="keyword">defun</span> <span class="function-name">check-astore</span> (<a href="../DJVM/INST/inst.lisp.html">inst</a> env curFrame)
  (<span class="keyword">let</span> ((index (arg1 <a href="../DJVM/INST/inst.lisp.html">inst</a>)))
    (storeIsTypeSafe env index 'reference curFrame)))

(<span class="keyword">defun</span> <span class="function-name">execute-astore</span> (<a href="../DJVM/INST/inst.lisp.html">inst</a> env curFrame)
  (<span class="keyword">let</span> ((index (arg1 <a href="../DJVM/INST/inst.lisp.html">inst</a>)))
    (mv (<span class="keyword">do-store</span> env index 'reference curFrame)
        (exceptionStackFrame curFrame))))
<span class="comment">;---
</span>(<span class="keyword">defun</span> <span class="function-name">check-athrow</span> (<a href="../DJVM/INST/inst.lisp.html">inst</a> env curFrame)
  (<span class="keyword">declare</span> (ignore <a href="../DJVM/INST/inst.lisp.html">inst</a>))
  (canPop env curFrame '((class <span class="string">"java.lang.Throwable"</span>))))

(<span class="keyword">defun</span> <span class="function-name">execute-athrow</span> (<a href="../DJVM/INST/inst.lisp.html">inst</a> env curFrame)
  (<span class="keyword">declare</span> (ignore <a href="../DJVM/INST/inst.lisp.html">inst</a> env))
  (mv 'aftergoto 
      (exceptionStackFrame curFrame)))
<span class="comment">;---
</span>
(<span class="keyword">defun</span> <span class="function-name">isSmallArray</span> (type)
  (or (equal type 'null)
      (equal type '(array byte))
      <span class="comment">;;  (equal type '(array short))
</span>      (equal type '(array boolean))))
  
<span class="comment">;--
</span>(<span class="keyword">defun</span> <span class="function-name">check-baload</span> (<a href="../DJVM/INST/inst.lisp.html">inst</a> env curFrame)
  (<span class="keyword">declare</span> (ignore <a href="../DJVM/INST/inst.lisp.html">inst</a>))
  (<span class="keyword">let</span> ((Array (nth1OperandStackIs 2 curFrame)))
    (and (nth1OperandStackExist 2 curFrame)
         (isSmallArray Array)
         (validTypeTransition env '(int topx) 'int  curFrame))))

(<span class="keyword">defun</span> <span class="function-name">execute-baload</span> (<a href="../DJVM/INST/inst.lisp.html">inst</a> env curFrame)
  (<span class="keyword">declare</span> (ignore <a href="../DJVM/INST/inst.lisp.html">inst</a>))
  (mv (TypeTransition  env '(int topx) 'int  curFrame)
      (exceptionStackFrame curFrame)))

<span class="comment">;---
</span>
(<span class="keyword">defun</span> <span class="function-name">check-bastore</span> (<a href="../DJVM/INST/inst.lisp.html">inst</a> env curFrame)
  (<span class="keyword">declare</span> (ignore <a href="../DJVM/INST/inst.lisp.html">inst</a>))
  (<span class="keyword">let</span> ((Array (nth1OperandStackIs 3 curFrame)))
    (and (nth1OperandStackExist 3 curFrame)
         (isSmallArray Array)
         (canPop env curFrame '(int int topx)))))

<span class="comment">;; after ensure isSmallArray,  use top here is all right. refer to
;; original comments.
</span>
(<span class="keyword">defun</span> <span class="function-name">execute-bastore</span> (<a href="../DJVM/INST/inst.lisp.html">inst</a> env curFrame)
  (<span class="keyword">declare</span> (ignore <a href="../DJVM/INST/inst.lisp.html">inst</a>))
  (mv (TypeTransition env '(int int topx) 'void curFrame)
      (exceptionStackFrame curFrame)))

<span class="comment">;---
</span>(<span class="keyword">defun</span> <span class="function-name">check-caload</span> (<a href="../DJVM/INST/inst.lisp.html">inst</a> env curFrame)
  (<span class="keyword">declare</span> (ignore <a href="../DJVM/INST/inst.lisp.html">inst</a>))
  (and (nth1OperandStackExist 2 curFrame)
       (validTypeTransition env '(int (array char)) 'int  curFrame)))

(<span class="keyword">defun</span> <span class="function-name">execute-caload</span> (<a href="../DJVM/INST/inst.lisp.html">inst</a> env curFrame)
  (<span class="keyword">declare</span> (ignore <a href="../DJVM/INST/inst.lisp.html">inst</a>))
  (mv (TypeTransition  env '(int (array char)) 'int  curFrame)
      (exceptionStackFrame curFrame)))

<span class="comment">;---
</span>
(<span class="keyword">defun</span> <span class="function-name">check-castore</span> (<a href="../DJVM/INST/inst.lisp.html">inst</a> env curFrame)
  (<span class="keyword">declare</span> (ignore <a href="../DJVM/INST/inst.lisp.html">inst</a>))
  (and (nth1OperandStackExist 3 curFrame)
       (canPop env curFrame '(int int (array char)))))

(<span class="keyword">defun</span> <span class="function-name">execute-castore</span> (<a href="../DJVM/INST/inst.lisp.html">inst</a> env curFrame)
  (<span class="keyword">declare</span> (ignore <a href="../DJVM/INST/inst.lisp.html">inst</a>))
  (mv (TypeTransition env '(int int (array char)) 'void curFrame)
      (exceptionStackFrame curFrame)))

<span class="comment">;---
</span>  
(<span class="keyword">defun</span> <span class="function-name">check-checkcast</span> (<a href="../DJVM/INST/inst.lisp.html">inst</a> env curFrame)
  (<span class="keyword">let</span> ((CP (arg1 <a href="../DJVM/INST/inst.lisp.html">inst</a>)))
    (and (or (isClassType CP)
             (isArrayType CP))
         (validTypeTransition env '((class <span class="string">"java.lang.Object"</span>)) 
                              CP   curFrame)))) 
         
       
(<span class="keyword">defun</span> <span class="function-name">execute-checkcast</span> (<a href="../DJVM/INST/inst.lisp.html">inst</a> env curFrame)
  (<span class="keyword">let</span> ((CP (arg1 <a href="../DJVM/INST/inst.lisp.html">inst</a>)))
    (mv (TypeTransition env '((class <span class="string">"java.lang.Object"</span>)) 
                        CP curFrame)
        (exceptionStackFrame curFrame))))

<span class="comment">;---
</span>(<span class="keyword">defun</span> <span class="function-name">check-d2f</span> (<a href="../DJVM/INST/inst.lisp.html">inst</a> env curFrame)
  (<span class="keyword">declare</span> (ignore <a href="../DJVM/INST/inst.lisp.html">inst</a>))
  (validTypeTransition env '(double) 'float curFrame))

(<span class="keyword">defun</span> <span class="function-name">execute-d2f</span> (<a href="../DJVM/INST/inst.lisp.html">inst</a> env curFrame)
  (<span class="keyword">declare</span> (ignore <a href="../DJVM/INST/inst.lisp.html">inst</a>))
  (mv (TypeTransition env '(double) 'float curFrame)
      (exceptionStackFrame curFrame)))
<span class="comment">;--
</span>
(<span class="keyword">defun</span> <span class="function-name">check-d2i</span> (<a href="../DJVM/INST/inst.lisp.html">inst</a> env curFrame)
  (<span class="keyword">declare</span> (ignore <a href="../DJVM/INST/inst.lisp.html">inst</a>))
  (validTypeTransition env '(double) 'int curFrame))

(<span class="keyword">defun</span> <span class="function-name">execute-d2i</span> (<a href="../DJVM/INST/inst.lisp.html">inst</a> env curFrame)
  (<span class="keyword">declare</span> (ignore <a href="../DJVM/INST/inst.lisp.html">inst</a>))
  (mv (TypeTransition env '(double) 'int curFrame)
      (exceptionStackFrame curFrame)))
<span class="comment">;--
</span>(<span class="keyword">defun</span> <span class="function-name">check-d2l</span> (<a href="../DJVM/INST/inst.lisp.html">inst</a> env curFrame)
  (<span class="keyword">declare</span> (ignore <a href="../DJVM/INST/inst.lisp.html">inst</a>))
  (validTypeTransition env '(double) 'long curFrame))

(<span class="keyword">defun</span> <span class="function-name">execute-d2l</span> (<a href="../DJVM/INST/inst.lisp.html">inst</a> env curFrame)
  (<span class="keyword">declare</span> (ignore <a href="../DJVM/INST/inst.lisp.html">inst</a>))
  (mv (TypeTransition env '(double) 'long curFrame)
      (exceptionStackFrame curFrame)))
<span class="comment">;--
</span>
(<span class="keyword">defun</span> <span class="function-name">check-dadd</span> (<a href="../DJVM/INST/inst.lisp.html">inst</a> env curFrame)
  (<span class="keyword">declare</span> (ignore <a href="../DJVM/INST/inst.lisp.html">inst</a>))
  (validTypeTransition env '(double double) 'double curFrame))

(<span class="keyword">defun</span> <span class="function-name">execute-dadd</span> (<a href="../DJVM/INST/inst.lisp.html">inst</a> env curFrame)
  (<span class="keyword">declare</span> (ignore <a href="../DJVM/INST/inst.lisp.html">inst</a>))
  (mv (TypeTransition env '(double double) 'double curFrame)
      (exceptionStackFrame curFrame)))
<span class="comment">;--
</span>(<span class="keyword">defun</span> <span class="function-name">check-daload</span> (<a href="../DJVM/INST/inst.lisp.html">inst</a> env curFrame)
  (<span class="keyword">declare</span> (ignore <a href="../DJVM/INST/inst.lisp.html">inst</a>))
  (validTypeTransition env '(int (array double)) 'double curFrame))

(<span class="keyword">defun</span> <span class="function-name">execute-daload</span> (<a href="../DJVM/INST/inst.lisp.html">inst</a> env curFrame)
  (<span class="keyword">declare</span> (ignore <a href="../DJVM/INST/inst.lisp.html">inst</a>))
  (mv (TypeTransition env '(int (array double)) 'double curFrame)
      (exceptionStackFrame curFrame)))
<span class="comment">;--
</span>
(<span class="keyword">defun</span> <span class="function-name">check-dastore</span> (<a href="../DJVM/INST/inst.lisp.html">inst</a> env curFrame)
  (<span class="keyword">declare</span> (ignore <a href="../DJVM/INST/inst.lisp.html">inst</a>))
  (canPop env curFrame '(double int (array double))))

(<span class="keyword">defun</span> <span class="function-name">execute-dastore</span> (<a href="../DJVM/INST/inst.lisp.html">inst</a> env curFrame)
  (<span class="keyword">declare</span> (ignore <a href="../DJVM/INST/inst.lisp.html">inst</a>))
  (mv (TypeTransition env '(double int (array double)) 'void curFrame)
      (exceptionStackFrame curFrame)))


<span class="comment">;--
</span>(<span class="keyword">defun</span> <span class="function-name">check-dcmpg</span> (<a href="../DJVM/INST/inst.lisp.html">inst</a> env curFrame)
  (<span class="keyword">declare</span> (ignore <a href="../DJVM/INST/inst.lisp.html">inst</a>))
  (validTypeTransition env '(double double) 'int curFrame))

(<span class="keyword">defun</span> <span class="function-name">execute-dcmpg</span> (<a href="../DJVM/INST/inst.lisp.html">inst</a> env curFrame)
  (<span class="keyword">declare</span> (ignore <a href="../DJVM/INST/inst.lisp.html">inst</a>))
  (mv (TypeTransition env '(double double) 'int curFrame)
      (exceptionStackFrame curFrame)))
<span class="comment">;--
</span>(<span class="keyword">defun</span> <span class="function-name">check-dconst_0</span> (<a href="../DJVM/INST/inst.lisp.html">inst</a> env curFrame)
  (<span class="keyword">declare</span> (ignore <a href="../DJVM/INST/inst.lisp.html">inst</a>))
  (validTypeTransition env nil 'double curFrame))

(<span class="keyword">defun</span> <span class="function-name">execute-dconst_0</span> (<a href="../DJVM/INST/inst.lisp.html">inst</a> env curFrame)
  (<span class="keyword">declare</span> (ignore <a href="../DJVM/INST/inst.lisp.html">inst</a>))
  (mv (TypeTransition env nil 'double curFrame)
      (exceptionStackFrame curFrame)))
<span class="comment">;--
</span>(<span class="keyword">defun</span> <span class="function-name">check-dload</span> (<a href="../DJVM/INST/inst.lisp.html">inst</a> env curFrame)
  (<span class="keyword">let</span> ((index (arg1 <a href="../DJVM/INST/inst.lisp.html">inst</a>)))
    (loadIsTypeSafe env index 'double curFrame)))


(<span class="keyword">defun</span> <span class="function-name">execute-dload</span> (<a href="../DJVM/INST/inst.lisp.html">inst</a> env curFrame)
  (<span class="keyword">let*</span> ((index (arg1 <a href="../DJVM/INST/inst.lisp.html">inst</a>)))
    (mv (<span class="keyword">do-load</span> env index 'double curFrame)
        (exceptionStackFrame curFrame))))
<span class="comment">;--
</span>(<span class="keyword">defun</span> <span class="function-name">check-dneg</span> (<a href="../DJVM/INST/inst.lisp.html">inst</a> env curFrame)
  (<span class="keyword">declare</span> (ignore <a href="../DJVM/INST/inst.lisp.html">inst</a>))
  (validTypeTransition env '(double) 'double curFrame))

(<span class="keyword">defun</span> <span class="function-name">execute-dneg</span> (<a href="../DJVM/INST/inst.lisp.html">inst</a> env curFrame)
  (<span class="keyword">declare</span> (ignore <a href="../DJVM/INST/inst.lisp.html">inst</a>))
  (mv (TypeTransition env '(double) 'double curFrame)
      (exceptionStackFrame curFrame)))

<span class="comment">;--
</span>(<span class="keyword">defun</span> <span class="function-name">check-dreturn</span> (<a href="../DJVM/INST/inst.lisp.html">inst</a> env curFrame)
  (<span class="keyword">declare</span> (ignore <a href="../DJVM/INST/inst.lisp.html">inst</a>))
  (<span class="keyword">let</span> ((method (methodEnvironment env)))
    (and (equal (methodReturnType method) 'double)
         (canPop env curFrame '(double)))))

(<span class="keyword">defun</span> <span class="function-name">execute-dreturn</span> (<a href="../DJVM/INST/inst.lisp.html">inst</a> env curFrame)
  (<span class="keyword">declare</span> (ignore <a href="../DJVM/INST/inst.lisp.html">inst</a> env))
  (mv 'aftergoto 
      (exceptionStackFrame curFrame)))
<span class="comment">;--
</span>(<span class="keyword">defun</span> <span class="function-name">check-dstore</span> (<a href="../DJVM/INST/inst.lisp.html">inst</a> env curFrame)
  (<span class="keyword">let</span> ((index (arg1 <a href="../DJVM/INST/inst.lisp.html">inst</a>)))
    (storeIsTypeSafe env index 'double curFrame)))

(<span class="keyword">defun</span> <span class="function-name">execute-dstore</span> (<a href="../DJVM/INST/inst.lisp.html">inst</a> env curFrame)
  (<span class="keyword">let</span> ((index (arg1 <a href="../DJVM/INST/inst.lisp.html">inst</a>)))
    (mv (<span class="keyword">do-store</span> env index 'double curFrame)
        (exceptionStackFrame curFrame))))
<span class="comment">;--
</span>(<span class="keyword">defun</span> <span class="function-name">isTopCategory1</span> (stack)
  (<span class="keyword">let</span> ((type (top stack)))
    (and (not (equal type 'topx))
         (equal (sizeOf type) 1))))

(<span class="keyword">defun</span> <span class="function-name">category1top</span> (stack)
  (top stack))

(<span class="keyword">defun</span> <span class="function-name">popCategory1</span> (stack)
  (pop stack))

(<span class="keyword">defun</span> <span class="function-name">canSafelyPush</span> (env stack type)
  (operandStackHasLegallength env (pushOperandStack type stack)))


(<span class="keyword">defun</span> <span class="function-name">check-dup</span> (<a href="../DJVM/INST/inst.lisp.html">inst</a> env curFrame)
  (<span class="keyword">declare</span> (ignore <a href="../DJVM/INST/inst.lisp.html">inst</a>))
  (<span class="keyword">let</span> ((stack (frameStack curFrame)))
    (and (nth1OperandStackExist 1 curFrame)
         (isTopCategory1 stack)
         (canSafelyPush env stack (category1top stack)))))

(<span class="keyword">defun</span> <span class="function-name">execute-dup</span> (<a href="../DJVM/INST/inst.lisp.html">inst</a> env curFrame)
  (<span class="keyword">declare</span> (ignore <a href="../DJVM/INST/inst.lisp.html">inst</a> env))
  (<span class="keyword">let</span> ((stack (frameStack curFrame))
        (locals (frameLocals curFrame))
        (flags  (frameFlags curFrame)))
    (mv (make-sig-frame locals 
                        (pushOperandStack 
                         (category1top stack) stack) flags)
        (exceptionStackFrame curFrame))))
<span class="comment">;--  
</span>
(<span class="keyword">defun</span> <span class="function-name">isTopCategory2</span> (stack)
  (and (equal (top stack) 'topx)
       (equal (sizeOf (top (pop stack))) 2)))

(<span class="keyword">defun</span> <span class="function-name">category2top</span> (stack)
  (top (pop stack)))

(<span class="keyword">defun</span> <span class="function-name">popCategory2</span> (stack)
  (pop (pop stack)))

(<span class="keyword">defun</span> <span class="function-name">pushList</span> (types stack)
  (<span class="keyword">if</span> (endp types)
      stack
    (pushList (cdr types) (pushOperandStack (car types) stack))))

(<span class="keyword">defun</span> <span class="function-name">canSafelyPushList</span> (env stack types)
  (operandStackHasLegalLength env (pushList types stack)))


(<span class="keyword">defun</span> <span class="function-name">check-dup_x1</span> (<a href="../DJVM/INST/inst.lisp.html">inst</a> env curFrame)
  (<span class="keyword">declare</span> (ignore <a href="../DJVM/INST/inst.lisp.html">inst</a>))
  (<span class="keyword">let</span> ((stack (frameStack curFrame)))
    (and (nth1OperandStackExist 2 curFrame)
         (isTopCategory1 stack)
         (isTopCategory1 (pop Stack))
         (canSafelyPushList env (popCategory1 (popCategory1 stack)) 
                            (list (category1top stack) 
                                  (category1top (popCategory1 stack))
                                  (category1top stack))))))
                              

(<span class="keyword">defun</span> <span class="function-name">execute-dup_x1</span> (<a href="../DJVM/INST/inst.lisp.html">inst</a> env curFrame)
  (<span class="keyword">declare</span> (ignore <a href="../DJVM/INST/inst.lisp.html">inst</a> env))
  (<span class="keyword">let</span> ((stack (frameStack curFrame))
        (locals (frameLocals curFrame))
        (flags  (frameFlags curFrame)))
    (mv (make-sig-frame locals 
                        (pushList 
                         (list (category1top stack) 
                               (category1top (popCategory1 stack))
                               (category1top stack))
                         (popCategory1 (popCategory1 stack)))
                        flags)
        (exceptionStackFrame curFrame))))
<span class="comment">;--
; the (let* part get evaluated and potentially cause hard error
; we replace the top and pop with guarded version.    
</span>
(<span class="keyword">defun</span> <span class="function-name">is_dup_x2_form1</span> (env stack)
  (<span class="keyword">let*</span> ((Type1  (category1top  stack))
         (Stack1 (popCategory1 stack))
         (Type2  (category1top  Stack1))
         (Stack2 (popCategory1 Stack1))
         (Type3  (category1top Stack2))
         (Rest   (popCategory1 Stack2)))
    (and (isTopCategory1 stack)
         (isTopCategory1 Stack1)
         (isTopCategory1 Stack2)
         (canSafelyPushList env Rest (list type1 type3 type2
                                           type1)))))

(<span class="keyword">defun</span> <span class="function-name">do_dup_x2_form1</span> (env curFrame)
  (<span class="keyword">declare</span> (ignore env))
  (<span class="keyword">let*</span> ((stack  (frameStack curFrame))
         (locals (frameLocals curFrame))
         (flags  (frameFlags curFrame))
         (Type1  (category1top  stack))
         (Stack1 (popCategory1 stack))
         (Type2  (category1top  Stack1))
         (Stack2 (popCategory1 Stack1))
         (Type3  (category1top Stack2))
         (Rest   (popCategory1 Stack2)))
    (mv (make-sig-frame locals
                        (pushList 
                         (list type1 type3 type2 type1) rest)
                        flags)
        (exceptionStackFrame curFrame))))


(<span class="keyword">defun</span> <span class="function-name">is_dup_x2_form2</span> (env stack)
  (<span class="keyword">let*</span> ((Type1  (category1top  stack))
         (Stack1 (popCategory1 stack))
         (Type2  (category2top  Stack1))
         (Rest   (popCategory2 Stack1)))
    (and (isTopCategory1 stack)
         (isTopCategory2 Stack1)
         (canSafelyPushList env Rest (list type1 type2 type1)))))


(<span class="keyword">defun</span> <span class="function-name">do_dup_x2_form2</span> (env curFrame)
  (<span class="keyword">declare</span> (ignore env))
  (<span class="keyword">let*</span> ((stack  (frameStack curFrame))
         (locals (frameLocals curFrame))
         (flags  (frameFlags curFrame))
         (Type1  (category1top  stack))
         (Stack1 (popCategory1 stack))
         (Type2  (category2top  Stack1))
         (rest (popCategory2 Stack1)))
    (mv (make-sig-frame locals
                        (pushList 
                         (list type1 type2 type1) rest)
                        flags)
        (exceptionStackFrame curFrame))))

<span class="comment">;; I should have let those function to return a pair (t . return) 
;; now I have to write two functions.
</span>         
(<span class="keyword">defun</span> <span class="function-name">check-dup_x2</span> (<a href="../DJVM/INST/inst.lisp.html">inst</a> env curFrame)
  (<span class="keyword">declare</span> (ignore <a href="../DJVM/INST/inst.lisp.html">inst</a>))
  (<span class="keyword">let</span> ((stack (frameStack curFrame)))
    (and (nth1OperandStackExist 3 curFrame)
         (or (is_dup_x2_form1 env stack)
             (is_dup_x2_form2 env stack)))))
                              
(<span class="keyword">defun</span> <span class="function-name">execute-dup_x2</span> (<a href="../DJVM/INST/inst.lisp.html">inst</a> env curFrame)
  (<span class="keyword">declare</span> (ignore <a href="../DJVM/INST/inst.lisp.html">inst</a>))
  (<span class="keyword">let</span> ((stack (frameStack curFrame)))
    (<span class="keyword">cond</span> ((is_dup_x2_form1 env stack)
           (do_dup_x2_form1 env curFrame))
          ((is_dup_x2_form2 env stack)
           (do_dup_x2_form2 env curFrame))
          (t (mv nil nil)))))<span class="comment">;; impossible.
</span>        
<span class="comment">;--
</span>
(<span class="keyword">defun</span> <span class="function-name">is_dup2_form1</span> (env stack)
  (<span class="keyword">let*</span> ((Type1  (category1top  stack))
         (Stack1 (popCategory1 stack))
         (Type2  (category1top  Stack1)))
    (and (isTopCategory1 stack)
         (isTopCategory1 Stack1)
         (canSafelyPushList env stack (list type2 type1)))))

(<span class="keyword">defun</span> <span class="function-name">do_dup2_form1</span> (env curFrame)
  (<span class="keyword">declare</span> (ignore env))
  (<span class="keyword">let*</span> ((stack  (frameStack curFrame))
         (locals (frameLocals curFrame))
         (flags  (frameFlags curFrame))
         (Type1  (category1top  stack))
         (Stack1 (popCategory1 stack))
         (Type2  (category1top  Stack1)))
    (mv (make-sig-frame locals
                        (pushList 
                         (list type2 type1) stack)
                        flags)
        (exceptionStackFrame curFrame))))
                          


(<span class="keyword">defun</span> <span class="function-name">is_dup2_form2</span> (env stack)
  (<span class="keyword">let*</span> ((Type1  (category2top  stack))
         (Rest   (popCategory2  stack)))
    (and (isTopCategory2 stack)
         (canSafelyPush env Rest Type1))))


(<span class="keyword">defun</span> <span class="function-name">do_dup2_form2</span> (env curFrame)
  (<span class="keyword">declare</span> (ignore env))
  (<span class="keyword">let*</span> ((stack  (frameStack curFrame))
         (locals (frameLocals curFrame))
         (flags  (frameFlags curFrame))
         (Type1  (category2top  stack)))
    (mv (make-sig-frame locals
                        (pushOperandStack type1 stack)
                        flags)
        (exceptionStackFrame curFrame))))    


(<span class="keyword">defun</span> <span class="function-name">check-dup2</span> (<a href="../DJVM/INST/inst.lisp.html">inst</a> env curFrame)
  (<span class="keyword">declare</span> (ignore <a href="../DJVM/INST/inst.lisp.html">inst</a>))
  (<span class="keyword">let</span> ((stack (frameStack curFrame)))
    (and (nth1OperandStackExist 2 curFrame)
         (or (is_dup2_form1 env stack)
             (is_dup2_form2 env stack)))))
                              
(<span class="keyword">defun</span> <span class="function-name">execute-dup2</span> (<a href="../DJVM/INST/inst.lisp.html">inst</a> env curFrame)
  (<span class="keyword">declare</span> (ignore <a href="../DJVM/INST/inst.lisp.html">inst</a>))
  (<span class="keyword">let</span> ((stack (frameStack curFrame)))
    (<span class="keyword">cond</span> ((is_dup2_form1 env stack)
           (do_dup2_form1 env curFrame))
          ((is_dup2_form2 env stack)
           (do_dup2_form2 env curFrame))
          (t (mv nil nil)))))<span class="comment">;; impossible.
</span>                 
<span class="comment">;--          
</span>
(<span class="keyword">defun</span> <span class="function-name">is_dup2_x1_form1</span> (env stack)
  (<span class="keyword">let*</span> ((Type1  (category1top  stack))
         (Stack1 (popCategory1 stack))
         (Type2  (category1top  Stack1))
         (Stack2 (popCategory1 Stack1))
         (Type3  (category1top Stack2))
         (rest   (popCategory1 Stack2))) 
    (and (isTopCategory1 stack)
         (isTopCategory1 Stack1)
         (isTopCategory1 Stack2)
         (canSafelyPushList env rest (list type2 type1 type3 type2 type1)))))

(<span class="keyword">defun</span> <span class="function-name">do_dup2_x1_form1</span> (env curFrame)
  (<span class="keyword">declare</span> (ignore env))
  (<span class="keyword">let*</span> ((stack  (frameStack curFrame))
         (locals (frameLocals curFrame))
         (flags  (frameFlags curFrame))
         (Type1  (category1top  stack))
         (Stack1 (popCategory1 stack))
         (Type2  (category1top  Stack1))
         (Stack2 (popCategory1 Stack1))
         (Type3  (category1top Stack2))
         (rest   (popCategory1 Stack2))) 
    (mv (make-sig-frame locals
                        (pushList 
                         (list type2 type1 type3 type2 type1) rest)
                        flags)
        (exceptionStackFrame curFrame))))
                          


(<span class="keyword">defun</span> <span class="function-name">is_dup2_x1_form2</span> (env stack)
  (<span class="keyword">let*</span> ((Type1  (category2top  stack))
         (Stack1 (popCategory2 stack))
         (Type2  (category1top Stack1))
         (rest   (popCategory1 Stack1)))
    (and (isTopCategory2 stack)
         (isTopCategory1 Stack1)
         (canSafelyPushList env Rest (list Type1 Type2 Type1)))))

(<span class="keyword">defun</span> <span class="function-name">do_dup2_x1_form2</span> (env curFrame)
  (<span class="keyword">declare</span> (ignore env))
  (<span class="keyword">let*</span> ((stack  (frameStack curFrame))
         (locals (frameLocals curFrame))
         (flags  (frameFlags curFrame))
         (Type1  (category2top  stack))
         (Stack1 (popCategory2  stack))
         (Type2  (category1top Stack1))
         (rest   (popCategory1 Stack1)))
    (mv (make-sig-frame locals
                        (pushList (list type1 type2 type1) rest)
                        flags)
        (exceptionStackFrame curFrame))))

(<span class="keyword">defun</span> <span class="function-name">check-dup2_x1</span> (<a href="../DJVM/INST/inst.lisp.html">inst</a> env curFrame)
  (<span class="keyword">declare</span> (ignore <a href="../DJVM/INST/inst.lisp.html">inst</a>))
  (<span class="keyword">let</span> ((stack (frameStack curFrame)))
    (and (nth1OperandStackExist 3 curFrame)
         (or (is_dup2_form1 env stack)
             (is_dup2_form2 env stack)))))
                              
(<span class="keyword">defun</span> <span class="function-name">execute-dup2_x1</span> (<a href="../DJVM/INST/inst.lisp.html">inst</a> env curFrame)
  (<span class="keyword">declare</span> (ignore <a href="../DJVM/INST/inst.lisp.html">inst</a>))
  (<span class="keyword">let</span> ((stack (frameStack curFrame)))
    (<span class="keyword">cond</span> ((is_dup2_x1_form1 env stack)
           (do_dup2_x1_form1 env curFrame))
          ((is_dup2_x1_form2 env stack)
           (do_dup2_x1_form2 env curFrame))
          (t (mv nil nil)))))<span class="comment">;; impossible.
;--          
</span>
(<span class="keyword">defun</span> <span class="function-name">is_dup2_x2_form1</span> (env stack)
  (<span class="keyword">let*</span> ((Type1  (category1top  stack))
         (Stack1 (popCategory1 stack))
         (Type2  (category1top  Stack1))
         (Stack2 (popCategory1 Stack1))
         (Type3  (category1top Stack2))
         (Stack3 (popCategory1 Stack2))
         (Type4  (category1top Stack3))
         (rest   (popCategory1 Stack3)))
    (and (isTopCategory1 stack)
         (isTopCategory1 Stack1)
         (isTopCategory1 Stack2)
         (isTopCategory1 stack3)
         (canSafelyPushList env rest (list type2 type1 type4 type3 type2 type1)))))

(<span class="keyword">defun</span> <span class="function-name">do_dup2_x2_form1</span> (env curFrame)
  (<span class="keyword">declare</span> (ignore env))
  (<span class="keyword">let*</span> ((stack  (frameStack curFrame))
         (locals (frameLocals curFrame))
         (flags  (frameFlags curFrame))
         (Type1  (category1top  stack))
         (Stack1 (popCategory1 stack))
         (Type2  (category1top  Stack1))
         (Stack2 (popCategory1 Stack1))
         (Type3  (category1top Stack2))
         (Stack3 (popCategory1 Stack2))
         (Type4  (category1top Stack3))
         (rest   (popCategory1 Stack3))) 
    (mv (make-sig-frame locals
                        (pushList 
                         (list type2 type1 type4 type3 type2 type1) rest)
                        flags)
        (exceptionStackFrame curFrame))))



(<span class="keyword">defun</span> <span class="function-name">is_dup2_x2_form2</span> (env stack)
  (<span class="keyword">let*</span> ((Type1  (category2top  stack))
         (Stack1 (popCategory2  stack))
         (Type2  (category1top Stack1))
         (Stack2 (popCategory1 Stack1))
         (Type3  (category1top Stack2))
         (rest   (popCategory1 Stack2)))
    (and (isTopCategory2 stack)
         (isTopCategory1 Stack1)
         (isTopCategory1 Stack2)
         (canSafelyPushList env Rest (list Type1 Type3 Type2 Type1)))))

(<span class="keyword">defun</span> <span class="function-name">do_dup2_x2_form2</span> (env curFrame)
  (<span class="keyword">declare</span> (ignore env))
  (<span class="keyword">let*</span> ((stack  (frameStack curFrame))
         (locals (frameLocals curFrame))
         (flags  (frameFlags curFrame))
         (Type1  (category2top  stack))
         (Stack1 (popCategory2  stack))
         (Type2  (category1top    Stack1))
         (Stack2 (popCategory1 Stack1))
         (Type3  (category1top Stack2))
         (rest   (popCategory1 Stack2)))
    (mv (make-sig-frame locals
                        (pushList (list type1 type3 type2 type1) rest)
                        flags)
        (exceptionStackFrame curFrame))))


(<span class="keyword">defun</span> <span class="function-name">is_dup2_x2_form3</span> (env stack)
  (<span class="keyword">let*</span> ((Type1  (category1top  stack))
         (Stack1 (popCategory1 stack))
         (Type2  (category1top  Stack1))
         (Stack2 (popCategory1 Stack1))
         (Type3  (category2top Stack2))
         (rest   (popCategory2 Stack2))) 
    (and (isTopCategory1 stack)
         (isTopCategory1 Stack1)
         (isTopCategory2 Stack2)
         (canSafelyPushList env rest (list type2 type1 type3 type2 type1)))))

(<span class="keyword">defun</span> <span class="function-name">do_dup2_x2_form3</span> (env curFrame)
  (<span class="keyword">declare</span> (ignore env))
  (<span class="keyword">let*</span> ((stack  (frameStack curFrame))
         (locals (frameLocals curFrame))
         (flags  (frameFlags curFrame))
         (Type1  (category1top  stack))
         (Stack1 (popCategory1 stack))
         (Type2  (category1top  Stack1))
         (Stack2 (popCategory1 Stack1))
         (Type3  (category2top Stack2))
         (rest   (popCategory2 Stack2))) 
    (mv (make-sig-frame locals
                        (pushList 
                         (list type2 type1 type3 type2 type1) rest)
                        flags)
        (exceptionStackFrame curFrame))))
                          


(<span class="keyword">defun</span> <span class="function-name">is_dup2_x2_form4</span> (env stack)
  (<span class="keyword">let*</span> ((Type1  (category2top  stack))
         (Stack1 (popCategory2 stack))
         (Type2  (category2top  Stack1))
         (Rest   (popCategory2 Stack1)))
    (and (isTopCategory2 stack)
         (isTopCategory2 Stack1)
         (canSafelyPushList env Rest (list type1 type2 type1)))))


(<span class="keyword">defun</span> <span class="function-name">do_dup2_x2_form4</span> (env curFrame)
  (<span class="keyword">declare</span> (ignore env))
  (<span class="keyword">let*</span> ((stack  (frameStack curFrame))
         (locals (frameLocals curFrame))
         (flags  (frameFlags curFrame))
         (Type1  (category2top  stack))
         (Stack1 (popCategory2 stack))
         (Type2  (category2top  Stack1))
         (rest (popCategory2 Stack1)))
    (mv (make-sig-frame locals
                        (pushList 
                         (list type1 type2 type1) rest)
                        flags)
        (exceptionStackFrame curFrame))))

(<span class="keyword">defun</span> <span class="function-name">check-dup2_x2</span> (<a href="../DJVM/INST/inst.lisp.html">inst</a> env curFrame)
  (<span class="keyword">declare</span> (ignore <a href="../DJVM/INST/inst.lisp.html">inst</a>))
  (<span class="keyword">let</span> ((stack (frameStack curFrame)))
    (and (nth1OperandStackExist 4 curFrame)
         (or (is_dup2_x2_form1 env stack)
             (is_dup2_x2_form2 env stack)
             (is_dup2_x2_form3 env stack)
             (is_dup2_x2_form4 env stack)))))
                              
(<span class="keyword">defun</span> <span class="function-name">execute-dup2_x2</span> (<a href="../DJVM/INST/inst.lisp.html">inst</a> env curFrame)
  (<span class="keyword">declare</span> (ignore <a href="../DJVM/INST/inst.lisp.html">inst</a>))
  (<span class="keyword">let</span> ((stack (frameStack curFrame)))
    (<span class="keyword">cond</span> ((is_dup2_x2_form1 env stack)
           (do_dup2_x2_form1 env curFrame))
          ((is_dup2_x2_form2 env stack)
           (do_dup2_x2_form2 env curFrame))
          ((is_dup2_x2_form3 env stack)
           (do_dup2_x2_form3 env curFrame))
          ((is_dup2_x2_form4 env stack)
           (do_dup2_x2_form4 env curFrame))
          (t (mv nil nil)))))<span class="comment">;; impossible.
;--          
</span>
<span class="comment">;---
</span>(<span class="keyword">defun</span> <span class="function-name">check-f2d</span> (<a href="../DJVM/INST/inst.lisp.html">inst</a> env curFrame)
  (<span class="keyword">declare</span> (ignore <a href="../DJVM/INST/inst.lisp.html">inst</a>))
  (validTypeTransition env '(float) 'double curFrame))

(<span class="keyword">defun</span> <span class="function-name">execute-f2d</span> (<a href="../DJVM/INST/inst.lisp.html">inst</a> env curFrame)
  (<span class="keyword">declare</span> (ignore <a href="../DJVM/INST/inst.lisp.html">inst</a>))
  (mv (TypeTransition env '(float) 'double curFrame)
      (exceptionStackFrame curFrame)))
<span class="comment">;--
</span>
(<span class="keyword">defun</span> <span class="function-name">check-f2i</span> (<a href="../DJVM/INST/inst.lisp.html">inst</a> env curFrame)
  (<span class="keyword">declare</span> (ignore <a href="../DJVM/INST/inst.lisp.html">inst</a>))
  (validTypeTransition env '(float) 'int curFrame))

(<span class="keyword">defun</span> <span class="function-name">execute-f2i</span> (<a href="../DJVM/INST/inst.lisp.html">inst</a> env curFrame)
  (<span class="keyword">declare</span> (ignore <a href="../DJVM/INST/inst.lisp.html">inst</a>))
  (mv (TypeTransition env '(float) 'int curFrame)
      (exceptionStackFrame curFrame)))
<span class="comment">;--
</span>(<span class="keyword">defun</span> <span class="function-name">check-f2l</span> (<a href="../DJVM/INST/inst.lisp.html">inst</a> env curFrame)
  (<span class="keyword">declare</span> (ignore <a href="../DJVM/INST/inst.lisp.html">inst</a>))
  (validTypeTransition env '(float) 'long curFrame))

(<span class="keyword">defun</span> <span class="function-name">execute-f2l</span> (<a href="../DJVM/INST/inst.lisp.html">inst</a> env curFrame)
  (<span class="keyword">declare</span> (ignore <a href="../DJVM/INST/inst.lisp.html">inst</a>))
  (mv (TypeTransition env '(float) 'long curFrame)
      (exceptionStackFrame curFrame)))
<span class="comment">;--
</span>
(<span class="keyword">defun</span> <span class="function-name">check-fadd</span> (<a href="../DJVM/INST/inst.lisp.html">inst</a> env curFrame)
  (<span class="keyword">declare</span> (ignore <a href="../DJVM/INST/inst.lisp.html">inst</a>))
  (validTypeTransition env '(float float) 'float curFrame))

(<span class="keyword">defun</span> <span class="function-name">execute-fadd</span> (<a href="../DJVM/INST/inst.lisp.html">inst</a> env curFrame)
  (<span class="keyword">declare</span> (ignore <a href="../DJVM/INST/inst.lisp.html">inst</a>))
  (mv (TypeTransition env '(float float) 'float curFrame)
      (exceptionStackFrame curFrame)))
<span class="comment">;--
</span>(<span class="keyword">defun</span> <span class="function-name">check-faload</span> (<a href="../DJVM/INST/inst.lisp.html">inst</a> env curFrame)
  (<span class="keyword">declare</span> (ignore <a href="../DJVM/INST/inst.lisp.html">inst</a>))
  (validTypeTransition env '(int (array float)) 'float curFrame))

(<span class="keyword">defun</span> <span class="function-name">execute-faload</span> (<a href="../DJVM/INST/inst.lisp.html">inst</a> env curFrame)
  (<span class="keyword">declare</span> (ignore <a href="../DJVM/INST/inst.lisp.html">inst</a>))
  (mv (TypeTransition env '(int (array float)) 'float curFrame)
      (exceptionStackFrame curFrame)))
<span class="comment">;--
</span>(<span class="keyword">defun</span> <span class="function-name">check-fastore</span> (<a href="../DJVM/INST/inst.lisp.html">inst</a> env curFrame)
  (<span class="keyword">declare</span> (ignore <a href="../DJVM/INST/inst.lisp.html">inst</a>))
  (canPop env curFrame '(float int (array float))))

(<span class="keyword">defun</span> <span class="function-name">execute-fastore</span> (<a href="../DJVM/INST/inst.lisp.html">inst</a> env curFrame)
  (<span class="keyword">declare</span> (ignore <a href="../DJVM/INST/inst.lisp.html">inst</a>))
  (mv (TypeTransition env '(float int (array float)) 'void curFrame)
      (exceptionStackFrame curFrame)))
<span class="comment">;--
</span>(<span class="keyword">defun</span> <span class="function-name">check-fcmpg</span> (<a href="../DJVM/INST/inst.lisp.html">inst</a> env curFrame)
  (<span class="keyword">declare</span> (ignore <a href="../DJVM/INST/inst.lisp.html">inst</a>))
  (validTypeTransition env '(float float) 'int curFrame))

(<span class="keyword">defun</span> <span class="function-name">execute-fcmpg</span> (<a href="../DJVM/INST/inst.lisp.html">inst</a> env curFrame)
  (<span class="keyword">declare</span> (ignore <a href="../DJVM/INST/inst.lisp.html">inst</a>))
  (mv (TypeTransition env '(float float) 'int curFrame)
      (exceptionStackFrame curFrame)))
<span class="comment">;--
</span>(<span class="keyword">defun</span> <span class="function-name">check-fconst_0</span> (<a href="../DJVM/INST/inst.lisp.html">inst</a> env curFrame)
  (<span class="keyword">declare</span> (ignore <a href="../DJVM/INST/inst.lisp.html">inst</a>))
  (validTypeTransition env nil 'float curFrame))

(<span class="keyword">defun</span> <span class="function-name">execute-fconst_0</span> (<a href="../DJVM/INST/inst.lisp.html">inst</a> env curFrame)
  (<span class="keyword">declare</span> (ignore <a href="../DJVM/INST/inst.lisp.html">inst</a>))
  (mv (TypeTransition env nil 'float curFrame)
      (exceptionStackFrame curFrame)))
<span class="comment">;--
</span>(<span class="keyword">defun</span> <span class="function-name">check-fload</span> (<a href="../DJVM/INST/inst.lisp.html">inst</a> env curFrame)
  (<span class="keyword">let</span> ((index (arg1 <a href="../DJVM/INST/inst.lisp.html">inst</a>)))
    (loadIsTypeSafe env index 'float curFrame)))


(<span class="keyword">defun</span> <span class="function-name">execute-fload</span> (<a href="../DJVM/INST/inst.lisp.html">inst</a> env curFrame)
  (<span class="keyword">let*</span> ((index (arg1 <a href="../DJVM/INST/inst.lisp.html">inst</a>)))
    (mv (<span class="keyword">do-load</span> env index 'float curFrame)
        (exceptionStackFrame curFrame))))
<span class="comment">;--
</span>(<span class="keyword">defun</span> <span class="function-name">check-fneg</span> (<a href="../DJVM/INST/inst.lisp.html">inst</a> env curFrame)
  (<span class="keyword">declare</span> (ignore <a href="../DJVM/INST/inst.lisp.html">inst</a>))
  (validTypeTransition env '(float) 'float curFrame))

(<span class="keyword">defun</span> <span class="function-name">execute-fneg</span> (<a href="../DJVM/INST/inst.lisp.html">inst</a> env curFrame)
  (<span class="keyword">declare</span> (ignore <a href="../DJVM/INST/inst.lisp.html">inst</a>))
  (mv (TypeTransition env '(float) 'float curFrame)
      (exceptionStackFrame curFrame)))

<span class="comment">;--
</span>(<span class="keyword">defun</span> <span class="function-name">check-freturn</span> (<a href="../DJVM/INST/inst.lisp.html">inst</a> env curFrame)
  (<span class="keyword">declare</span> (ignore <a href="../DJVM/INST/inst.lisp.html">inst</a>))
  (<span class="keyword">let*</span> ((method (methodEnvironment env))
         (returnType (methodReturnType method)))
    (and (equal returnType 'float)
         (canPop env curFrame '(float)))))

(<span class="keyword">defun</span> <span class="function-name">execute-freturn</span> (<a href="../DJVM/INST/inst.lisp.html">inst</a> env curFrame)
  (<span class="keyword">declare</span> (ignore <a href="../DJVM/INST/inst.lisp.html">inst</a> env))
  (mv 'aftergoto 
      (exceptionStackFrame curFrame)))
<span class="comment">;--
</span>(<span class="keyword">defun</span> <span class="function-name">check-fstore</span> (<a href="../DJVM/INST/inst.lisp.html">inst</a> env curFrame)
  (<span class="keyword">let</span> ((index (arg1 <a href="../DJVM/INST/inst.lisp.html">inst</a>)))
    (storeIsTypeSafe env index 'float curFrame)))

(<span class="keyword">defun</span> <span class="function-name">execute-fstore</span> (<a href="../DJVM/INST/inst.lisp.html">inst</a> env curFrame)
  (<span class="keyword">let</span> ((index (arg1 <a href="../DJVM/INST/inst.lisp.html">inst</a>)))
    (mv (<span class="keyword">do-store</span> env index 'float curFrame)
        (exceptionStackFrame curFrame))))
<span class="comment">;---
;
; assume the field is well formed.
</span>
<span class="comment">;; (fieldCP &lt;name&gt; &lt;classname&gt; type)
</span>(<span class="keyword">defun</span> <span class="function-name">fieldNameCP</span> (FieldCP)
  (nth 1 fieldCP))
(<span class="keyword">defun</span> <span class="function-name">fieldClassNameCP</span> (FieldCP)
  (nth 2 fieldCP))

<span class="comment">;; Thu Aug 12 19:07:57 2004
;;; bug. 
;;; in djvm fieldCP-fieldtype assume unnormalized
;;; 
</span>
(<span class="keyword">defun</span> <span class="function-name">fieldTypeCP</span> (FieldCP)
  (nth 3 fieldCP))


(<span class="keyword">defun</span> <span class="function-name">superclassChain</span> (n cl)
  (cdr (collect-superclass-list n cl)))


(<span class="keyword">defun</span> <span class="function-name">find-field</span> (fname type fields)
  (<span class="keyword">if</span> (endp fields) nil
    (<span class="keyword">if</span> (and (equal (fieldName (car fields)) fname)
             (equal (fieldType (car fields)) type))
        (car fields)
      (find-field fname type (cdr fields)))))


(<span class="keyword">defun</span> <span class="function-name">lookupFieldInClasses</span> (fname type classes cl)
  (<span class="keyword">if</span> (endp classes) nil
    (<span class="keyword">let*</span> ((Class (class-by-name (car classes) cl)) 
           <span class="comment">;; if loaded didn't fail, this class must exist. 
</span>           (fields (classFields Class))
           (field  (find-field fname type fields)))
      (<span class="keyword">if</span> <span class="comment">;; field  ;;; Fri Jan 28 16:08:32 2005. 
</span>                    <span class="comment">;;; problem!!!. 
</span>                    <span class="comment">;;; We use nil to indicate not found!!
</span>          (and (equal (FIELDNAME field) FNAME)
               (equal (FIELDTYPE field) TYPE)) <span class="comment">;; actually find it.
</span>          field
        (lookupFieldInClasses fname type (cdr classes) cl)))))
        

(<span class="keyword">defun</span> <span class="function-name">isProtectedField</span> (fclassname fname type cl)
  (<span class="keyword">let*</span> ((classes (collect-superclass-list fclassname cl))
         (field   (lookupFieldInClasses fname type classes cl))
         <span class="comment">;; assume the resolution always find it.
</span>         <span class="comment">;; because resolution is done
</span>         (accessflags (fieldAccessFlags field)))
    (member '*protected* accessflags)))

<span class="comment">;; under well formed condition:
;;
;;    isProtected == (not (isNotProtected))
;;
;; It is not true otherwise. Do we need to prove this? or 
;; define: isNotProtected to be not isProtected? 
;;
;; Hanbing   
;;
</span>
<span class="comment">;;
;; this implemention means if not found assume it is not protected!!
;;
;; notice this resolution process is the same as the resolution step in the
;; execution time. --- April 18th. 
</span>
<span class="comment">;; Sun Apr 17 14:10:26 2005. fixed!! 
</span>

(<span class="keyword">defun</span> <span class="function-name">passesProtectedFieldCheck</span> (env fclassname fname type target)
  (<span class="keyword">let*</span> ((curClass (classEnvironment env))
         (curClassName (classClassName curClass))
         (cl  (classtableEnvironment env))
         (superchain   (superclassChain curClassName cl)))
    (or (not (mem fclassName superchain))
        (not (isProtectedField fclassname fname type cl))
        (isAssignable target (prefix-class curClassName) env))))


<span class="comment">;;; Fri Jun 17 17:48:51 2005 modification! 
;;; more modification. 
;;; to assert that fieldcp-classname is not "java.lang.Object"
;;; not some interface type!! 
;;; 
</span> 

<span class="comment">;; ;; (defun check-getfield (<a href="../DJVM/INST/inst.lisp.html">inst</a> env curFrame)
;; ;;   (let* ((CP (arg1 <a href="../DJVM/INST/inst.lisp.html">inst</a>))
;; ;;          (fieldClassName (fieldClassNameCP cp))
;; ;;          (fieldName      (fieldNameCP cp))
;; ;;          (fieldType1      (fieldTypeCP  cp))
;; ;;          (fieldType       (translate-type fieldType1))
;; ;;          (operandStack    (frameStack curFrame))
;; ;;          (target          (top operandStack)))
;; ;;     (and 
;; ;;      (passesProtectedFieldCheck env fieldClassName fieldName fieldType target)
;; ;;      (not (equal fieldClassName "java.lang.Object"))
;; ;;      (class-by-name fieldClassName
;; ;;                     (classtableEnvironment env))
;; ;;      (not (classIsInterface
;; ;;            (class-by-name fieldClassName
;; ;;                           (classtableEnvironment env))))
;; ;;      (validTypeTransition env 
;; ;;                           (list (prefix-class fieldClassName))
;; ;;                           fieldType
;; ;;                           curFrame)
;; ;;      (not (isArrayType target)))))
</span>
<span class="comment">;;;;;  after discussion with Gilad. This is not what he want!!
;;;;; 
</span>
(<span class="keyword">defun</span> <span class="function-name">check-getfield</span> (<a href="../DJVM/INST/inst.lisp.html">inst</a> env curFrame)
  (<span class="keyword">let*</span> ((CP (arg1 <a href="../DJVM/INST/inst.lisp.html">inst</a>))
         (fieldClassName (fieldClassNameCP cp))
         (fieldName      (fieldNameCP cp))
         (fieldType1      (fieldTypeCP  cp))
         (fieldType       (translate-type fieldType1))
         (operandStack    (frameStack curFrame))
         (target          (top operandStack)))
    (and 
     (passesProtectedFieldCheck env fieldClassName fieldName fieldType target)
     (validTypeTransition env 
                          (list (prefix-class fieldClassName))
                          fieldType
                          curFrame))))

<span class="comment">;;;  (not (isArrayType (fieldClassName 
;;;  (not (isArrayType target)))))
;;; 
</span>



(<span class="keyword">defun</span> <span class="function-name">execute-getfield</span> (<a href="../DJVM/INST/inst.lisp.html">inst</a> env curFrame)
  (<span class="keyword">let*</span> ((CP (arg1 <a href="../DJVM/INST/inst.lisp.html">inst</a>))
         (fieldClassName (fieldClassNameCP cp))
         (fieldType1      (fieldTypeCP  cp))
         (fieldType       (translate-type fieldType1)))
    (mv (TypeTransition env 
                        (list (prefix-class fieldClassName))
                        fieldType
                        curFrame)
        (exceptionStackFrame curFrame))))

<span class="comment">;---
</span>(<span class="keyword">defun</span> <span class="function-name">check-getstatic</span> (<a href="../DJVM/INST/inst.lisp.html">inst</a> env curFrame)
  (<span class="keyword">let*</span> ((CP (arg1 <a href="../DJVM/INST/inst.lisp.html">inst</a>))
         (fieldType1      (fieldTypeCP  cp))
         (fieldType       (translate-type fieldType1)))
    (validTypeTransition env 
                         nil
                         fieldType
                         curFrame)))

(<span class="keyword">defun</span> <span class="function-name">execute-getstatic</span> (<a href="../DJVM/INST/inst.lisp.html">inst</a> env curFrame)
  (<span class="keyword">let*</span> ((CP (arg1 <a href="../DJVM/INST/inst.lisp.html">inst</a>))
         (fieldType1      (fieldTypeCP  cp))
         (fieldType       (translate-type fieldType1)))
    (mv (TypeTransition env 
                        nil
                        fieldType
                        curFrame)
        (exceptionStackFrame curFrame))))
<span class="comment">;
;----
;
</span>
<span class="comment">; --- search for StackFrame at offset Target --- 
</span>
(<span class="keyword">defun</span> <span class="function-name">searchStackFrame</span> (target Instructions)<span class="comment">;; *12*
</span>  (<span class="keyword">if</span> (endp Instructions) 
      nil
    (<span class="keyword">if</span> (isStackMapFrame (car Instructions))
        (<span class="keyword">if</span> (equal (mapOffset (getMap (car Instructions)))
                   target)
            (mapFrame (getMap (car Instructions)))
          (searchStackFrame target (cdr Instructions)))
      (searchStackFrame target (cdr Instructions)))))

<span class="comment">;; *12* Note: 
;;      Instructions here is Merged Instruction
;;      produced by intermixed StackMap and Parsed Instruction.
</span>  

(<span class="keyword">defun</span> <span class="function-name">stackFrameAtOffset</span> (Environment Target)
  (<span class="keyword">let</span> ((Instructions (AllInstructions Environment)))
    (searchStackFrame target Instructions)))



(<span class="keyword">defun</span> <span class="function-name">isStackFrame</span> (stackFrame)
  (and (consp stackFrame)
       (equal (car stackFrame) 'frame)))


(<span class="keyword">defun</span> <span class="function-name">targetIsTypeSafe</span> (Environment StackFrame Target)
  (<span class="keyword">let</span> ((Frame (stackFrameAtOffset Environment target)))
    (and <span class="comment">;; (isStackMapFrame Frame) 
</span>         <span class="comment">;; added Wed Jul 27 23:37:22 2005. Tue Dec 20 19:56:07 2005!!! 
</span>         <span class="comment">;; Wed Jul 27 23:37:24 2005
</span>         <span class="comment">;; Tue Dec 20 19:55:42 2005
</span>         (isStackFrame Frame) 
         (frameIsAssignable StackFrame Frame environment))))
<span class="comment">;; you have to be a well formed frame for it tobe frame Assignable
</span>

(<span class="keyword">defun</span> <span class="function-name">check-goto</span> (<a href="../DJVM/INST/inst.lisp.html">inst</a> env curFrame)
  (<span class="keyword">let</span> ((target (arg1 <a href="../DJVM/INST/inst.lisp.html">inst</a>)))
    (targetIsTypeSafe env curFrame target)))

(<span class="keyword">defun</span> <span class="function-name">execute-goto</span> (<a href="../DJVM/INST/inst.lisp.html">inst</a> env curFrame)
  (<span class="keyword">declare</span> (ignore <a href="../DJVM/INST/inst.lisp.html">inst</a> env))
  (mv 'aftergoto 
      (exceptionStackFrame curFrame)))

<span class="comment">;--
</span>        
<span class="comment">;---
</span>(<span class="keyword">defun</span> <span class="function-name">check-i2d</span> (<a href="../DJVM/INST/inst.lisp.html">inst</a> env curFrame)
  (<span class="keyword">declare</span> (ignore <a href="../DJVM/INST/inst.lisp.html">inst</a>))
  (validTypeTransition env '(int) 'double curFrame))

(<span class="keyword">defun</span> <span class="function-name">execute-i2d</span> (<a href="../DJVM/INST/inst.lisp.html">inst</a> env curFrame)
  (<span class="keyword">declare</span> (ignore <a href="../DJVM/INST/inst.lisp.html">inst</a>))
  (mv (TypeTransition env '(int) 'double curFrame)
      (exceptionStackFrame curFrame)))

<span class="comment">;---
</span>(<span class="keyword">defun</span> <span class="function-name">check-i2f</span> (<a href="../DJVM/INST/inst.lisp.html">inst</a> env curFrame)
  (<span class="keyword">declare</span> (ignore <a href="../DJVM/INST/inst.lisp.html">inst</a>))
  (validTypeTransition env '(int) 'float curFrame))

(<span class="keyword">defun</span> <span class="function-name">execute-i2f</span> (<a href="../DJVM/INST/inst.lisp.html">inst</a> env curFrame)
  (<span class="keyword">declare</span> (ignore <a href="../DJVM/INST/inst.lisp.html">inst</a>))
  (mv (TypeTransition env '(int) 'float curFrame)
      (exceptionStackFrame curFrame)))
<span class="comment">;--
</span>
(<span class="keyword">defun</span> <span class="function-name">check-i2l</span> (<a href="../DJVM/INST/inst.lisp.html">inst</a> env curFrame)
  (<span class="keyword">declare</span> (ignore <a href="../DJVM/INST/inst.lisp.html">inst</a>))
  (validTypeTransition env '(int) 'long curFrame))

(<span class="keyword">defun</span> <span class="function-name">execute-i2l</span> (<a href="../DJVM/INST/inst.lisp.html">inst</a> env curFrame)
  (<span class="keyword">declare</span> (ignore <a href="../DJVM/INST/inst.lisp.html">inst</a>))
  (mv (TypeTransition env '(int) 'long curFrame)
      (exceptionStackFrame curFrame)))
<span class="comment">;--
</span>
(<span class="keyword">defun</span> <span class="function-name">check-iadd</span> (<a href="../DJVM/INST/inst.lisp.html">inst</a> env curFrame)
  (<span class="keyword">declare</span> (ignore <a href="../DJVM/INST/inst.lisp.html">inst</a>))
  (validTypeTransition env '(int int) 'int curFrame))

(<span class="keyword">defun</span> <span class="function-name">execute-iadd</span> (<a href="../DJVM/INST/inst.lisp.html">inst</a> env curFrame)
  (<span class="keyword">declare</span> (ignore <a href="../DJVM/INST/inst.lisp.html">inst</a>))
  (mv (TypeTransition env '(int int) 'int curFrame)
      (exceptionStackFrame curFrame)))
<span class="comment">;--
</span>(<span class="keyword">defun</span> <span class="function-name">check-iaload</span> (<a href="../DJVM/INST/inst.lisp.html">inst</a> env curFrame)
  (<span class="keyword">declare</span> (ignore <a href="../DJVM/INST/inst.lisp.html">inst</a>))
  (validTypeTransition env '(int (array int)) 'int curFrame))

(<span class="keyword">defun</span> <span class="function-name">execute-iaload</span> (<a href="../DJVM/INST/inst.lisp.html">inst</a> env curFrame)
  (<span class="keyword">declare</span> (ignore <a href="../DJVM/INST/inst.lisp.html">inst</a>))
  (mv (TypeTransition env '(int (array int)) 'int curFrame)
      (exceptionStackFrame curFrame)))
<span class="comment">;--
</span>(<span class="keyword">defun</span> <span class="function-name">check-iastore</span> (<a href="../DJVM/INST/inst.lisp.html">inst</a> env curFrame)
  (<span class="keyword">declare</span> (ignore <a href="../DJVM/INST/inst.lisp.html">inst</a>))
  (canPop env curFrame '(int int  (array int))))

(<span class="keyword">defun</span> <span class="function-name">execute-iastore</span> (<a href="../DJVM/INST/inst.lisp.html">inst</a> env curFrame)
  (<span class="keyword">declare</span> (ignore <a href="../DJVM/INST/inst.lisp.html">inst</a>))
  (mv (TypeTransition env '(int int (array int)) 'void curFrame)
      (exceptionStackFrame curFrame)))
<span class="comment">;--
;; assume the offset has been resolved. target gives the offset from
;; the beginning of the method. 
</span>
(<span class="keyword">defun</span> <span class="function-name">check-if_acmpeq</span> (<a href="../DJVM/INST/inst.lisp.html">inst</a> env curFrame)
  (<span class="keyword">let</span> ((target (arg1 <a href="../DJVM/INST/inst.lisp.html">inst</a>))
        (nextframe (PopMatchingList '(reference reference)  curFrame)))
    (and (canPop env curFrame '(reference reference))
         (targetIsTypeSafe env nextFrame target))))

(<span class="keyword">defun</span> <span class="function-name">execute-if_acmpeq</span> (<a href="../DJVM/INST/inst.lisp.html">inst</a> env curFrame)
  (<span class="keyword">declare</span> (ignore <a href="../DJVM/INST/inst.lisp.html">inst</a>))
  (mv (TypeTransition env 
                      '(reference reference)
                      'void 
                      curFrame)
      (exceptionStackFrame curFrame)))
<span class="comment">;--
</span>(<span class="keyword">defun</span> <span class="function-name">check-if_icmpeq</span> (<a href="../DJVM/INST/inst.lisp.html">inst</a> env curFrame)
  (<span class="keyword">let</span> ((target (arg1 <a href="../DJVM/INST/inst.lisp.html">inst</a>))
        (nextframe (PopMatchingList '(int int) curFrame)))
    (and (canPop env curFrame '(int int))
         (targetIsTypeSafe env nextFrame target))))

(<span class="keyword">defun</span> <span class="function-name">execute-if_icmpeq</span> (<a href="../DJVM/INST/inst.lisp.html">inst</a> env curFrame)
  (<span class="keyword">declare</span> (ignore <a href="../DJVM/INST/inst.lisp.html">inst</a>))
  (mv (TypeTransition env 
                      '(int int)
                      'void 
                      curFrame)
      (exceptionStackFrame curFrame)))
<span class="comment">;--
</span>(<span class="keyword">defun</span> <span class="function-name">check-ifeq</span> (<a href="../DJVM/INST/inst.lisp.html">inst</a> env curFrame)
  (<span class="keyword">let</span> ((target (arg1 <a href="../DJVM/INST/inst.lisp.html">inst</a>))
        (nextFrame (PopMatchingList '(int) curFrame)))
    (and (canPop env curFrame '(int))
         (targetIsTypeSafe env nextFrame target))))

(<span class="keyword">defun</span> <span class="function-name">execute-ifeq</span> (<a href="../DJVM/INST/inst.lisp.html">inst</a> env curFrame)
  (<span class="keyword">declare</span> (ignore <a href="../DJVM/INST/inst.lisp.html">inst</a>))
  (mv (TypeTransition env 
                      '(int)
                      'void 
                      curFrame)
      (exceptionStackFrame curFrame)))
<span class="comment">;--
</span>(<span class="keyword">defun</span> <span class="function-name">check-ifnonnull</span> (<a href="../DJVM/INST/inst.lisp.html">inst</a> env curFrame)
  (<span class="keyword">let</span> ((target (arg1 <a href="../DJVM/INST/inst.lisp.html">inst</a>))
        (nextFrame (PopMatchingList '(reference) curFrame)))
    (and (canPop env curFrame '(reference))
         (targetIsTypeSafe env nextFrame target))))

(<span class="keyword">defun</span> <span class="function-name">execute-ifnonnull</span> (<a href="../DJVM/INST/inst.lisp.html">inst</a> env curFrame)
  (<span class="keyword">declare</span> (ignore <a href="../DJVM/INST/inst.lisp.html">inst</a>))
  (mv (TypeTransition env 
                      '(reference)
                      'void 
                      curFrame)
      (exceptionStackFrame curFrame)))
<span class="comment">;--
; assume well formed <a href="../DJVM/INST/inst.lisp.html">inst</a>
</span>(<span class="keyword">defun</span> <span class="function-name">check-iinc</span> (<a href="../DJVM/INST/inst.lisp.html">inst</a> env curFrame)
  (<span class="keyword">declare</span> (ignore env))
  (<span class="keyword">let*</span> ((locals (frameLocals curFrame))
         (index  (arg1 <a href="../DJVM/INST/inst.lisp.html">inst</a>)))
    (and (nthLocalsExist index 'int curFrame)
         (equal (nth index locals) 'int))))

(<span class="keyword">defun</span> <span class="function-name">execute-iinc</span> (<a href="../DJVM/INST/inst.lisp.html">inst</a> env curFrame)
  (<span class="keyword">declare</span> (ignore <a href="../DJVM/INST/inst.lisp.html">inst</a> env))
  (mv curFrame (exceptionStackFrame curFrame)))
<span class="comment">;--
</span>(<span class="keyword">defun</span> <span class="function-name">check-iload</span> (<a href="../DJVM/INST/inst.lisp.html">inst</a> env curFrame)
  (<span class="keyword">let</span> ((index (arg1 <a href="../DJVM/INST/inst.lisp.html">inst</a>)))
    (loadIsTypeSafe env index 'int curFrame)))


(<span class="keyword">defun</span> <span class="function-name">execute-iload</span> (<a href="../DJVM/INST/inst.lisp.html">inst</a> env curFrame)
  (<span class="keyword">let*</span> ((index (arg1 <a href="../DJVM/INST/inst.lisp.html">inst</a>)))
    (mv (<span class="keyword">do-load</span> env index 'int curFrame)
        (exceptionStackFrame curFrame))))
<span class="comment">;--
</span>(<span class="keyword">defun</span> <span class="function-name">check-ineg</span> (<a href="../DJVM/INST/inst.lisp.html">inst</a> env curFrame)
  (<span class="keyword">declare</span> (ignore <a href="../DJVM/INST/inst.lisp.html">inst</a>))
  (validTypeTransition env '(int) 'int curFrame))

(<span class="keyword">defun</span> <span class="function-name">execute-ineg</span> (<a href="../DJVM/INST/inst.lisp.html">inst</a> env curFrame)
  (<span class="keyword">declare</span> (ignore <a href="../DJVM/INST/inst.lisp.html">inst</a>))
  (mv (TypeTransition env '(int) 'int curFrame)
      (exceptionStackFrame curFrame)))
<span class="comment">;--
</span>(<span class="keyword">defun</span> <span class="function-name">check-<a href="../DJVM/INST/inst.lisp.html">inst</a>anceof</span> (<a href="../DJVM/INST/inst.lisp.html">inst</a> env curFrame)
  (<span class="keyword">let</span> ((CP (arg1 <a href="../DJVM/INST/inst.lisp.html">inst</a>)))
    (and (or (isClassType CP)
             (isArrayType CP))
         (validTypeTransition env  '((class <span class="string">"java.lang.Object"</span>))
                              'int  curFrame))))

(<span class="keyword">defun</span> <span class="function-name">execute-<a href="../DJVM/INST/inst.lisp.html">inst</a>anceof</span> (<a href="../DJVM/INST/inst.lisp.html">inst</a> env curFrame)
  (<span class="keyword">declare</span> (ignore <a href="../DJVM/INST/inst.lisp.html">inst</a>))
  (mv (TypeTransition env  '((class <span class="string">"java.lang.Object"</span>))
                      'int curFrame)
      (exceptionStackFrame curFrame)))
<span class="comment">;--
;; assume well formed inst, CP, Count , 0
</span>
(<span class="keyword">defun</span> <span class="function-name">CountIsValid</span> (count InFrame OutFrame)
  (equal count (- (len (frameStack InFrame)) 
                  (len (frameStack OutFrame)))))


<span class="comment">;; (methodCP &lt;name&gt; &lt;className&gt; (&lt;type&gt;*) returntype)
</span>(<span class="keyword">defun</span> <span class="function-name">methodNameCP</span> (MethodCP)
  (nth 1 MethodCP))
(<span class="keyword">defun</span> <span class="function-name">methodClassNameCP</span> (MethodCP)
  (nth 2 MethodCP))
(<span class="keyword">defun</span> <span class="function-name">methodArgListCP</span> (MethodCP)
  (nth 3 MethodCP))
(<span class="keyword">defun</span> <span class="function-name">methodReturnTypeCP</span> (MethodCP)
  (nth 4 MethodCP))

<span class="comment">;;
;; assuming the last count is always zero, we 
;; omit it in the representation of the invokeinterface
;;
</span>
(<span class="keyword">defun</span> <span class="function-name">check-invokeinterface</span> (<a href="../DJVM/INST/inst.lisp.html">inst</a> env curFrame)
  (<span class="keyword">let*</span> ((CP (arg1 <a href="../DJVM/INST/inst.lisp.html">inst</a>))
         (Count (arg2 <a href="../DJVM/INST/inst.lisp.html">inst</a>)) 
         (methodName (methodNameCP CP))
         (returnType1 (methodReturnTypeCP CP))
         (returnType  (translate-type returnType1))
         (OperandArgList1 (methodArgListCP CP))
         (OperandArgList  (translate-types OperandArgList1))
         (MethodClassName (methodClassNameCP CP))
         (StackArgList    (reverse (cons (prefix-class MethodClassName) 
                                         OperandArgList)))
         (tempFrame (PopMatchingList StackArgList curFrame)))
    (and (not (equal MethodName <span class="string">"&lt;init&gt;"</span>))
         (not (equal MethodName <span class="string">"&lt;clinit&gt;"</span>))
         (canPop env curFrame StackArgList)
         (validTypeTransition env nil returnType tempFrame)
         (countIsValid Count curFrame TempFrame))))

(<span class="keyword">defun</span> <span class="function-name">execute-invokeinterface</span> (<a href="../DJVM/INST/inst.lisp.html">inst</a> env curFrame)
  (<span class="keyword">let*</span> ((CP (arg1 <a href="../DJVM/INST/inst.lisp.html">inst</a>))
         (returnType1 (methodReturnTypeCP CP))
         (returnType  (translate-type returnType1))
         (OperandArgList1 (methodArgListCP CP))
         (OperandArgList  (translate-types OperandArgList1))
         (MethodClassName (methodClassNameCP CP))
         (StackArgList    (reverse (cons (prefix-class MethodClassName) 
                                         OperandArgList)))
         (tempFrame (PopMatchingList StackArgList curFrame)))
    (mv (TypeTransition env nil returnType tempFrame)
        (exceptionStackFrame curFrame))))
<span class="comment">;--
;     CP = method(MethodClassName, MethodName, Signature) 
;--
</span>
(<span class="keyword">defun</span> <span class="function-name">is-invoke-non-init</span> (<a href="../DJVM/INST/inst.lisp.html">inst</a> env curFrame)
  (<span class="keyword">let*</span> ((CP (arg1 <a href="../DJVM/INST/inst.lisp.html">inst</a>))
         (methodName (methodNameCP CP))
         (returnType1 (methodReturnTypeCP CP))
         (returnType  (translate-type returnType1))
         (OperandArgList1 (methodArgListCP CP))
         (OperandArgList  (translate-types OperandArgList1))
         (CurrentClass (thisClassEnvironment env))
         (StackArgList    (reverse (cons (prefix-class CurrentClass)
                                         OperandArgList)))
         (MethodClassName (methodClassNameCP CP))
         (StackArgList2  (reverse (cons (prefix-class MethodClassName) 
                                        OperandArgList))))
    (and (not (equal MethodName <span class="string">"&lt;init&gt;"</span>))
         (not (equal MethodName <span class="string">"&lt;clinit&gt;"</span>))
         (validTypeTransition env StackArgList  returnType curFrame)
         (validTypeTransition env StackArgList2 returnType curFrame))))


(<span class="keyword">defun</span> <span class="function-name">do-invoke-non-init</span> (<a href="../DJVM/INST/inst.lisp.html">inst</a> env curFrame)
  (<span class="keyword">let*</span> ((CP (arg1 <a href="../DJVM/INST/inst.lisp.html">inst</a>))
         (returnType1 (methodReturnTypeCP CP))
         (returnType  (translate-type returnType1))
         (OperandArgList1 (methodArgListCP CP))
         (OperandArgList  (translate-types OperandArgList1))
         (MethodClassName (methodClassNameCP CP))
         (StackArgList    (reverse (cons (prefix-class MethodClassName) 
                                         OperandArgList)))
         (tempFrame (PopMatchingList StackArgList curFrame)))
    (mv (TypeTransition env nil returnType tempFrame)
        (exceptionStackFrame curFrame))))          

(<span class="keyword">defun</span> <span class="function-name">address-uninit</span> (uninit)
  (cadr uninit))

(<span class="keyword">defun</span> <span class="function-name">make-inst1</span> (offset opcode arg1)
  (list offset (list opcode arg1)))

(<span class="keyword">defun</span> <span class="function-name">is-invoke-init</span> (<a href="../DJVM/INST/inst.lisp.html">inst</a> env curFrame)
  (<span class="keyword">let*</span> ((CP (arg1 <a href="../DJVM/INST/inst.lisp.html">inst</a>))
         (methodName (methodNameCP CP))
         (methodClassName (methodClassNameCP CP))
         (OperandArgList1 (methodArgListCP CP))
         (OperandArgList  (translate-types OperandArgList1))
         (StackArgList (reverse OperandArgList))
         (TempFrame (popMatchingList StackArgList curFrame))
         (FullOperandStack (frameStack TempFrame))
         (UninitializedArg (top FullOperandStack)))
    (and (equal methodName <span class="string">"&lt;init&gt;"</span>)
         (or (equal UninitializedArg 'uninitializedThis)
             (and (isuninitializedObject UninitializedArg)
                  (mem (make-inst1 (address-uninit  uninitializedArg)
                                   'new
                                   (prefix-class methodClassName))
                       (allInstructions env))))
         <span class="comment">;; 'uninitializedThis comes from the original parameter of &lt;init&gt;
</span>         <span class="comment">;; (what instruction inside of &lt;init&gt; see. (recursive invoke)
</span>         <span class="comment">;; (uninitialized &lt;offset&gt;) is what code of outside &lt;init&gt; see
</span>         <span class="comment">;; (invokespecial ...)
</span>         (CanPop env curFrame StackArgList))))

(<span class="keyword">defun</span> <span class="function-name">rewrittenUninitializedType</span> (type env MethodClassCP)
  (<span class="keyword">cond</span> ((equal type 'uninitializedThis)
         (prefix-class  (thisClassEnvironment env)))
        ((equal (car type) 'uninitialized)
         MethodClassCP)
        (t nil)))

(<span class="keyword">defun</span> <span class="function-name">rewrittenInitializationFlags</span> (type Flags)
  (<span class="keyword">cond</span> ((equal type 'uninitializedThis) nil)
        ((isuninitializedObject type) Flags)
        (t nil)))
  
<span class="comment">;--
</span>(<span class="keyword">defun</span> <span class="function-name">replacex</span> (old new lst)
  (<span class="keyword">if</span> (endp lst)
      nil
    (<span class="keyword">if</span> (equal (car lst) old)
        (cons new (replacex old new (cdr lst)))
      (cons (car lst) (replacex old new (cdr lst))))))
<span class="comment">;--
</span>

(<span class="keyword">defun</span> <span class="function-name">do-invoke-init</span> (<a href="../DJVM/INST/inst.lisp.html">inst</a> env curFrame)
  (<span class="keyword">let*</span> ((CP (arg1 <a href="../DJVM/INST/inst.lisp.html">inst</a>))
         (methodClassName (methodClassNameCP CP))
         (OperandArgList1 (methodArgListCP CP))
         (OperandArgList  (translate-types OperandArgList1))
         (StackArgList (reverse OperandArgList))
         (TempFrame (popMatchingList StackArgList curFrame))
         (FullOperandStack (frameStack TempFrame))
         (Flags (frameFlags TempFrame))
         (Locals (frameLocals TempFrame))
         (UninitializedArg (top FullOperandStack))
         (This (rewrittenUninitializedType 
                UninitializedArg env (prefix-class MethodClassName)))
         (NextFlags (rewrittenInitializationFlags UninitializedArg Flags))
         (OperandStack (pop FullOperandStack))
         (NextOperandStack (replacex UninitializedArg This OperandStack))
         (NextLocals (replacex UninitializedArg This Locals)))
    (prog2$ 
     (acl2::debug-print <span class="string">"PC = ~p0 Initializing ~p1~%"</span> (<a href="../DJVM/INST/inst.lisp.html">inst</a>rOffset <a href="../DJVM/INST/inst.lisp.html">inst</a>) UninitializedArg)
     (mv (make-sig-frame NextLocals NextOperandStack NextFlags)
         (make-sig-frame NextLocals nil Flags)))))


(<span class="keyword">defun</span> <span class="function-name">check-invokespecial</span> (<a href="../DJVM/INST/inst.lisp.html">inst</a> env curFrame)
  (or (is-invoke-init <a href="../DJVM/INST/inst.lisp.html">inst</a> env curFrame)
      (is-invoke-non-init <a href="../DJVM/INST/inst.lisp.html">inst</a> env curFrame)))

(<span class="keyword">defun</span> <span class="function-name">execute-invokespecial</span> (<a href="../DJVM/INST/inst.lisp.html">inst</a> env curFrame)
  (<span class="keyword">cond</span> ((is-invoke-non-init <a href="../DJVM/INST/inst.lisp.html">inst</a> env curFrame) 
         (<span class="keyword">do-invoke-non-init</span> <a href="../DJVM/INST/inst.lisp.html">inst</a> env curFrame))
        ((is-invoke-init  <a href="../DJVM/INST/inst.lisp.html">inst</a> env curFrame)
         (<span class="keyword">do-invoke-init</span> <a href="../DJVM/INST/inst.lisp.html">inst</a> env curFrame))
        (t (mv nil nil)))) 
<span class="comment">;;
;; ERROR STATE well formed prevent it to happend
;;
;; What would happen if resolution failed??
;; bytecode verifier has to ensure resolution succeeds!!
;;
</span>
<span class="comment">;--
</span>(<span class="keyword">defun</span> <span class="function-name">check-invokestatic</span> (<a href="../DJVM/INST/inst.lisp.html">inst</a> env curFrame)
  (<span class="keyword">let*</span> ((CP (arg1 <a href="../DJVM/INST/inst.lisp.html">inst</a>))
         (methodName     (methodNameCP CP))
         (OperandArgList1 (methodArgListCP CP))
         (OperandArgList  (translate-types OperandArgList1))
         (ReturnType1     (methodReturnTypeCP CP))
         (returnType  (translate-type returnType1))
         (StackArgList (reverse OperandArgList)))
    (and (not (equal methodName <span class="string">"&lt;clinit&gt;"</span>))
         (validTypeTransition env StackArgList ReturnType
                              curFrame))))

(<span class="keyword">defun</span> <span class="function-name">execute-invokestatic</span> (<a href="../DJVM/INST/inst.lisp.html">inst</a> env curFrame)
  (<span class="keyword">let*</span> ((CP (arg1 <a href="../DJVM/INST/inst.lisp.html">inst</a>))
         (OperandArgList1 (methodArgListCP CP))
         (OperandArgList  (translate-types OperandArgList1))
         (ReturnType1     (methodReturnTypeCP CP))
         (returnType  (translate-type returnType1))
         (StackArgList (reverse OperandArgList)))
    (mv (TypeTransition env StackArgList ReturnType
                        curFrame)
        (exceptionStackFrame curFrame))))
<span class="comment">;--
</span>(<span class="keyword">defun</span> <span class="function-name">find-method</span> (mName returnType argTypes methods)
  (<span class="keyword">if</span> (endp methods) nil
    (<span class="keyword">if</span> (and (equal (methodName (car methods)) mName)
             (equal (methodReturnType (car methods)) returnType)
             (equal (methodParameters (car methods)) argTypes))
        (car methods)
      (find-method mName returnType argTypes (cdr methods)))))


(<span class="keyword">defun</span> <span class="function-name">lookupMethodInClasses</span> (mName returnType argTypes classes cl)
  (<span class="keyword">if</span> (endp classes) nil
    (<span class="keyword">let*</span> ((Class (class-by-name (car classes) cl)) 
           <span class="comment">;; if loaded didn't fail, this class must exist. 
</span>           (methods (classMethods Class))
           (method (find-method mName returnType argTypes methods)))
      (<span class="keyword">if</span> <span class="comment">;; method ;; same problem as in lookupFieldInClasses
</span>          (and (equal (methodName (car methods)) mName)
               (equal (methodReturnType (car methods)) returnType)
               (equal (methodParameters (car methods)) argTypes))
          method
        (lookupMethodInClasses mName returnType argTypes (cdr classes) cl)))))

(<span class="keyword">defun</span> <span class="function-name">isProtectedMethod</span> (mClassName mName returntype args cl)
  (<span class="keyword">let*</span> ((classes (collect-superclass-list mClassName cl))
         (method  (lookupMethodInClasses mName returntype args classes cl))
         (accessflags (methodAccessFlags method)))
    (member '*protected* accessflags)))
<span class="comment">;; assume the resolution always find it.
;; because resolution is done
</span>
(<span class="keyword">defun</span> <span class="function-name">passesProtectedMethodCheck</span> 
  (env mClassName mName returntype args target)
  (<span class="keyword">let*</span> ((curClass (classEnvironment env))
         (curClassName (classClassName curClass))
         (cl  (classtableEnvironment env))
         (superchain   (superclassChain curClassName cl)))
    (or (not (mem curClassName superchain))
        (not (isProtectedMethod mClassname mName returntype args cl))
        (isAssignable target (prefix-class curClassName) env))))


(<span class="keyword">defun</span> <span class="function-name">check-invokevirtual</span> (<a href="../DJVM/INST/inst.lisp.html">inst</a> env curFrame)
  (<span class="keyword">let*</span> ((CP (arg1 <a href="../DJVM/INST/inst.lisp.html">inst</a>))
         (methodName      (methodNameCP     CP))
         (methodClassName (methodClassNameCP  CP))
         (OperandArgList1 (methodArgListCP CP))
         (OperandArgList  (translate-types OperandArgList1))
         (ReturnType1     (methodReturnTypeCP CP))
         (returnType  (translate-type returnType1))
         (StackArgList (reverse (cons (prefix-class MethodClassName) 
                                      OperandArgList)))
         (target (top (popMatchingList1 (reverse OperandArgList) (frameStack curFrame)))))
    (and (not (equal methodName <span class="string">"&lt;clinit&gt;"</span>))
         (not (equal methodName <span class="string">"&lt;init&gt;"</span>))
         (passesProtectedMethodCheck env methodClassName methodName 
                                     Returntype1 OperandArgList1 target)
         <span class="comment">;; use untranslated types to look up 
</span>         <span class="comment">;; but treat them as int during type checking 
</span>         <span class="comment">;; byte, char, short and  boolean to int
</span>         (validTypeTransition env StackArgList ReturnType curFrame))))


(<span class="keyword">defun</span> <span class="function-name">execute-invokevirtual</span> (<a href="../DJVM/INST/inst.lisp.html">inst</a> env curFrame)
  (<span class="keyword">let*</span> ((CP (arg1 <a href="../DJVM/INST/inst.lisp.html">inst</a>))
         (methodClassName (methodClassNameCP  CP))
         (OperandArgList1  (methodArgListCP CP))
         (OperandArgList  (translate-types OperandArgList1))
         (ReturnType1      (methodReturnTypeCP CP))
         (returnType  (translate-type returnType1))
         (StackArgList (reverse (cons (prefix-class MethodClassName) 
                                      OperandArgList))))
    (mv (TypeTransition env StackArgList ReturnType
                        curFrame)
        (exceptionStackFrame curFrame))))

<span class="comment">;--
</span>(<span class="keyword">defun</span> <span class="function-name">check-ireturn</span> (<a href="../DJVM/INST/inst.lisp.html">inst</a> env curFrame)
  (<span class="keyword">declare</span> (ignore <a href="../DJVM/INST/inst.lisp.html">inst</a>))
  (<span class="keyword">let*</span> ((method (methodEnvironment env))
         (returnType1 (methodReturnType method))
         (returnType  (translate-type returnType1)))
    (and (equal returntype 'int)
         (canPop env curFrame '(int)))))

(<span class="keyword">defun</span> <span class="function-name">execute-ireturn</span> (<a href="../DJVM/INST/inst.lisp.html">inst</a> env curFrame)
  (<span class="keyword">declare</span> (ignore <a href="../DJVM/INST/inst.lisp.html">inst</a> env))
  (mv 'aftergoto 
      (exceptionStackFrame curFrame)))
<span class="comment">;--
</span>(<span class="keyword">defun</span> <span class="function-name">check-istore</span> (<a href="../DJVM/INST/inst.lisp.html">inst</a> env curFrame)
  (<span class="keyword">let</span> ((index (arg1 <a href="../DJVM/INST/inst.lisp.html">inst</a>)))
    (storeIsTypeSafe env index 'int curFrame)))

(<span class="keyword">defun</span> <span class="function-name">execute-istore</span> (<a href="../DJVM/INST/inst.lisp.html">inst</a> env curFrame)
  (<span class="keyword">let</span> ((index (arg1 <a href="../DJVM/INST/inst.lisp.html">inst</a>)))
    (mv (<span class="keyword">do-store</span> env index 'int curFrame)
        (exceptionStackFrame curFrame))))
<span class="comment">;--
</span>
<span class="comment">;---
</span>(<span class="keyword">defun</span> <span class="function-name">check-l2d</span> (<a href="../DJVM/INST/inst.lisp.html">inst</a> env curFrame)
  (<span class="keyword">declare</span> (ignore <a href="../DJVM/INST/inst.lisp.html">inst</a>))
  (validTypeTransition env '(long) 'double curFrame))

(<span class="keyword">defun</span> <span class="function-name">execute-l2d</span> (<a href="../DJVM/INST/inst.lisp.html">inst</a> env curFrame)
  (<span class="keyword">declare</span> (ignore <a href="../DJVM/INST/inst.lisp.html">inst</a>))
  (mv (TypeTransition env '(long) 'double curFrame)
      (exceptionStackFrame curFrame)))
<span class="comment">;--
</span>(<span class="keyword">defun</span> <span class="function-name">check-l2f</span> (<a href="../DJVM/INST/inst.lisp.html">inst</a> env curFrame)
  (<span class="keyword">declare</span> (ignore <a href="../DJVM/INST/inst.lisp.html">inst</a>))
  (validTypeTransition env '(long) 'float curFrame))

(<span class="keyword">defun</span> <span class="function-name">execute-l2f</span> (<a href="../DJVM/INST/inst.lisp.html">inst</a> env curFrame)
  (<span class="keyword">declare</span> (ignore <a href="../DJVM/INST/inst.lisp.html">inst</a>))
  (mv (TypeTransition env '(long) 'float curFrame)
      (exceptionStackFrame curFrame)))
<span class="comment">;--
</span>
(<span class="keyword">defun</span> <span class="function-name">check-l2i</span> (<a href="../DJVM/INST/inst.lisp.html">inst</a> env curFrame)
  (<span class="keyword">declare</span> (ignore <a href="../DJVM/INST/inst.lisp.html">inst</a>))
  (validTypeTransition env '(long) 'int curFrame))

(<span class="keyword">defun</span> <span class="function-name">execute-l2i</span> (<a href="../DJVM/INST/inst.lisp.html">inst</a> env curFrame)
  (<span class="keyword">declare</span> (ignore <a href="../DJVM/INST/inst.lisp.html">inst</a>))
  (mv (TypeTransition env '(long) 'int curFrame)
      (exceptionStackFrame curFrame)))
<span class="comment">;--
</span>(<span class="keyword">defun</span> <span class="function-name">check-l2l</span> (<a href="../DJVM/INST/inst.lisp.html">inst</a> env curFrame)
  (<span class="keyword">declare</span> (ignore <a href="../DJVM/INST/inst.lisp.html">inst</a>))
  (validTypeTransition env '(long) 'long curFrame))

(<span class="keyword">defun</span> <span class="function-name">execute-l2l</span> (<a href="../DJVM/INST/inst.lisp.html">inst</a> env curFrame)
  (<span class="keyword">declare</span> (ignore <a href="../DJVM/INST/inst.lisp.html">inst</a>))
  (mv (TypeTransition env '(long) 'long curFrame)
      (exceptionStackFrame curFrame)))
<span class="comment">;--
</span>
(<span class="keyword">defun</span> <span class="function-name">check-ladd</span> (<a href="../DJVM/INST/inst.lisp.html">inst</a> env curFrame)
  (<span class="keyword">declare</span> (ignore <a href="../DJVM/INST/inst.lisp.html">inst</a>))
  (validTypeTransition env '(long long) 'long curFrame))

(<span class="keyword">defun</span> <span class="function-name">execute-ladd</span> (<a href="../DJVM/INST/inst.lisp.html">inst</a> env curFrame)
  (<span class="keyword">declare</span> (ignore <a href="../DJVM/INST/inst.lisp.html">inst</a>))
  (mv (TypeTransition env '(long long) 'long curFrame)
      (exceptionStackFrame curFrame)))
<span class="comment">;--
</span>(<span class="keyword">defun</span> <span class="function-name">check-laload</span> (<a href="../DJVM/INST/inst.lisp.html">inst</a> env curFrame)
  (<span class="keyword">declare</span> (ignore <a href="../DJVM/INST/inst.lisp.html">inst</a>))
  (validTypeTransition env '(int (array long)) 'long curFrame))

(<span class="keyword">defun</span> <span class="function-name">execute-laload</span> (<a href="../DJVM/INST/inst.lisp.html">inst</a> env curFrame)
  (<span class="keyword">declare</span> (ignore <a href="../DJVM/INST/inst.lisp.html">inst</a>))
  (mv (TypeTransition env '(int (array long)) 'long curFrame)
      (exceptionStackFrame curFrame)))
<span class="comment">;--
</span>(<span class="keyword">defun</span> <span class="function-name">check-lastore</span> (<a href="../DJVM/INST/inst.lisp.html">inst</a> env curFrame)
  (<span class="keyword">declare</span> (ignore <a href="../DJVM/INST/inst.lisp.html">inst</a>))
  (canPop env curFrame '(long int (array long))))

(<span class="keyword">defun</span> <span class="function-name">execute-lastore</span> (<a href="../DJVM/INST/inst.lisp.html">inst</a> env curFrame)
  (<span class="keyword">declare</span> (ignore <a href="../DJVM/INST/inst.lisp.html">inst</a>))
  (mv (TypeTransition env '(long int (array long)) 'void curFrame)
      (exceptionStackFrame curFrame)))
<span class="comment">;--
</span>(<span class="keyword">defun</span> <span class="function-name">check-lcmp</span> (<a href="../DJVM/INST/inst.lisp.html">inst</a> env curFrame)
  (<span class="keyword">declare</span> (ignore <a href="../DJVM/INST/inst.lisp.html">inst</a>))
  (validTypeTransition env '(long long) 'int curFrame))

(<span class="keyword">defun</span> <span class="function-name">execute-lcmp</span> (<a href="../DJVM/INST/inst.lisp.html">inst</a> env curFrame)
  (<span class="keyword">declare</span> (ignore <a href="../DJVM/INST/inst.lisp.html">inst</a>))
  (mv (TypeTransition env '(long long) 'int curFrame)
      (exceptionStackFrame curFrame)))
<span class="comment">;--
</span>(<span class="keyword">defun</span> <span class="function-name">check-lconst_0</span> (<a href="../DJVM/INST/inst.lisp.html">inst</a> env curFrame)
  (<span class="keyword">declare</span> (ignore <a href="../DJVM/INST/inst.lisp.html">inst</a>))
  (validTypeTransition env nil 'long curFrame))

(<span class="keyword">defun</span> <span class="function-name">execute-lconst_0</span> (<a href="../DJVM/INST/inst.lisp.html">inst</a> env curFrame)
  (<span class="keyword">declare</span> (ignore <a href="../DJVM/INST/inst.lisp.html">inst</a>))
  (mv (TypeTransition env nil 'long curFrame)
      (exceptionStackFrame curFrame)))

<span class="comment">;---
; ldc constant pool entry ( &lt;tag&gt; &lt;value&gt; ) 
; shall we just assume this already resolved 
;
; -- either by jvm2acl2 translator or by the top level routine that do
; some instruction preprocessing routine. 
; ldc, invokevirtual, branch instructions all need this kind of preprocessing.
;---
</span>
(<span class="keyword">defun</span> <span class="function-name">tagCP</span> (CP)
  (car CP))

(<span class="keyword">defun</span> <span class="function-name">typeCP</span> (CP)
  (cadr CP))

(<span class="keyword">defun</span> <span class="function-name">check-ldc</span> (<a href="../DJVM/INST/inst.lisp.html">inst</a> env curFrame)
  (<span class="keyword">let*</span> ((cp (arg1 <a href="../DJVM/INST/inst.lisp.html">inst</a>))
         (tag (tagCP CP))
         (type (typeCP CP)))
    (and (mem (list tag type)
              '((int int)
                (float float)
                (string (class <span class="string">"java.lang.String"</span>))))
         (validTypeTransition env nil type curFrame))))

(<span class="keyword">defun</span> <span class="function-name">execute-ldc</span> (<a href="../DJVM/INST/inst.lisp.html">inst</a> env curFrame)
  (<span class="keyword">let*</span> ((cp (arg1 <a href="../DJVM/INST/inst.lisp.html">inst</a>))
         (type (typeCP CP)))
    (mv (TypeTransition env nil type curFrame)
        (exceptionStackFrame curFrame))))
<span class="comment">;-- 
</span>(<span class="keyword">defun</span> <span class="function-name">check-ldc2_w</span> (<a href="../DJVM/INST/inst.lisp.html">inst</a> env curFrame)
  (<span class="keyword">let*</span> ((cp (arg1 <a href="../DJVM/INST/inst.lisp.html">inst</a>))
         (tag (tagCP CP)))
    (and (mem tag
              '(long double))
         (validTypeTransition env nil tag curFrame))))

(<span class="keyword">defun</span> <span class="function-name">execute-ldc2_w</span> (<a href="../DJVM/INST/inst.lisp.html">inst</a> env curFrame)
  (<span class="keyword">let*</span> ((cp (arg1 <a href="../DJVM/INST/inst.lisp.html">inst</a>))
         (tag (tagCP cp)))
    (mv (TypeTransition env nil tag curFrame)
        (exceptionStackFrame curFrame))))

<span class="comment">;;
;; need properties about ldc2_w is not changed during execution.
;;
</span>
<span class="comment">;--
</span>(<span class="keyword">defun</span> <span class="function-name">check-lload</span> (<a href="../DJVM/INST/inst.lisp.html">inst</a> env curFrame)
  (<span class="keyword">let</span> ((index (arg1 <a href="../DJVM/INST/inst.lisp.html">inst</a>)))
    (loadIsTypeSafe env index 'long curFrame)))


(<span class="keyword">defun</span> <span class="function-name">execute-lload</span> (<a href="../DJVM/INST/inst.lisp.html">inst</a> env curFrame)
  (<span class="keyword">let*</span> ((index (arg1 <a href="../DJVM/INST/inst.lisp.html">inst</a>)))
    (mv (<span class="keyword">do-load</span> env index 'long curFrame)
        (exceptionStackFrame curFrame))))
<span class="comment">;--
</span>(<span class="keyword">defun</span> <span class="function-name">check-lneg</span> (<a href="../DJVM/INST/inst.lisp.html">inst</a> env curFrame)
  (<span class="keyword">declare</span> (ignore <a href="../DJVM/INST/inst.lisp.html">inst</a>))
  (validTypeTransition env '(long) 'long curFrame))

(<span class="keyword">defun</span> <span class="function-name">execute-lneg</span> (<a href="../DJVM/INST/inst.lisp.html">inst</a> env curFrame)
  (<span class="keyword">declare</span> (ignore <a href="../DJVM/INST/inst.lisp.html">inst</a>))
  (mv (TypeTransition env '(long) 'long curFrame)
      (exceptionStackFrame curFrame)))
<span class="comment">;-- 
; rely on some preprocessing
</span>
(<span class="keyword">defun</span> <span class="function-name">ordered</span> (lst)
  (<span class="keyword">if</span> (endp lst)
      t
    (<span class="keyword">if</span> (endp (cdr lst))
        t
      (and (&lt;= (car lst) (cadr lst))
           (ordered (cdr lst))))))
        
(<span class="keyword">defun</span> <span class="function-name">checklist-targetIsTypeSafe</span> (env frame targets)
  (<span class="keyword">if</span> (endp targets)
      t
    (and (targetIsTypeSafe env frame (car targets))
         (checklist-targetIsTypeSafe env frame (cdr targets)))))

(<span class="keyword">defun</span> <span class="function-name">make-inst2</span> (offset opcode arg1 arg2)
  (list offset (list opcode arg1 arg2)))

(<span class="keyword">defun</span> <span class="function-name">lksdefault</span> (lksinfo)
  (nth 1 lksinfo))

(<span class="keyword">defun</span> <span class="function-name">paircount</span> (lksinfo)
  (nth 2 lksinfo))

(<span class="keyword">defun</span> <span class="function-name">pairs</span> (lksinfo)
  (nth 3 lksinfo))


(<span class="keyword">defun</span> <span class="function-name">collect-keys</span> (npairs)
  (<span class="keyword">if</span> (endp npairs)
      nil
    (cons (caar npairs) (collect-keys (cdr npairs)))))

(<span class="keyword">defun</span> <span class="function-name">collect-targets</span> (npairs)
  (<span class="keyword">if</span> (endp npairs)
      nil
    (cons (cdar npairs) (collect-targets (cdr npairs)))))


(<span class="keyword">defun</span> <span class="function-name"><a href="../DJVM/INST/inst.lisp.html">inst</a>-trans-lookupswitch</span> (<a href="../DJVM/INST/inst.lisp.html">inst</a>) 
  (<span class="keyword">let*</span> ((lookupswitchinfo (arg1 <a href="../DJVM/INST/inst.lisp.html">inst</a>))
         (default     (lksdefault lookupswitchinfo))
         (npairs      (pairs     lookupswitchinfo))
         (keys        (collect-keys npairs))
         (targets     (collect-targets npairs)))
    (make-<a href="../DJVM/INST/inst.lisp.html">inst</a>2 (<a href="../DJVM/INST/inst.lisp.html">inst</a>rOffset <a href="../DJVM/INST/inst.lisp.html">inst</a>)
                (op-code <a href="../DJVM/INST/inst.lisp.html">inst</a>)
                (cons default targets)
                keys)))



(<span class="keyword">defun</span> <span class="function-name">check-lookupswitch</span> (<a href="../DJVM/INST/inst.lisp.html">inst</a> env curFrame)
  (<span class="keyword">let*</span> ((Targets (arg1 <a href="../DJVM/INST/inst.lisp.html">inst</a>))
         (Keys    (arg2 <a href="../DJVM/INST/inst.lisp.html">inst</a>))
         (BranchStackFrame (popMatchingList '(int) curFrame)))
    (and (ordered Keys)
         (canPop env curFrame '(int))
         (checklist-targetIsTypeSafe env branchStackFrame targets))))


(<span class="keyword">defun</span> <span class="function-name">execute-lookupswitch</span> (<a href="../DJVM/INST/inst.lisp.html">inst</a> env curFrame)
  (<span class="keyword">declare</span> (ignore <a href="../DJVM/INST/inst.lisp.html">inst</a> env))
  (mv 'aftergoto (exceptionStackFrame curFrame)))
<span class="comment">;--
</span>
(<span class="keyword">defun</span> <span class="function-name">check-lreturn</span> (<a href="../DJVM/INST/inst.lisp.html">inst</a> env curFrame)
  (<span class="keyword">declare</span> (ignore <a href="../DJVM/INST/inst.lisp.html">inst</a>))
  (<span class="keyword">let*</span> ((method (methodEnvironment env))
         (returnType (methodReturnType method)))
    (and (equal returnType 'long)
         (canPop env curFrame '(long)))))

(<span class="keyword">defun</span> <span class="function-name">execute-lreturn</span> (<a href="../DJVM/INST/inst.lisp.html">inst</a> env curFrame)
  (<span class="keyword">declare</span> (ignore <a href="../DJVM/INST/inst.lisp.html">inst</a> env))
  (mv 'aftergoto 
      (exceptionStackFrame curFrame)))
<span class="comment">;--
</span>(<span class="keyword">defun</span> <span class="function-name">check-lshl</span> (<a href="../DJVM/INST/inst.lisp.html">inst</a> env curFrame)
  (<span class="keyword">declare</span> (ignore <a href="../DJVM/INST/inst.lisp.html">inst</a>))
  (validTypeTransition env '(int long) 'long curFrame))

(<span class="keyword">defun</span> <span class="function-name">execute-lshl</span> (<a href="../DJVM/INST/inst.lisp.html">inst</a> env curFrame)
  (<span class="keyword">declare</span> (ignore <a href="../DJVM/INST/inst.lisp.html">inst</a>))
  (mv (TypeTransition env '(int long) 'long curFrame)
      (exceptionStackFrame curFrame)))
<span class="comment">;--
</span>(<span class="keyword">defun</span> <span class="function-name">check-lstore</span> (<a href="../DJVM/INST/inst.lisp.html">inst</a> env curFrame)
  (<span class="keyword">let</span> ((index (arg1 <a href="../DJVM/INST/inst.lisp.html">inst</a>)))
    (storeIsTypeSafe env index 'long curFrame)))

(<span class="keyword">defun</span> <span class="function-name">execute-lstore</span> (<a href="../DJVM/INST/inst.lisp.html">inst</a> env curFrame)
  (<span class="keyword">let</span> ((index (arg1 <a href="../DJVM/INST/inst.lisp.html">inst</a>)))
    (mv (<span class="keyword">do-store</span> env index 'long curFrame)
        (exceptionStackFrame curFrame))))
<span class="comment">;--
</span>(<span class="keyword">defun</span> <span class="function-name">check-monitorenter</span> (<a href="../DJVM/INST/inst.lisp.html">inst</a> env curFrame)
  (<span class="keyword">declare</span> (ignore <a href="../DJVM/INST/inst.lisp.html">inst</a>))
  (canPop env curFrame '(reference)))

(<span class="keyword">defun</span> <span class="function-name">execute-monitorenter</span> (<a href="../DJVM/INST/inst.lisp.html">inst</a> env curFrame)
  (<span class="keyword">declare</span> (ignore <a href="../DJVM/INST/inst.lisp.html">inst</a> env))
  (mv (PopMatchingList '(reference) curFrame)
      (exceptionStackFrame curFrame)))
<span class="comment">;--
</span>
(<span class="keyword">defun</span> <span class="function-name">classDimensionCP</span> (class)
  (<span class="keyword">let</span> ((X (component-type class)))
    (<span class="keyword">cond</span> ((isClassType class) 0)
          ((isArrayType class)
           (+ 1 (classDimensionCP X)))
          (t 0))))
      
(<span class="keyword">defun</span> <span class="function-name">intlist</span> (n)
  (<span class="keyword">if</span> (zp n)
      nil
    (cons 'int (intlist (- n 1)))))

(<span class="keyword">defun</span> <span class="function-name">check-multianewarray</span> (<a href="../DJVM/INST/inst.lisp.html">inst</a> env curFrame)
  (<span class="keyword">let*</span> ((CP (arg1 <a href="../DJVM/INST/inst.lisp.html">inst</a>))
         (Dimension (classDimensionCP CP))
         (Dim (arg2 <a href="../DJVM/INST/inst.lisp.html">inst</a>))
         (IntList (intlist Dim)))
    (and (isArrayType CP)
         (&lt;= Dim Dimension)
         (&lt; 0 Dim)
         (validTypeTransition env IntList CP curFrame))))

(<span class="keyword">defun</span> <span class="function-name">execute-multianewarray</span> (<a href="../DJVM/INST/inst.lisp.html">inst</a> env curFrame)
  (<span class="keyword">let*</span> ((CP (arg1 <a href="../DJVM/INST/inst.lisp.html">inst</a>))
         (Dim (arg2 <a href="../DJVM/INST/inst.lisp.html">inst</a>))
         (IntList (intlist Dim)))
    (mv (TypeTransition env IntList CP curFrame)
        (exceptionStackFrame curFrame))))
<span class="comment">;--
</span>

(<span class="keyword">defun</span> <span class="function-name">check-new</span> (<a href="../DJVM/INST/inst.lisp.html">inst</a> env curFrame)
  (<span class="keyword">let*</span> ((CP (arg1 <a href="../DJVM/INST/inst.lisp.html">inst</a>))
         (OperandStack (frameStack curFrame))
         (Locals       (frameLocals curFrame))
         (Flags        (frameFlags  curFrame))
         (offset (<a href="../DJVM/INST/inst.lisp.html">inst</a>rOffset <a href="../DJVM/INST/inst.lisp.html">inst</a>))
         (newItem (list 'uninitialized offset)))
    (and (isClassType CP)
         (not (mem newItem OperandStack)) 
<span class="comment">;;
;;         make sure we are not coming to this location, 
;;         without initialize the previous object that was created. 
;;
</span>         (<span class="keyword">let</span> ((NewLocals (replacex NewItem 'topx Locals)))
<span class="comment">;;
;;  For safety, we clean out the NewItem that exists in LOCALS
;; ?? Why? Because we could have some old reference lying around? 
;;  We could have some uninitialized pointers lying around? Replacing them with
;;  'topx we prevent the future use of those uninitialized pointers. 
;; 
;;  We can eventually prove that defensive machine will never use an
;;  uninitialized pointer
;;
</span>           (validTypeTransition env nil newItem 
                                (make-sig-frame newLocals 
                                                OperandStack
                                                Flags))))))


(<span class="keyword">defun</span> <span class="function-name">execute-new</span> (<a href="../DJVM/INST/inst.lisp.html">inst</a> env curFrame)
  (<span class="keyword">let*</span> ((OperandStack (frameStack curFrame))
         (Locals       (frameLocals curFrame))
         (Flags        (frameFlags  curFrame))
         (offset (<a href="../DJVM/INST/inst.lisp.html">inst</a>rOffset <a href="../DJVM/INST/inst.lisp.html">inst</a>))
         (newItem (list 'uninitialized offset))
         (NewLocals (replacex NewItem 'topx Locals)))
    <span class="comment">;; make sure we can store such a reference somewhere in unoccupied slot but
</span>    <span class="comment">;; nowhere else.
</span>    (mv (TypeTransition env nil newItem 
                        (make-sig-frame newLocals 
                                        OperandStack
                                        Flags))
        (exceptionStackFrame curFrame))))
<span class="comment">;--
</span>(<span class="keyword">defun</span> <span class="function-name">check-newarray</span> (<a href="../DJVM/INST/inst.lisp.html">inst</a> env curFrame)
  (<span class="keyword">let</span> ((ElementType (arg1 <a href="../DJVM/INST/inst.lisp.html">inst</a>)))
    (validTypeTransition env '(int) (list 'array ElementType)
                         curFrame)))

(<span class="keyword">defun</span> <span class="function-name">execute-newarray</span> (<a href="../DJVM/INST/inst.lisp.html">inst</a> env curFrame)
  (<span class="keyword">let</span> ((ElementType (arg1 <a href="../DJVM/INST/inst.lisp.html">inst</a>)))
    (mv (TypeTransition env '(int) (list 'array ElementType)
                        curFrame)
        (exceptionStackFrame curFrame))))
<span class="comment">;--
</span>
(<span class="keyword">defun</span> <span class="function-name">check-nop</span> (<a href="../DJVM/INST/inst.lisp.html">inst</a> env curFrame)
  (<span class="keyword">declare</span> (ignore <a href="../DJVM/INST/inst.lisp.html">inst</a> env curFrame))
  t)

(<span class="keyword">defun</span> <span class="function-name">execute-nop</span> (<a href="../DJVM/INST/inst.lisp.html">inst</a> env curFrame)
  (<span class="keyword">declare</span> (ignore <a href="../DJVM/INST/inst.lisp.html">inst</a> env))
  (mv curFrame 
      (exceptionStackFrame curFrame)))
<span class="comment">;--
</span>(<span class="keyword">defun</span> <span class="function-name">check-pop</span> (<a href="../DJVM/INST/inst.lisp.html">inst</a> env curFrame)
  (<span class="keyword">declare</span> (ignore <a href="../DJVM/INST/inst.lisp.html">inst</a> env))
  (<span class="keyword">let*</span> ((Stack  (frameStack  curFrame)))
    (and (nth1OperandStackExist 1 curFrame)
         (isTopCategory1 stack))))

(<span class="keyword">defun</span> <span class="function-name">execute-pop</span> (<a href="../DJVM/INST/inst.lisp.html">inst</a> env curFrame)
  (<span class="keyword">declare</span> (ignore <a href="../DJVM/INST/inst.lisp.html">inst</a>  env))
  (<span class="keyword">let*</span> ((Locals (frameLocals curFrame))
         (Stack  (frameStack  curFrame))
         (Flags  (frameFlags  curFrame))
         (Rest   (popCategory1 Stack)))
    (mv (make-sig-frame Locals
                        Rest
                        Flags)
        (exceptionStackFrame curFrame))))
<span class="comment">;--
</span>(<span class="keyword">defun</span> <span class="function-name">is-pop2-form1</span> (<a href="../DJVM/INST/inst.lisp.html">inst</a> env curFrame)
  (<span class="keyword">declare</span> (ignore <a href="../DJVM/INST/inst.lisp.html">inst</a> env))
  (and (isTopCategory1 (frameStack curFrame))
       (isTopCategory1 (popCategory1 (frameStack curFrame)))))

(<span class="keyword">defun</span> <span class="function-name">do-pop2-form1</span> (<a href="../DJVM/INST/inst.lisp.html">inst</a> env curFrame)
  (<span class="keyword">declare</span> (ignore <a href="../DJVM/INST/inst.lisp.html">inst</a> env))
  (mv (make-sig-frame 
       (framelocals curFrame)
       (popCategory1 (popCategory1 (frameStack curFrame)))
       (frameFlags curFrame))
      (exceptionStackFrame curFrame)))

(<span class="keyword">defun</span> <span class="function-name">is-pop2-form2</span> (<a href="../DJVM/INST/inst.lisp.html">inst</a> env curFrame)
  (<span class="keyword">declare</span> (ignore <a href="../DJVM/INST/inst.lisp.html">inst</a> env))
  (isTopCategory2 (frameStack curFrame)))

(<span class="keyword">defun</span> <span class="function-name">do-pop2-form2</span> (<a href="../DJVM/INST/inst.lisp.html">inst</a> env curFrame)
  (<span class="keyword">declare</span> (ignore <a href="../DJVM/INST/inst.lisp.html">inst</a> env))
  (mv (make-sig-frame 
       (framelocals curFrame)
       (popCategory2 (frameStack curFrame))
       (frameFlags curFrame))
      (exceptionStackFrame curFrame)))

(<span class="keyword">defun</span> <span class="function-name">check-pop2</span> (<a href="../DJVM/INST/inst.lisp.html">inst</a> env curFrame)
  (and (nth1operandStackExist 2 curFrame)
       (or (is-pop2-form1 <a href="../DJVM/INST/inst.lisp.html">inst</a> env curFrame)
           (is-pop2-form2 <a href="../DJVM/INST/inst.lisp.html">inst</a> env curFrame))))

(<span class="keyword">defun</span> <span class="function-name">execute-pop2</span> (<a href="../DJVM/INST/inst.lisp.html">inst</a> env curFrame)
  (<span class="keyword">cond</span> ((is-pop2-form1 <a href="../DJVM/INST/inst.lisp.html">inst</a> env curFrame)
         (<span class="keyword">do-pop2-form1</span> <a href="../DJVM/INST/inst.lisp.html">inst</a> env curFrame))
        ((is-pop2-form2 <a href="../DJVM/INST/inst.lisp.html">inst</a> env curFrame)
         (<span class="keyword">do-pop2-form2</span> <a href="../DJVM/INST/inst.lisp.html">inst</a> env curFrame))
        (t (mv nil nil))))
<span class="comment">;--
; assume the field is well formed.
</span>(<span class="keyword">defun</span> <span class="function-name">check-putfield</span> (<a href="../DJVM/INST/inst.lisp.html">inst</a> env curFrame)
  (<span class="keyword">let*</span> ((CP (arg1 <a href="../DJVM/INST/inst.lisp.html">inst</a>))
         (fieldClassName (fieldClassNameCP cp))
         (fieldName      (fieldNameCP cp))
         (fieldType1      (fieldTypeCP  cp))
         (fieldType       (translate-type fieldType1))
         (target (top (popMatchingType fieldType (frameStack curFrame)))))
    (and (passesProtectedFieldCheck env fieldClassName fieldName fieldType target)
         (canPop  env curFrame (list fieldtype (prefix-class
                                                     fieldClassName))))))

(<span class="keyword">defun</span> <span class="function-name">execute-putfield</span> (<a href="../DJVM/INST/inst.lisp.html">inst</a> env curFrame)
  (<span class="keyword">declare</span> (ignore env))
  (<span class="keyword">let*</span> ((CP (arg1 <a href="../DJVM/INST/inst.lisp.html">inst</a>))
         (fieldClassName  (fieldClassNameCP cp))
         (fieldType1      (fieldTypeCP  cp))
         (fieldType       (translate-type fieldType1)))
    (mv (PopMatchingList (list fieldtype (prefix-class
                                               fieldClassName))
                         curFrame)
        (exceptionStackFrame curFrame))))
<span class="comment">;--
</span>(<span class="keyword">defun</span> <span class="function-name">check-putstatic</span> (<a href="../DJVM/INST/inst.lisp.html">inst</a> env curFrame)
  (<span class="keyword">let*</span> ((CP (arg1 <a href="../DJVM/INST/inst.lisp.html">inst</a>))
         (fieldType1      (fieldTypeCP  cp))
         (fieldType       (translate-type fieldType1)))
    (canPop  env curFrame (list fieldtype))))

(<span class="keyword">defun</span> <span class="function-name">execute-putstatic</span> (<a href="../DJVM/INST/inst.lisp.html">inst</a> env curFrame)
  (<span class="keyword">declare</span> (ignore env))
  (<span class="keyword">let*</span> ((CP (arg1 <a href="../DJVM/INST/inst.lisp.html">inst</a>))
         (fieldType1      (fieldTypeCP  cp))
         (fieldType       (translate-type fieldType1)))
    (mv (PopMatchingList (list fieldtype)
                         curFrame)
        (exceptionStackFrame curFrame))))
<span class="comment">;--
</span>(<span class="keyword">defun</span> <span class="function-name">check-return</span> (<a href="../DJVM/INST/inst.lisp.html">inst</a> env curFrame)
  (<span class="keyword">declare</span> (ignore <a href="../DJVM/INST/inst.lisp.html">inst</a>))
  (<span class="keyword">let*</span> ((curMethod (methodEnvironment env))
         (Flags (frameFlags curFrame))
         (returntype (methodReturnType curMethod)))
    (and (equal returntype 'void)
         (not (mem 'flagThisUninit Flags)))))

(<span class="keyword">defun</span> <span class="function-name">execute-return</span> (<a href="../DJVM/INST/inst.lisp.html">inst</a> env curFrame)
  (<span class="keyword">declare</span> (ignore <a href="../DJVM/INST/inst.lisp.html">inst</a> env))
  (mv 'aftergoto
      (exceptionStackFrame curFrame)))
<span class="comment">;--
</span>(<span class="keyword">defun</span> <span class="function-name">check-saload</span> (<a href="../DJVM/INST/inst.lisp.html">inst</a> env curFrame)
  (<span class="keyword">declare</span> (ignore <a href="../DJVM/INST/inst.lisp.html">inst</a>))
  (validTypeTransition env '(int (array short)) 'int curFrame))

(<span class="keyword">defun</span> <span class="function-name">execute-saload</span> (<a href="../DJVM/INST/inst.lisp.html">inst</a> env curFrame)
  (<span class="keyword">declare</span> (ignore <a href="../DJVM/INST/inst.lisp.html">inst</a>))
  (mv (TypeTransition env '(int (array short)) 'int curFrame)
      (exceptionStackFrame curFrame)))
<span class="comment">;--
</span>(<span class="keyword">defun</span> <span class="function-name">check-sastore</span> (<a href="../DJVM/INST/inst.lisp.html">inst</a> env curFrame)
  (<span class="keyword">declare</span> (ignore <a href="../DJVM/INST/inst.lisp.html">inst</a>))
  (canPop env curFrame '(int int (array short))))

(<span class="keyword">defun</span> <span class="function-name">execute-sastore</span> (<a href="../DJVM/INST/inst.lisp.html">inst</a> env curFrame)
  (<span class="keyword">declare</span> (ignore <a href="../DJVM/INST/inst.lisp.html">inst</a>))
  (mv (TypeTransition env '(int int (array short)) 'void curFrame)
      (exceptionStackFrame curFrame)))
<span class="comment">;--
</span>(<span class="keyword">defun</span> <span class="function-name">check-sipush</span> (<a href="../DJVM/INST/inst.lisp.html">inst</a> env curFrame)
  (<span class="keyword">declare</span> (ignore <a href="../DJVM/INST/inst.lisp.html">inst</a>))
  (validTypeTransition env nil 'int curFrame))

(<span class="keyword">defun</span> <span class="function-name">execute-sipush</span> (<a href="../DJVM/INST/inst.lisp.html">inst</a> env curFrame)
  (<span class="keyword">declare</span> (ignore <a href="../DJVM/INST/inst.lisp.html">inst</a>))
  (mv (TypeTransition env nil 'int curFrame)
      (exceptionStackFrame curFrame)))
<span class="comment">;--
</span>(<span class="keyword">defun</span> <span class="function-name">check-swap</span> (<a href="../DJVM/INST/inst.lisp.html">inst</a> env curFrame)
  (<span class="keyword">declare</span> (ignore <a href="../DJVM/INST/inst.lisp.html">inst</a> env))
  (<span class="keyword">let</span> ((Stack (frameStack curFrame)))
    (and (nth1operandStackExist 2 curFrame)
         (equal (sizeOf (top stack)) 1)
         (equal (sizeOf (top (pop stack))) 1))))

(<span class="keyword">defun</span> <span class="function-name">execute-swap</span> (<a href="../DJVM/INST/inst.lisp.html">inst</a> env curFrame)
  (<span class="keyword">declare</span> (ignore <a href="../DJVM/INST/inst.lisp.html">inst</a> env))
  (<span class="keyword">let</span> ((Stack (frameStack curFrame)))
    (mv (make-sig-frame 
         (frameLocals curFrame)
         (push (top (pop stack))
               (push (top stack)
                     (pop (pop stack))))
         (frameFlags curFrame))
        (exceptionStackFrame curFrame))))
<span class="comment">;--
</span>
(<span class="keyword">defun</span> <span class="function-name">tbldefault</span> (tblinfo)
  (nth 1 tblinfo))

(<span class="keyword">defun</span> <span class="function-name">tblrange</span> (tblinfo)
  (nth 2 tblinfo))

(<span class="keyword">defun</span> <span class="function-name">tbltargets</span> (tblinfo)
  (nth 3 tblinfo))


(<span class="keyword">defun</span> <span class="function-name">gen-list</span> (low count)
  (<span class="keyword">if</span> (zp count)
      nil
    (cons low (gen-list (+ 1 low) (- count 1)))))


(<span class="keyword">defun</span> <span class="function-name">gen-keys</span> (range)
  (gen-list (car range) (- (+ 1 (cdr range)) (car range))))


(<span class="keyword">defun</span> <span class="function-name"><a href="../DJVM/INST/inst.lisp.html">inst</a>-trans-tableswitch</span> (<a href="../DJVM/INST/inst.lisp.html">inst</a>)
  (<span class="keyword">let*</span> ((tblinfo (arg1 <a href="../DJVM/INST/inst.lisp.html">inst</a>))
         (default (tbldefault tblinfo))
         (range   (tblrange tblinfo))
         (keys    (gen-keys range))
         (targets  (tbltargets tblinfo)))
    (make-<a href="../DJVM/INST/inst.lisp.html">inst</a>2 (<a href="../DJVM/INST/inst.lisp.html">inst</a>rOffset <a href="../DJVM/INST/inst.lisp.html">inst</a>)
                (op-code <a href="../DJVM/INST/inst.lisp.html">inst</a>)
                (cons default targets)
                keys)))





(<span class="keyword">defun</span> <span class="function-name">check-tableswitch</span> (<a href="../DJVM/INST/inst.lisp.html">inst</a> env curFrame)
  (<span class="keyword">let*</span> ((Targets (arg1 <a href="../DJVM/INST/inst.lisp.html">inst</a>))
         (Keys    (arg2 <a href="../DJVM/INST/inst.lisp.html">inst</a>))
         (BranchStackFrame (popMatchingList '(int) curFrame)))
    (and (ordered Keys)
         (canPop env curFrame '(int))
         (checklist-targetIsTypeSafe env branchStackFrame Targets))))

(<span class="keyword">defun</span> <span class="function-name">execute-tableswitch</span> (<a href="../DJVM/INST/inst.lisp.html">inst</a> env curFrame)
  (<span class="keyword">declare</span> (ignore <a href="../DJVM/INST/inst.lisp.html">inst</a> env))
  (mv 'aftergoto (exceptionStackFrame curFrame)))



(<span class="keyword">defun</span> <span class="function-name">cpEntry</span> (index cpool)
  (nth index cpool))

(<span class="keyword">defun</span> <span class="function-name">makeTagCP</span> (tag type)
  (list tag type))

(<span class="keyword">defun</span> <span class="function-name"><a href="../DJVM/INST/inst.lisp.html">inst</a>-resolve-cp</span> (<a href="../DJVM/INST/inst.lisp.html">inst</a> env) 
  (<span class="keyword">let</span> ((cpool (classConstantPool (classEnvironment env))))
    (<span class="keyword">cond</span> ((or (equal (op-code <a href="../DJVM/INST/inst.lisp.html">inst</a>) 'ldc)
               (equal (op-code <a href="../DJVM/INST/inst.lisp.html">inst</a>) 'ldc2_w))
           (<span class="keyword">let*</span> ((index (arg1 <a href="../DJVM/INST/inst.lisp.html">inst</a>))
                  (entry (cpEntry index cpool))
                  (tag   (car entry)))
             (<span class="keyword">cond</span> ((equal tag 'String) 
                    (make-<a href="../DJVM/INST/inst.lisp.html">inst</a>1 (<a href="../DJVM/INST/inst.lisp.html">inst</a>rOffset <a href="../DJVM/INST/inst.lisp.html">inst</a>)
                                (op-code <a href="../DJVM/INST/inst.lisp.html">inst</a>)
                                (makeTagCP tag '(class <span class="string">"java.lang.String"</span>))))
                   ((equal tag 'Long)
                    (make-<a href="../DJVM/INST/inst.lisp.html">inst</a>1 (<a href="../DJVM/INST/inst.lisp.html">inst</a>rOffset <a href="../DJVM/INST/inst.lisp.html">inst</a>)
                                (op-code <a href="../DJVM/INST/inst.lisp.html">inst</a>)
                                (makeTagCP tag 'LONG)))
                   ((equal tag 'FLOAT)
                    (make-<a href="../DJVM/INST/inst.lisp.html">inst</a>1 (<a href="../DJVM/INST/inst.lisp.html">inst</a>rOffset <a href="../DJVM/INST/inst.lisp.html">inst</a>)
                                (op-code <a href="../DJVM/INST/inst.lisp.html">inst</a>)
                                (makeTagCP tag 'FLOAT)))
                   ((equal tag 'DOUBLE)
                    (make-<a href="../DJVM/INST/inst.lisp.html">inst</a>1 (<a href="../DJVM/INST/inst.lisp.html">inst</a>rOffset <a href="../DJVM/INST/inst.lisp.html">inst</a>)
                                (op-code <a href="../DJVM/INST/inst.lisp.html">inst</a>)
                                (makeTagCP tag 'DOUBLE)))
                   ((equal tag 'Int)
                    (make-<a href="../DJVM/INST/inst.lisp.html">inst</a>1 (<a href="../DJVM/INST/inst.lisp.html">inst</a>rOffset <a href="../DJVM/INST/inst.lisp.html">inst</a>)
                                (op-code <a href="../DJVM/INST/inst.lisp.html">inst</a>)
                                (makeTagCP tag 'INT)))
                   (t nil))))
          (t nil))))



(<span class="keyword">defun</span> <span class="function-name">instructionIsTypeSafe</span> (instr env cur)<span class="comment">;; *9*
</span>  (<span class="keyword">let*</span> ((<a href="../DJVM/INST/inst.lisp.html">inst</a> (<a href="../DJVM/INST/inst.lisp.html">inst</a>ructionHasEquivalentTypeRule <a href="../DJVM/INST/inst.lisp.html">inst</a>r))
         (op   (op-code <a href="../DJVM/INST/inst.lisp.html">inst</a>)))
    (<span class="keyword">cond</span> ((equal op 'aaload)      (check-aaload  <a href="../DJVM/INST/inst.lisp.html">inst</a> env cur))
          ((equal op 'aastore)     (check-aastore <a href="../DJVM/INST/inst.lisp.html">inst</a> env cur))
          ((equal op 'aconst_null) (check-aconst_null   <a href="../DJVM/INST/inst.lisp.html">inst</a> env cur))  
          ((equal op 'aload)       (check-aload   <a href="../DJVM/INST/inst.lisp.html">inst</a> env cur))
          ((equal op 'anewarray)   (check-anewarray   <a href="../DJVM/INST/inst.lisp.html">inst</a> env cur))  
          ((equal op 'areturn)     (check-areturn <a href="../DJVM/INST/inst.lisp.html">inst</a> env cur))
          ((equal op 'arraylength) (check-arraylength   <a href="../DJVM/INST/inst.lisp.html">inst</a> env cur))  
          ((equal op 'astore)      (check-astore <a href="../DJVM/INST/inst.lisp.html">inst</a> env cur))
          ((equal op 'athrow)      (check-athrow   <a href="../DJVM/INST/inst.lisp.html">inst</a> env cur))  
          ((equal op 'baload)      (check-baload <a href="../DJVM/INST/inst.lisp.html">inst</a> env cur))
          ((equal op 'bastore)     (check-bastore   <a href="../DJVM/INST/inst.lisp.html">inst</a> env cur))  
          ((equal op 'caload)      (check-caload <a href="../DJVM/INST/inst.lisp.html">inst</a> env cur))
          ((equal op 'castore)     (check-castore  <a href="../DJVM/INST/inst.lisp.html">inst</a> env cur))  
          ((equal op 'checkcast)   (check-checkcast <a href="../DJVM/INST/inst.lisp.html">inst</a> env cur))
          ((equal op 'd2f)         (check-d2f   <a href="../DJVM/INST/inst.lisp.html">inst</a> env cur))  
          ((equal op 'd2i)         (check-d2i <a href="../DJVM/INST/inst.lisp.html">inst</a> env cur))
          ((equal op 'd2l)         (check-d2l   <a href="../DJVM/INST/inst.lisp.html">inst</a> env cur))  
          ((equal op 'dadd)        (check-dadd <a href="../DJVM/INST/inst.lisp.html">inst</a> env cur))
          ((equal op 'daload)      (check-daload   <a href="../DJVM/INST/inst.lisp.html">inst</a> env cur))  
          ((equal op 'dastore)     (check-dastore <a href="../DJVM/INST/inst.lisp.html">inst</a> env cur))
          ((equal op 'dcmpg)       (check-dcmpg   <a href="../DJVM/INST/inst.lisp.html">inst</a> env cur))  
          ((equal op 'dconst_0)   (check-dconst_0 <a href="../DJVM/INST/inst.lisp.html">inst</a> env cur))
          ((equal op 'dload)      (check-dload   <a href="../DJVM/INST/inst.lisp.html">inst</a> env cur))  
          ((equal op 'dneg)       (check-dneg <a href="../DJVM/INST/inst.lisp.html">inst</a> env cur))
          ((equal op 'dreturn)    (check-dreturn   <a href="../DJVM/INST/inst.lisp.html">inst</a> env cur))  
          ((equal op 'dstore)     (check-dstore <a href="../DJVM/INST/inst.lisp.html">inst</a> env cur))
          ((equal op 'dup)        (check-dup  <a href="../DJVM/INST/inst.lisp.html">inst</a> env cur))  
          ((equal op 'dup_x1)     (check-dup_x1 <a href="../DJVM/INST/inst.lisp.html">inst</a> env cur))
          ((equal op 'dup_x2)     (check-dup_x2   <a href="../DJVM/INST/inst.lisp.html">inst</a> env cur))  
          ((equal op 'dup2)       (check-dup2 <a href="../DJVM/INST/inst.lisp.html">inst</a> env cur))
          ((equal op 'dup2_x1)    (check-dup2_x1   <a href="../DJVM/INST/inst.lisp.html">inst</a> env cur))  
          ((equal op 'dup2_x2)    (check-dup2_x2 <a href="../DJVM/INST/inst.lisp.html">inst</a> env cur))
          ((equal op 'f2d)        (check-f2d   <a href="../DJVM/INST/inst.lisp.html">inst</a> env cur))  
          ((equal op 'f2i)         (check-f2i <a href="../DJVM/INST/inst.lisp.html">inst</a> env cur))
          ((equal op 'f2l)         (check-f2l   <a href="../DJVM/INST/inst.lisp.html">inst</a> env cur))  
          ((equal op 'fadd)        (check-fadd <a href="../DJVM/INST/inst.lisp.html">inst</a> env cur))
          ((equal op 'faload)      (check-faload   <a href="../DJVM/INST/inst.lisp.html">inst</a> env cur))  
          ((equal op 'fastore)     (check-fastore <a href="../DJVM/INST/inst.lisp.html">inst</a> env cur))
          ((equal op 'fcmpg)       (check-fcmpg   <a href="../DJVM/INST/inst.lisp.html">inst</a> env cur))  
          ((equal op 'fconst_0)   (check-fconst_0 <a href="../DJVM/INST/inst.lisp.html">inst</a> env cur))
          ((equal op 'fload)      (check-fload   <a href="../DJVM/INST/inst.lisp.html">inst</a> env cur))  
          ((equal op 'fneg)       (check-fneg <a href="../DJVM/INST/inst.lisp.html">inst</a> env cur))
          ((equal op 'freturn)    (check-freturn   <a href="../DJVM/INST/inst.lisp.html">inst</a> env cur))  
          ((equal op 'fstore)     (check-fstore <a href="../DJVM/INST/inst.lisp.html">inst</a> env cur))
          ((equal op 'getfield)   (check-getfield <a href="../DJVM/INST/inst.lisp.html">inst</a> env cur))
          ((equal op 'getstatic)  (check-getstatic   <a href="../DJVM/INST/inst.lisp.html">inst</a> env cur))  
          ((equal op 'goto)       (check-goto <a href="../DJVM/INST/inst.lisp.html">inst</a> env cur))
          ((equal op 'i2f)        (check-i2f   <a href="../DJVM/INST/inst.lisp.html">inst</a> env cur))  
          ((equal op 'i2d)        (check-i2d   <a href="../DJVM/INST/inst.lisp.html">inst</a> env cur))  
          ((equal op 'i2l)        (check-i2l   <a href="../DJVM/INST/inst.lisp.html">inst</a> env cur))  
          ((equal op 'iadd)       (check-iadd <a href="../DJVM/INST/inst.lisp.html">inst</a> env cur))
          ((equal op 'saload)      (check-saload   <a href="../DJVM/INST/inst.lisp.html">inst</a> env cur))  
          ((equal op 'sastore)     (check-sastore <a href="../DJVM/INST/inst.lisp.html">inst</a> env cur))
          ((equal op 'iaload)      (check-iaload   <a href="../DJVM/INST/inst.lisp.html">inst</a> env cur))  
          ((equal op 'iastore)     (check-iastore <a href="../DJVM/INST/inst.lisp.html">inst</a> env cur))
          ((equal op 'if_acmpeq)   (check-if_acmpeq <a href="../DJVM/INST/inst.lisp.html">inst</a> env cur))
          ((equal op 'if_icmpeq)   (check-if_icmpeq <a href="../DJVM/INST/inst.lisp.html">inst</a> env cur))
          ((equal op 'ifeq)        (check-ifeq <a href="../DJVM/INST/inst.lisp.html">inst</a> env cur))
          ((equal op 'ifnonnull)   (check-ifnonnull <a href="../DJVM/INST/inst.lisp.html">inst</a> env cur))
          ((equal op 'iinc)        (check-iinc <a href="../DJVM/INST/inst.lisp.html">inst</a> env cur))
          ((equal op 'iload)      (check-iload   <a href="../DJVM/INST/inst.lisp.html">inst</a> env cur))  
          ((equal op 'ineg)       (check-ineg <a href="../DJVM/INST/inst.lisp.html">inst</a> env cur))
          ((equal op '<a href="../DJVM/INST/inst.lisp.html">inst</a>anceof) (check-<a href="../DJVM/INST/inst.lisp.html">inst</a>anceof <a href="../DJVM/INST/inst.lisp.html">inst</a> env cur))
          ((equal op 'invokeinterface) (check-invokeinterface  <a href="../DJVM/INST/inst.lisp.html">inst</a> env cur))  
          ((equal op 'invokespecial)  (check-invokespecial    <a href="../DJVM/INST/inst.lisp.html">inst</a> env cur))
          ((equal op 'invokestatic)   (check-invokestatic    <a href="../DJVM/INST/inst.lisp.html">inst</a> env cur))
          ((equal op 'invokevirtual)  (check-invokevirtual    <a href="../DJVM/INST/inst.lisp.html">inst</a> env cur))
          ((equal op 'ireturn)    (check-ireturn   <a href="../DJVM/INST/inst.lisp.html">inst</a> env cur))  
          ((equal op 'istore)     (check-istore <a href="../DJVM/INST/inst.lisp.html">inst</a> env cur))
          ((equal op 'l2f)        (check-l2f   <a href="../DJVM/INST/inst.lisp.html">inst</a> env cur))  
          ((equal op 'l2d)        (check-l2d   <a href="../DJVM/INST/inst.lisp.html">inst</a> env cur))  
          ((equal op 'l2i)         (check-l2i <a href="../DJVM/INST/inst.lisp.html">inst</a> env cur))
          ((equal op 'ladd)        (check-ladd <a href="../DJVM/INST/inst.lisp.html">inst</a> env cur))
          ((equal op 'laload)      (check-laload   <a href="../DJVM/INST/inst.lisp.html">inst</a> env cur))  
          ((equal op 'lastore)     (check-lastore <a href="../DJVM/INST/inst.lisp.html">inst</a> env cur))
          ((equal op 'lcmp)       (check-lcmp   <a href="../DJVM/INST/inst.lisp.html">inst</a> env cur))  
          ((equal op 'lconst_0)   (check-lconst_0 <a href="../DJVM/INST/inst.lisp.html">inst</a> env cur))
          ((equal op 'ldc)        (check-ldc 
                                   (<a href="../DJVM/INST/inst.lisp.html">inst</a>-resolve-cp <a href="../DJVM/INST/inst.lisp.html">inst</a> env) env cur))
          ((equal op 'ldc2_w)        (check-ldc2_w 
                                      (<a href="../DJVM/INST/inst.lisp.html">inst</a>-resolve-cp <a href="../DJVM/INST/inst.lisp.html">inst</a> env) env cur))
          ((equal op 'lload)      (check-lload   <a href="../DJVM/INST/inst.lisp.html">inst</a> env cur))  
          ((equal op 'lneg)         (check-lneg <a href="../DJVM/INST/inst.lisp.html">inst</a> env cur))
          ((equal op 'lookupswitch) (check-lookupswitch (<a href="../DJVM/INST/inst.lisp.html">inst</a>-trans-lookupswitch <a href="../DJVM/INST/inst.lisp.html">inst</a>) env cur))
          ((equal op 'lreturn)    (check-lreturn   <a href="../DJVM/INST/inst.lisp.html">inst</a> env cur))  
          ((equal op 'lshl)       (check-lshl   <a href="../DJVM/INST/inst.lisp.html">inst</a> env cur))
          ((equal op 'lstore)       (check-lstore <a href="../DJVM/INST/inst.lisp.html">inst</a> env cur))          
          ((equal op 'monitorenter)    (check-monitorenter   <a href="../DJVM/INST/inst.lisp.html">inst</a> env cur))
          ((equal op 'multianewarray)  (check-multianewarray <a href="../DJVM/INST/inst.lisp.html">inst</a> env cur))
          ((equal op 'new)       (check-new   <a href="../DJVM/INST/inst.lisp.html">inst</a> env cur))  
          ((equal op 'newarray)   (check-newarray <a href="../DJVM/INST/inst.lisp.html">inst</a> env cur))
          ((equal op 'nop)       (check-nop  <a href="../DJVM/INST/inst.lisp.html">inst</a> env cur))  
          ((equal op 'pop)       (check-pop <a href="../DJVM/INST/inst.lisp.html">inst</a> env cur))
          ((equal op 'pop2)      (check-pop2   <a href="../DJVM/INST/inst.lisp.html">inst</a> env cur))  
          ((equal op 'putfield)  (check-putfield <a href="../DJVM/INST/inst.lisp.html">inst</a> env cur))
          ((equal op 'putstatic)    (check-putstatic <a href="../DJVM/INST/inst.lisp.html">inst</a> env cur))
          ((equal op 'return)       (check-return <a href="../DJVM/INST/inst.lisp.html">inst</a> env cur))
          ((equal op 'saload)       (check-saload <a href="../DJVM/INST/inst.lisp.html">inst</a> env cur))
          ((equal op 'sipush)       (check-sipush <a href="../DJVM/INST/inst.lisp.html">inst</a> env cur))
          ((equal op 'swap)         (check-swap   <a href="../DJVM/INST/inst.lisp.html">inst</a> env cur))
          ((equal op 'tableswitch)  (check-tableswitch (<a href="../DJVM/INST/inst.lisp.html">inst</a>-trans-tableswitch <a href="../DJVM/INST/inst.lisp.html">inst</a>) env cur))
          (t nil))))


<span class="comment">; return boolean 
</span>

<span class="comment">;; *9* Note: 
;;     This corresponds to M3-untagged-runtime's 
;;     sig-check-inst   
;;     in /u/hbl/m3-runtime/m3-untagged-runtime-machine.lisp
;;
;; this, together with following sig-do-inst is where we define the
;; semantics of individual instruction. 
;; model differently from Prolog, We want to sperate the Guard --&gt; Action
</span>


(<span class="keyword">defun</span> <span class="function-name">sig-do-inst</span>  (instr Env cur)<span class="comment">;; *10* 
</span>  (<span class="keyword">let*</span> ((<a href="../DJVM/INST/inst.lisp.html">inst</a> (<a href="../DJVM/INST/inst.lisp.html">inst</a>ructionHasEquivalentTypeRule <a href="../DJVM/INST/inst.lisp.html">inst</a>r))
         (op   (op-code <a href="../DJVM/INST/inst.lisp.html">inst</a>)))
    (<span class="keyword">cond</span> ((equal op 'aaload)      (execute-aaload  <a href="../DJVM/INST/inst.lisp.html">inst</a> env cur))
          ((equal op 'aastore)     (execute-aastore <a href="../DJVM/INST/inst.lisp.html">inst</a> env cur))
          ((equal op 'aconst_null) (execute-aconst_null   <a href="../DJVM/INST/inst.lisp.html">inst</a> env cur))  
          ((equal op 'aload)       (execute-aload   <a href="../DJVM/INST/inst.lisp.html">inst</a> env cur))
          ((equal op 'anewarray)   (execute-anewarray   <a href="../DJVM/INST/inst.lisp.html">inst</a> env cur))  
          ((equal op 'areturn)     (execute-areturn <a href="../DJVM/INST/inst.lisp.html">inst</a> env cur))
          ((equal op 'arraylength) (execute-arraylength   <a href="../DJVM/INST/inst.lisp.html">inst</a> env cur))  
          ((equal op 'astore)      (execute-astore <a href="../DJVM/INST/inst.lisp.html">inst</a> env cur))
          ((equal op 'athrow)      (execute-athrow   <a href="../DJVM/INST/inst.lisp.html">inst</a> env cur))  
          ((equal op 'baload)      (execute-baload <a href="../DJVM/INST/inst.lisp.html">inst</a> env cur))
          ((equal op 'bastore)     (execute-bastore   <a href="../DJVM/INST/inst.lisp.html">inst</a> env cur))  
          ((equal op 'caload)      (execute-caload <a href="../DJVM/INST/inst.lisp.html">inst</a> env cur))
          ((equal op 'castore)     (execute-castore  <a href="../DJVM/INST/inst.lisp.html">inst</a> env cur))  
          ((equal op 'checkcast)   (execute-checkcast <a href="../DJVM/INST/inst.lisp.html">inst</a> env cur))
          ((equal op 'd2f)         (execute-d2f   <a href="../DJVM/INST/inst.lisp.html">inst</a> env cur))  
          ((equal op 'd2i)         (execute-d2i <a href="../DJVM/INST/inst.lisp.html">inst</a> env cur))
          ((equal op 'd2l)         (execute-d2l   <a href="../DJVM/INST/inst.lisp.html">inst</a> env cur))  
          ((equal op 'dadd)        (execute-dadd <a href="../DJVM/INST/inst.lisp.html">inst</a> env cur))
          ((equal op 'daload)      (execute-daload   <a href="../DJVM/INST/inst.lisp.html">inst</a> env cur))  
          ((equal op 'dastore)     (execute-dastore <a href="../DJVM/INST/inst.lisp.html">inst</a> env cur))
          ((equal op 'dcmpg)       (execute-dcmpg   <a href="../DJVM/INST/inst.lisp.html">inst</a> env cur))  
          ((equal op 'dconst_0)   (execute-dconst_0 <a href="../DJVM/INST/inst.lisp.html">inst</a> env cur))
          ((equal op 'dload)      (execute-dload   <a href="../DJVM/INST/inst.lisp.html">inst</a> env cur))  
          ((equal op 'dneg)       (execute-dneg <a href="../DJVM/INST/inst.lisp.html">inst</a> env cur))
          ((equal op 'dreturn)    (execute-dreturn   <a href="../DJVM/INST/inst.lisp.html">inst</a> env cur))  
          ((equal op 'dstore)     (execute-dstore <a href="../DJVM/INST/inst.lisp.html">inst</a> env cur))
          ((equal op 'dup)        (execute-dup  <a href="../DJVM/INST/inst.lisp.html">inst</a> env cur))  
          ((equal op 'dup_x1)     (execute-dup_x1 <a href="../DJVM/INST/inst.lisp.html">inst</a> env cur))
          ((equal op 'dup_x2)     (execute-dup_x2   <a href="../DJVM/INST/inst.lisp.html">inst</a> env cur))  
          ((equal op 'dup2)       (execute-dup2 <a href="../DJVM/INST/inst.lisp.html">inst</a> env cur))
          ((equal op 'dup2_x1)    (execute-dup2_x1   <a href="../DJVM/INST/inst.lisp.html">inst</a> env cur))  
          ((equal op 'dup2_x2)    (execute-dup2_x2 <a href="../DJVM/INST/inst.lisp.html">inst</a> env cur))
          ((equal op 'f2d)        (execute-f2d   <a href="../DJVM/INST/inst.lisp.html">inst</a> env cur))  
          ((equal op 'f2i)         (execute-f2i <a href="../DJVM/INST/inst.lisp.html">inst</a> env cur))
          ((equal op 'f2l)         (execute-f2l   <a href="../DJVM/INST/inst.lisp.html">inst</a> env cur))  
          ((equal op 'fadd)        (execute-fadd <a href="../DJVM/INST/inst.lisp.html">inst</a> env cur))
          ((equal op 'faload)      (execute-faload   <a href="../DJVM/INST/inst.lisp.html">inst</a> env cur))  
          ((equal op 'fastore)     (execute-fastore <a href="../DJVM/INST/inst.lisp.html">inst</a> env cur))
          ((equal op 'fcmpg)       (execute-fcmpg   <a href="../DJVM/INST/inst.lisp.html">inst</a> env cur))  
          ((equal op 'fconst_0)   (execute-fconst_0 <a href="../DJVM/INST/inst.lisp.html">inst</a> env cur))
          ((equal op 'fload)      (execute-fload   <a href="../DJVM/INST/inst.lisp.html">inst</a> env cur))  
          ((equal op 'fneg)       (execute-fneg <a href="../DJVM/INST/inst.lisp.html">inst</a> env cur))
          ((equal op 'freturn)    (execute-freturn   <a href="../DJVM/INST/inst.lisp.html">inst</a> env cur))  
          ((equal op 'fstore)     (execute-fstore <a href="../DJVM/INST/inst.lisp.html">inst</a> env cur))
          ((equal op 'getfield)   (execute-getfield <a href="../DJVM/INST/inst.lisp.html">inst</a> env cur))
          ((equal op 'getstatic)  (execute-getstatic   <a href="../DJVM/INST/inst.lisp.html">inst</a> env cur))  
          ((equal op 'goto)       (execute-goto <a href="../DJVM/INST/inst.lisp.html">inst</a> env cur))
          ((equal op 'i2f)        (execute-i2f   <a href="../DJVM/INST/inst.lisp.html">inst</a> env cur))  
          ((equal op 'i2d)        (execute-i2d   <a href="../DJVM/INST/inst.lisp.html">inst</a> env cur))  
          ((equal op 'i2l)        (execute-i2l   <a href="../DJVM/INST/inst.lisp.html">inst</a> env cur))  
          ((equal op 'iadd)       (execute-iadd <a href="../DJVM/INST/inst.lisp.html">inst</a> env cur))
          ((equal op 'iaload)      (execute-iaload   <a href="../DJVM/INST/inst.lisp.html">inst</a> env cur))  
          ((equal op 'iastore)     (execute-iastore <a href="../DJVM/INST/inst.lisp.html">inst</a> env cur))
          ((equal op 'saload)      (execute-saload   <a href="../DJVM/INST/inst.lisp.html">inst</a> env cur))  
          ((equal op 'sastore)     (execute-sastore <a href="../DJVM/INST/inst.lisp.html">inst</a> env cur))
          ((equal op 'if_acmpeq)   (execute-if_acmpeq <a href="../DJVM/INST/inst.lisp.html">inst</a> env cur))
          ((equal op 'if_icmpeq)   (execute-if_icmpeq <a href="../DJVM/INST/inst.lisp.html">inst</a> env cur))
          ((equal op 'ifeq)        (execute-ifeq <a href="../DJVM/INST/inst.lisp.html">inst</a> env cur))
          ((equal op 'ifnonnull)   (execute-ifnonnull <a href="../DJVM/INST/inst.lisp.html">inst</a> env cur))
          ((equal op 'iinc)        (execute-iinc <a href="../DJVM/INST/inst.lisp.html">inst</a> env cur))
          ((equal op 'iload)      (execute-iload   <a href="../DJVM/INST/inst.lisp.html">inst</a> env cur))  
          ((equal op 'ineg)       (execute-ineg <a href="../DJVM/INST/inst.lisp.html">inst</a> env cur))
          ((equal op '<a href="../DJVM/INST/inst.lisp.html">inst</a>anceof) (execute-<a href="../DJVM/INST/inst.lisp.html">inst</a>anceof <a href="../DJVM/INST/inst.lisp.html">inst</a> env cur))
          ((equal op 'invokeinterface) (execute-invokeinterface  <a href="../DJVM/INST/inst.lisp.html">inst</a> env cur))  
          ((equal op 'invokespecial)  (execute-invokespecial    <a href="../DJVM/INST/inst.lisp.html">inst</a> env cur))
          ((equal op 'invokestatic)   (execute-invokestatic    <a href="../DJVM/INST/inst.lisp.html">inst</a> env cur))
          ((equal op 'invokevirtual)  (execute-invokevirtual    <a href="../DJVM/INST/inst.lisp.html">inst</a> env cur))
          ((equal op 'ireturn)    (execute-ireturn   <a href="../DJVM/INST/inst.lisp.html">inst</a> env cur))  
          ((equal op 'istore)     (execute-istore <a href="../DJVM/INST/inst.lisp.html">inst</a> env cur))
          ((equal op 'l2f)        (execute-l2f   <a href="../DJVM/INST/inst.lisp.html">inst</a> env cur))  
          ((equal op 'l2d)        (execute-l2d   <a href="../DJVM/INST/inst.lisp.html">inst</a> env cur))  
          ((equal op 'l2i)         (execute-l2i <a href="../DJVM/INST/inst.lisp.html">inst</a> env cur))
          ((equal op 'ladd)        (execute-ladd <a href="../DJVM/INST/inst.lisp.html">inst</a> env cur))
          ((equal op 'laload)      (execute-laload   <a href="../DJVM/INST/inst.lisp.html">inst</a> env cur))  
          ((equal op 'lastore)     (execute-lastore <a href="../DJVM/INST/inst.lisp.html">inst</a> env cur))
          ((equal op 'lcmp)       (execute-lcmp   <a href="../DJVM/INST/inst.lisp.html">inst</a> env cur))  
          ((equal op 'lconst_0)   (execute-lconst_0 <a href="../DJVM/INST/inst.lisp.html">inst</a> env cur))
          ((equal op 'ldc)        (execute-ldc (<a href="../DJVM/INST/inst.lisp.html">inst</a>-resolve-cp <a href="../DJVM/INST/inst.lisp.html">inst</a> env) env cur))
          ((equal op 'ldc2_w)     (execute-ldc2_w (<a href="../DJVM/INST/inst.lisp.html">inst</a>-resolve-cp <a href="../DJVM/INST/inst.lisp.html">inst</a> env) env cur))
          ((equal op 'lload)      (execute-lload   <a href="../DJVM/INST/inst.lisp.html">inst</a> env cur))  
          ((equal op 'lneg)         (execute-lneg <a href="../DJVM/INST/inst.lisp.html">inst</a> env cur))
          ((equal op 'lookupswitch) (execute-lookupswitch <a href="../DJVM/INST/inst.lisp.html">inst</a> env cur))
          ((equal op 'lreturn)    (execute-lreturn   <a href="../DJVM/INST/inst.lisp.html">inst</a> env cur))  
          ((equal op 'lshl)       (execute-lshl   <a href="../DJVM/INST/inst.lisp.html">inst</a> env cur))
          ((equal op 'lstore)       (execute-lstore <a href="../DJVM/INST/inst.lisp.html">inst</a> env cur))          
          ((equal op 'monitorenter)    (execute-monitorenter   <a href="../DJVM/INST/inst.lisp.html">inst</a> env cur))
          ((equal op 'multianewarray)  (execute-multianewarray <a href="../DJVM/INST/inst.lisp.html">inst</a> env cur))
          ((equal op 'new)       (execute-new   <a href="../DJVM/INST/inst.lisp.html">inst</a> env cur))  
          ((equal op 'newarray)   (execute-newarray <a href="../DJVM/INST/inst.lisp.html">inst</a> env cur))
          ((equal op 'nop)       (execute-nop  <a href="../DJVM/INST/inst.lisp.html">inst</a> env cur))  
          ((equal op 'pop)       (execute-pop <a href="../DJVM/INST/inst.lisp.html">inst</a> env cur))
          ((equal op 'pop2)      (execute-pop2   <a href="../DJVM/INST/inst.lisp.html">inst</a> env cur))  
          ((equal op 'putfield)  (execute-putfield <a href="../DJVM/INST/inst.lisp.html">inst</a> env cur))
          ((equal op 'putstatic)    (execute-putstatic <a href="../DJVM/INST/inst.lisp.html">inst</a> env cur))
          ((equal op 'return)       (execute-return <a href="../DJVM/INST/inst.lisp.html">inst</a> env cur))
          ((equal op 'saload)       (execute-saload <a href="../DJVM/INST/inst.lisp.html">inst</a> env cur))
          ((equal op 'sipush)       (execute-sipush <a href="../DJVM/INST/inst.lisp.html">inst</a> env cur))
          ((equal op 'swap)         (execute-swap   <a href="../DJVM/INST/inst.lisp.html">inst</a> env cur))
          ((equal op 'tableswitch)  (execute-tableswitch <a href="../DJVM/INST/inst.lisp.html">inst</a> env cur))
          (t (mv nil nil)))))



 
<span class="comment">; return (&lt;frame&gt; &lt;frame&gt;) 
; first one is a NextStackFrame      as in normal execution
; next  one is a ExceptionStackFrame as in event an exception is thrown.
</span>
<span class="comment">;; *10* Note:
;;      In prolog version, typechecker.pl:351
;;      instructionIsTypeSafe  -- check instruction is TypeSafe 
;;      and compute the effect on SigState at the same time.
;;
;;      by returning a NextStackFrame and ExceptionStackFrame                 
</span>


<span class="comment">;; --------------------------------------------------
;;
;; Exception Handler Helper functions
;;
;; --------------------------------------------------
</span>
<span class="comment">;; &lt;ExceptionHandler&gt; ::= (handler &lt;stack_pc&gt; &lt;end_pc&gt; &lt;hander_pc&gt; &lt;ExceptionType&gt;)
</span>
(<span class="keyword">defun</span> <span class="function-name">handlerStartPC</span> (handler)
  (nth 1 handler))

(<span class="keyword">defun</span> <span class="function-name">handlerEndPC</span> (handler)
  (nth 2 handler))

(<span class="keyword">defun</span> <span class="function-name">handlerHandlerPC</span> (handler)
  (nth 3 handler))


(<span class="keyword">defun</span> <span class="function-name">handlerExceptionClass</span> (handler)<span class="comment">;; *11*
</span>  (nth 4 handler))

<span class="comment">;; *11* Note: 
;;   In JVM if handler type is O, translate into 
;;    (class "java.lang.Throwable")
;;
;;  jvm2acl2 tool translates the ExceptionInfo section type 0 into "All" -- old
;;  update: jvm2acl2 take the responsibility to translates this correctly
</span>
<span class="comment">; --- Exception helper ----
</span>
<span class="comment">;; assume well formed handlers
</span>(<span class="keyword">defun</span> <span class="function-name">isApplicableHandler</span> (offset handler) 
  (<span class="keyword">let</span> ((start (handlerStartPC handler))
        (end   (handlerEndPC   handler)))
    (and (&gt;= offset start)
         (&lt; offset end))))



<span class="comment">;; well formed the predicate is seperated from this function.
</span>(<span class="keyword">defun</span> <span class="function-name">instructionSatisfiesHandler</span> (Environment ExceptionStackFrame handler)
  (<span class="keyword">let</span> ((ExceptionClass (handlerExceptionClass handler))
        (Target  (handlerHandlerPC handler))
        (Flags  (frameFlags ExceptionStackFrame))
        (Locals (frameLocals ExceptionStackFrame)))
    (targetIsTypeSafe Environment (make-sig-Frame Locals (list ExceptionClass)
                                                  Flags)
                      Target)))
                      

<span class="comment">;; curMethod
</span>(<span class="keyword">defun</span> <span class="function-name">checklist-instructionSatisfiesHandler</span> (env frame Handlers)
  (<span class="keyword">if</span> (endp handlers)
      t
    (and (instructionSatisfiesHandler env frame (car Handlers))
         (checklist-instructionSatisfiesHandler env frame (cdr Handlers)))))

(<span class="keyword">defun</span> <span class="function-name">sublist-isApplicableHandler</span> (offset Handlers)
  (<span class="keyword">if</span> (endp handlers)
      nil
    (<span class="keyword">if</span> (isApplicableHandler offset (car Handlers))
        (cons (car Handlers) 
              (sublist-isApplicableHandler offset (cdr Handlers)))
      (sublist-isApplicableHandler offset (cdr Handlers)))))


(<span class="keyword">defun</span> <span class="function-name">instructionSatisfiesHandlers</span> (Environment offset ExceptionStackFrame)
  (<span class="keyword">let*</span> ((Handlers (exceptionHandlers Environment))
         (ApplicableHandlers (sublist-isApplicableHandler offset Handlers)))
    <span class="comment">;; collect all applicable handlers
</span>    (checklist-instructionSatisfiesHandler 
     Environment ExceptionStackFrame  ApplicableHandlers)))


(<span class="keyword">defun</span> <span class="function-name">mergedCodeIsTypeSafe</span>(Environment MergedCode StackFrame)
  (<span class="keyword">if</span> (endp MergedCode)  nil
    (<span class="keyword">if</span> (endp (cdr MergedCode))
        (and (isEnd (car mergedcode))
             (equal stackframe 'aftergoto))
      (<span class="keyword">if</span> (equal StackFrame 'afterGoto)
          (<span class="keyword">cond</span>  ((isStackMap (car MergedCode))
                  (prog2$ 
                   (acl2::debug-print <span class="string">"saw a stack frame as ~p0~%"</span> (getMap (car MergedCode)))
                   (<span class="keyword">let</span> ((MapFrame (mapFrame (getMap (car MergedCode)))))
                     (mergedCodeIsTypeSafe Environment (cdr MergedCode)
                                           mapFrame))))
                 ((isInstruction (car MergedCode))
                  (prog2$
                   (acl2::debug-print <span class="string">"Missing StackFrame aftergoto at offset ~p0~%"</span>
                                      (instrOffset (car MergedCode)))
                   nil))
                 (t nil))
        <span class="comment">;; is after unconditional branch, there must be a mapFrame  
</span>        (<span class="keyword">cond</span>  ((isStackMap (car MergedCode))
                (prog2$ 
                 (acl2::debug-print <span class="string">"saw a stack frame as ~p0~%"</span> (getMap (car MergedCode)))
                 (<span class="keyword">let</span> ((MapFrame (mapFrame (getMap (car MergedCode)))))
                   (and (frameIsAssignable StackFrame MapFrame
                                           Environment)
                        (mergedCodeIsTypeSafe Environment (cdr MergedCode)
                                              MapFrame)))))
          <span class="comment">;; must be an instruction (in a basic block)
</span>               ((isInstruction (car MergedCode))
                (prog2$
                 (acl2::debug-print <span class="string">"~%check <a href="../DJVM/INST/inst.lisp.html">inst</a> ~p0~%---~p1~%"</span> (car MergedCode) StackFrame)
                 (<span class="keyword">let</span> ((offset     (instrOffset (car MergedCode)))
                       (instr      (car MergedCode)))
                   (<span class="keyword">if</span> (instructionIsTypeSafe instr Environment StackFrame)
                       (prog2$ (acl2::debug-print <span class="string">"here"</span>)
                               (mv-let (NextStackFrame ExceptionStackFrame)
                                       (sig-do-inst instr Environment StackFrame)
                                       (and (instructionSatisfiesHandlers Environment offset
                                                                          ExceptionStackFrame)
                                            (prog2$
                                             (acl2::debug-print <span class="string">""</span> (car (cdr MergedCode)))
                                             (mergedCodeIsTypeSafe Environment (cdr MergedCode)
                                                                   NextStackFrame)))))
                     (prog2$ 
                      (acl2::debug-print <span class="string">"check <a href="../DJVM/INST/inst.lisp.html">inst</a> ~p0 failed! ~%~p1~%~p2~%"</span> 
                                         instr  stackFrame (stackFrameAtOffset
                                                            Environment (arg1 instr))) 
                      nil)))))
               (t nil))))))



<span class="comment">;; (defun mergedCodeIsTypeSafe(Environment MergedCode StackFrame)
;;   (if (endp MergedCode) 
;;       (equal StackFrame 'afterGoto)
;;     (if (equal StackFrame 'afterGoto)
;;         (if (isStackMap (car MergedCode))
;;             (prog2$ 
;;              (acl2::debug-print "saw a stack frame as ~p0~%" (getMap (car MergedCode)))
;;              (let ((MapFrame (mapFrame (getMap (car MergedCode)))))
;;                (mergedCodeIsTypeSafe Environment (cdr MergedCode)
;;                                      mapFrame)))
;;           (if (isInstruction (car MergedCode))
;;               (prog2$
;;                (acl2::debug-print "Missing StackFrame aftergoto at offset ~p0~%"
;;                          (instrOffset (car MergedCode)))
;;                nil)
;;             (isEnd (car MergedCode))))
;;       ;; is after unconditional branch, there must be a mapFrame  
;;       (if (isStackMap (car MergedCode))
;;           (prog2$ 
;;            (acl2::debug-print "saw a stack frame as ~p0~%" (getMap (car MergedCode)))
;;            (let ((MapFrame (mapFrame (getMap (car MergedCode)))))
;;              (and (frameIsAssignable StackFrame MapFrame
;;                                      Environment)
;;                   (mergedCodeIsTypeSafe Environment (cdr MergedCode)
;;                                         MapFrame))))
;;         ;; must be an instruction (in a basic block)
;;         (if (isInstruction (car MergedCode))
;;             (prog2$
;;              (acl2::debug-print "~%check <a href="../DJVM/INST/inst.lisp.html">inst</a> ~p0~%---~p1~%" (car MergedCode) StackFrame)
;;              (let ((offset     (instrOffset (car MergedCode)))
;;                    (instr      (car MergedCode)))
;;                (if (instructionIsTypeSafe instr Environment StackFrame)
;;                    (prog2$ (acl2::debug-print "here")
;;                            (mv-let (NextStackFrame ExceptionStackFrame)
;;                                    (sig-do-inst instr Environment StackFrame)
;;                                    (and (instructionSatisfiesHandlers Environment offset
;;                                                                       ExceptionStackFrame)
;;                                         (prog2$
;;                                          (acl2::debug-print "" (car (cdr MergedCode)))
;;                                          (mergedCodeIsTypeSafe Environment (cdr MergedCode)
;;                                                                NextStackFrame)))))
;;                  (prog2$ 
;;                   (acl2::debug-print "check <a href="../DJVM/INST/inst.lisp.html">inst</a> ~p0 failed! ~%~p1~%~p2~%" 
;;                             instr  stackFrame (stackFrameAtOffset
;;                                                Environment (arg1 instr))) 
;;                   nil))))
;;             (if (isEnd (car MergedCode)) t nil))))));; if reach an end
</span>

<span class="comment">;;;; Sat Dec 24 13:45:39 2005. Wrong!!! 
</span>
<span class="comment">;; (defun mergedCodeIsTypeSafe(Environment MergedCode StackFrame)
;;   (if (endp MergedCode) 
;;       (equal StackFrame 'afterGoto)
;;     (if (equal StackFrame 'afterGoto)
;;         (if (isStackMap (car MergedCode))
;;             (prog2$ 
;;              (acl2::debug-print "saw a stack frame as ~p0~%" (getMap (car MergedCode)))
;;              (let ((MapFrame (mapFrame (getMap (car MergedCode)))))
;;                (mergedCodeIsTypeSafe Environment (cdr MergedCode)
;;                                      mapFrame)))
;;           (if (isInstruction (car MergedCode))
;;               (prog2$
;;                (acl2::debug-print "Missing StackFrame aftergoto at offset ~p0~%"
;;                          (instrOffset (car MergedCode)))
;;                nil)
;;             (isEnd (car MergedCode))))
;;       ;; is after unconditional branch, there must be a mapFrame  
;;       (if (isStackMap (car MergedCode))
;;           (prog2$ 
;;            (acl2::debug-print "saw a stack frame as ~p0~%" (getMap (car MergedCode)))
;;            (let ((MapFrame (mapFrame (getMap (car MergedCode)))))
;;              (and (frameIsAssignable StackFrame MapFrame
;;                                      Environment)
;;                   (mergedCodeIsTypeSafe Environment (cdr MergedCode)
;;                                         MapFrame))))
;;         ;; must be an instruction (in a basic block)
;;         (if (isInstruction (car MergedCode))
;;             (prog2$
;;              (acl2::debug-print "~%check <a href="../DJVM/INST/inst.lisp.html">inst</a> ~p0~%---~p1~%" (car MergedCode) StackFrame)
;;              (let ((offset     (instrOffset (car MergedCode)))
;;                    (instr      (car MergedCode)))
;;                (if (instructionIsTypeSafe instr Environment StackFrame)
;;                    (prog2$ (acl2::debug-print "here")
;;                            (mv-let (NextStackFrame ExceptionStackFrame)
;;                                    (sig-do-inst instr Environment StackFrame)
;;                                    (and (instructionSatisfiesHandlers Environment offset
;;                                                                       ExceptionStackFrame)
;;                                         (prog2$
;;                                          (acl2::debug-print "" (car (cdr MergedCode)))
;;                                          (mergedCodeIsTypeSafe Environment (cdr MergedCode)
;;                                                                NextStackFrame)))))
;;                  (prog2$ 
;;                   (acl2::debug-print "check <a href="../DJVM/INST/inst.lisp.html">inst</a> ~p0 failed! ~%~p1~%~p2~%" 
;;                             instr  stackFrame (stackFrameAtOffset
;;                                                Environment (arg1 instr))) 
;;                   nil))))
;;           (if (isEnd (car MergedCode)) t nil))))));; if reach an end
</span>

<span class="comment">;; and not
;; afterGoto. fail. 
</span>

(<span class="keyword">defun</span> <span class="function-name">instrExists</span> (offset Instructions)
  (assoc-equal offset Instructions))

(<span class="keyword">defun</span> <span class="function-name">isEndofcode</span> (end Instructions)
  (<span class="keyword">if</span> (assoc-equal 'endofcode Instructions)
      (equal (cadr (assoc-equal 'endofcode Instructions))
             end)
    nil))
  

(<span class="keyword">defun</span> <span class="function-name">instrIncludedEnd</span> (Instructions End) 
  (or (instrExists End Instructions)<span class="comment">;; do we want to insert an (endofcode
</span>      <span class="comment">;; offset) into the parsed instruction? 
</span>      (isEndofCode End Instructions)))

<span class="comment">;; (defun isStackFrame (stackFrame)
;;   (and (consp stackFrame)
;;        (equal (car stackFrame) 'frame)))
</span>
(<span class="keyword">defun</span> <span class="function-name">handlerIsLegal</span> (Environment Handler)
  (<span class="keyword">let*</span> ((Start (handlerStartPC Handler))
         (End   (handlerEndPC   Handler))
         (Target (handlerHandlerPC Handler))
         (StackFrame (StackFrameAtOffset Environment Target))
         (ExceptionClass (handlerExceptionClass Handler))
         (Instructions (AllInstructions Environment)))
    (and (&lt; Start End)
         (instrExists Start Instructions)
         (isStackFrame stackframe)
         (instrIncludedEnd Instructions End)
         (isAssignable ExceptionClass '(class <span class="string">"java.lang.Throwable"</span>) environment))))
         
(<span class="keyword">defun</span> <span class="function-name">checklist-handlerIsLegal</span> (env handlers)
  (<span class="keyword">if</span> (endp handlers)
      t
    (and (handlerIsLegal env (car handlers))
         (checklist-handlerIsLegal env (cdr handlers)))))


(<span class="keyword">defun</span> <span class="function-name">handlersAreLegal</span> (Environment) 
  (<span class="keyword">let</span> ((Handlers (Handlers (methodEnvironment Environment)
                            (classEnvironment Environment))))
    (checklist-handlerIsLegal Environment Handlers)))

(<span class="keyword">defun</span> <span class="function-name">methodWithCodeIsTypeSafe</span> (Class Method CL)
  <span class="comment">;; change parseCodeAttribute to consistentCodeAttribute
</span>  (and (isWellFormedCodeAttribute Class Method) 
       <span class="comment">;; will this be important?
</span>       (<span class="keyword">let*</span> ((FrameSize  (FrameSize method Class)) 
              (MaxStack   (MaxStack   Method Class))
              <span class="comment">;;(ByteCodeLength (ByteCodeLength Method Class))
</span>              (ParsedCode (ParsedCode Method Class))
              (Handlers   (Handlers    Method Class))
              (StackMap   (StackMap   Method Class)))
         (and<span class="comment">;; (mem '(endofCode *any*) ParsedCode) 
</span>          <span class="comment">;; temp, doubt whether it
</span>          <span class="comment">;; will work this way.
</span>          (<span class="keyword">let*</span> ((MergedCode (mergeStackMapAndCode StackMap ParsedCode))
                 (StackFrame (methodInitialStackFrame Class Method FrameSize))
                 (ReturnType  (methodReturnType Method))
                 (Environment (makeEnvironment Class Method ReturnType
                                               MergedCode MaxStack
                                               Handlers
                                               CL)))
            (and (handlersAreLegal Environment)
                 (mergedCodeIsTypeSafe Environment MergedCode
                                       StackFrame)))))))

<span class="comment">;--------------
</span>(<span class="keyword">defun</span> <span class="function-name">sigMatch</span> (m1 m2)
  (and (equal (methodName m1) (methodName m2))
       (equal (methodParameters m1) (methodParameters m2))
       (equal (methodReturnType m1) (methodReturnType m2))))


(<span class="keyword">defun</span> <span class="function-name">matchMethodNameSig</span> (method methods)
  (<span class="keyword">if</span> (endp methods) 
      nil
    (<span class="keyword">if</span> (sigMatch method (car methods))
        (car methods)
      (matchMethodNameSig method (cdr methods)))))

(<span class="keyword">defun</span> <span class="function-name">isFinal</span> (method)
  (member '*final* (methodAccessFlags method)))


<span class="comment">#|        
(defun doesNotOverrideFinalMethod (Class Method CL)
  (let ((classname (classClassName Class)))
    (or (equal classname "java.lang.Object")
        (let* ((supername (classSuperClassName Class))
               (superClass (class-by-name supername CL))
               (methods (classMethods superClass))
               (matched (matchMethodNameSig method methods)))
               (if matched 
                   (not (isFinal matched))
                 (doesNotOverrideFinalMethod superClass Method CL))))))
|#</span> <span class="comment">;; This is hard to terminate. Write a different one. 
</span>
(<span class="keyword">defun</span> <span class="function-name">doesNotOverrideFinalMethodInClasses</span> (supers Method cl)
  (<span class="keyword">if</span> (endp supers) t
    (<span class="keyword">let*</span> ((supername (car supers))
           (superClass (class-by-name supername CL))
           (methods (classMethods superClass))
           (matched (matchMethodNameSig method methods)))
      (<span class="keyword">if</span> <span class="comment">;; matched ;;; Fri Jan 28 16:38:20 2005. Same problem as lookupFieldInClasses
</span>          (sigMatch method matched)
          (not (isFinal matched))
        (doesNotOverrideFinalMethodInClasses (cdr supers) Method cl)))))

(<span class="keyword">defun</span> <span class="function-name">doesNotOverrideFinalMethod</span> (Class Method CL)
    (<span class="keyword">let*</span> ((classname (classClassName Class))
           (superclasses (superClassChain classname cl)))
      (or (equal classname <span class="string">"java.lang.Object"</span>)
          (doesNotOverrideFinalMethodInClasses superclasses Method CL))))


(<span class="keyword">defun</span> <span class="function-name">methodIsTypeSafe</span> (Class CL Method)
  (<span class="keyword">let*</span> ((AccessFlags (methodAccessFlags Method))
         (code  (methodCodeAttribute Method)))
    (and (doesNotOverrideFinalMethod Class Method CL)
         (or (mem '*abstract*  AccessFlags)<span class="comment">;; rule 1
</span>             (mem '*native*  AccessFlags)<span class="comment">;; rule 2  
</span>             (and (not (mem '*native*  AccessFlags))<span class="comment">;; rule 3
</span>                  (not (mem '*abstract* AccessFlags))
                  (not (equal code nil))
                  (methodWithCodeIsTypeSafe Class Method CL))))))

   
   
(<span class="keyword">defun</span> <span class="function-name">checklist-methodIsTypeSafe</span> (class cl methods)
  (<span class="keyword">if</span> (endp methods)
      t
    (and (prog2$ 
          (acl2::debug-print <span class="string">"Checking Method ~p0 in Class ~p1~%"</span> 
                    (methodName (car methods)) (classClassName  class))
          (methodIsTypeSafe class cl (car methods)))
         (prog2$
          (acl2::debug-print <span class="string">"Check Method ~p0 Passed!~%~%"</span> (methodName (car methods)))
          (checklist-methodIsTypeSafe class cl (cdr methods))))))
    
(<span class="keyword">defun</span> <span class="function-name">classIsFinal</span> (Class)
  (member '*final* (classAccessFlags Class)))

(<span class="keyword">defun</span> <span class="function-name">classIsNotFinal</span> (Class)
  (not (classIsFinal Class)))


(<span class="keyword">defun</span> <span class="function-name">classIsTypeSafe</span> (Class CL)
  (<span class="keyword">let</span> ((Methods (classMethods Class))
        (Name    (classClassName class)))
    (prog2$
     (acl2::debug-print  <span class="string">"Checking class ~p0 ~%"</span> (classClassName class))
     (and (isClassTerm Class)
          (or (equal Name <span class="string">"java.lang.Object"</span>)
              (<span class="keyword">let*</span> ((superClassName (classSuperClassName Class))
                     (superClass (class-by-name superClassName CL)))
                (classIsNotFinal superClass)))
          (checklist-methodIsTypeSafe Class Cl Methods)))))


(<span class="keyword">defun</span> <span class="function-name">bcv-sim</span> (mcode env curframe n)
  (<span class="keyword">if</span> (zp n)
      curframe
    (<span class="keyword">if</span> (endp mcode)
        curframe
      (<span class="keyword">if</span> (isStackMapFrame (car mcode))
          (prog2$
           (acl2::debug-print <span class="string">"saw a mapframe ~p0 ~%"</span>(getMap (car mcode)))
           (<span class="keyword">if</span> (equal curFrame 'aftergoto) 
               (bcv-sim (cdr mcode) env (mapFrame (getMap (car mCode))) (- n 1))
             (<span class="keyword">if</span> (FrameIsAssignable curFrame (mapFrame (getMap (car mcode))) env)
                 (bcv-sim (cdr mcode) env (mapFrame (getMap (car mCode))) (- n 1))
               (acl2::debug-print <span class="string">"incompatible mapframe ~p0 ~% ~p1~%"</span> curFrame (mapFrame (getMap (car mcode)))))))
        (<span class="keyword">if</span> (isInstruction (car mcode))
            (<span class="keyword">if</span> (instructionIsTypeSafe (car mcode) env curFrame)
                (prog2$ 
                 (acl2::debug-print <span class="string">"inst ~p0 OK~%----~%~p1~%===~%"</span> (car mcode) curFrame)
                 (mv-let (nextframe exceptionframe)
                         (sig-do-inst (car mcode) env curframe)
                         (<span class="keyword">declare</span> (ignore exceptionFrame))
                         (bcv-sim (cdr mcode) env nextframe  (- n 1))))
              (acl2::debug-print <span class="string">"inst ~p0 failed on ~p1~%"</span> (car mcode) curframe))
          (<span class="keyword">if</span> (isEnd (car mcode)) 
              (acl2::debug-print <span class="string">"Verification Succeed!~%"</span>)
            (acl2::debug-print <span class="string">"unknown sequence ~p0~%"</span> mcode)))))))

(<span class="keyword">defun</span> <span class="function-name">bcv-sim2</span> (method class cl n) 
  (<span class="keyword">let*</span> ((FrameSize  (FrameSize method Class)) 
         (MaxStack   (MaxStack   Method Class))
         <span class="comment">;;(ByteCodeLength (ByteCodeLength Method Class))
</span>         (ParsedCode (ParsedCode Method Class))
         (Handlers   (Handlers    Method Class))
         (StackMap   (StackMap   Method Class)))
    (<span class="keyword">let*</span> ((MergedCode (mergeStackMapAndCode StackMap ParsedCode))
           (StackFrame (methodInitialStackFrame Class Method FrameSize))
           (ReturnType  (methodReturnType Method))
           (Environment (makeEnvironment Class Method ReturnType
                                         MergedCode MaxStack
                                         Handlers
                                         CL)))
      (bcv-sim mergedcode environment stackframe n))))
                


                    
   
<span class="comment">;; (defun make-class-def (class)
;;   class)
</span>
<span class="comment">;; I changed the file format of the output of jvm2acl2
;; to include better support for accessflags 
;; The classIsInterface field disappeared.
;;
;; either change the definition of make-class-def 
;; or make change to this typechecker.
;; 
;; chose to change this <a href="typechecker.lisp.html">typechecker</a> to reflect the change.
;; because to allow expansion, we need the better support for accessflag.
;; is this true??? -- no
;;
;; let's change make-class-def
</span>
(<span class="keyword">defun</span> <span class="function-name">classname-s</span> (scd)          (nth 1 scd))
(<span class="keyword">defun</span> <span class="function-name">super-s</span>     (scd)          (nth 2 scd))
(<span class="keyword">defun</span> <span class="function-name">constantpool-s</span>   (scd)     (cdr (nth 3 scd)))
(<span class="keyword">defun</span> <span class="function-name">fields-s</span>         (scd)     (cdr (nth 4 scd)))
(<span class="keyword">defun</span> <span class="function-name">methods-s</span>        (scd)     (cdr (nth 5 scd)))
(<span class="keyword">defun</span> <span class="function-name">interfaces-s</span>     (scd)     (cdr (nth 6 scd)))
(<span class="keyword">defun</span> <span class="function-name">accessflags-s</span>    (scd)     (cdr (nth 7 scd)))
(<span class="keyword">defun</span> <span class="function-name">attributes-s</span>     (scd)     (cdr (nth 8 scd)))

(<span class="keyword">defun</span> <span class="function-name">make-class-def</span> (raw-class)
  (make-class-term 
   (classname-s raw-class)
   (mem '*interface* (accessflags-s raw-class))
   (super-s     raw-class)
   (constantpool-s  raw-class)
   (interfaces-s    raw-class)
   (fields-s        raw-class)
   (methods-s       raw-class)
   (accessflags-s   raw-class)))


(<span class="keyword">defmacro</span> <span class="function-name">make-static-class-decls</span> (<span class="type">&amp;rest</span> cl)
  (cons 'list cl))


(<span class="keyword">defun</span> <span class="function-name">verifyAll</span> (l cl)
  (<span class="keyword">if</span> (endp l)
      t
    (and (classIsTypeSafe (car l) cl)
         (verifyAll (cdr l) cl))))
                
                
(<span class="keyword">defun</span> <span class="function-name">collectAllFailedClass</span> (l cl)
  (<span class="keyword">if</span> (endp l)
      nil
    (<span class="keyword">if</span> (classIsTypeSafe (car l) cl)
        (collectAllFailedClass (cdr l) cl)
      (cons (classClassName (car l)) (collectAllFailedClass (cdr l) cl)))))
           
(<span class="keyword">defun</span> <span class="function-name">abstract-parsedCode</span> (c)
  (<span class="keyword">declare</span> (ignore c))
  nil)

(<span class="keyword">defun</span> <span class="function-name">abstract-methodCodeAttribute</span> (m)
  (make-code-attribute-term
   (MaxStack1 m)
   (FrameSize1 m)
   (ByteCodeLength1 m)
   (abstract-parsedCode (ParsedCode1 m))
   (Handlers1   m)
   (StackMap1   m)))

(<span class="keyword">defun</span> <span class="function-name">abstract-method-def</span> (m)
  (make-method-term 
   (methodName m)
   (methodParameters m)
   (methodReturnType m)
   (methodAccessFlags m)
   (abstract-methodCodeAttribute 
    (methodCodeAttribute m))))
   


(<span class="keyword">defun</span> <span class="function-name">abstract-method-defs</span> (methods)
  (<span class="keyword">if</span> (endp methods)
      nil
    (cons (abstract-method-def (car methods))
          (abstract-method-defs (cdr methods)))))


(<span class="keyword">defun</span> <span class="function-name">abstract-class-def</span> (c)
  (make-class-term 
   (classClassName c)
   (classIsInterface c)
   (classSuperClassName c)
   (classConstantPool c)
   (classInterfaces c)
   (classFields     c)
   (abstract-method-defs
    (classMethods    c))
   (classAccessFlags c)))

<span class="comment">;; (defun abstract-class-def (c)
;;   (make-class-term 
;;    (classClassName c)
;;    (classIsInterface c)
;;    (classSuperClassName c)
;;    (classConstantPool c)
;;    (classInterfaces c)
;;    (classFields     c)
;;    (abstract-method-defs
;;     (classMethods    c))
;;    (classAccessFlags c)
;;    (classAttributes c)))
</span>
(<span class="keyword">defun</span> <span class="function-name">abstract-class-defs</span> (cl) 
  (<span class="keyword">if</span> (endp cl) 
      nil
    (cons (abstract-class-def (car cl))
          (abstract-class-defs (cdr cl)))))


(<span class="keyword">defun</span> <span class="function-name">abstract-class-table</span> (ct)
  (abstract-class-defs ct))



<span class="comment">#|
(defthm bcv-abs-bcv-concrete-equal 
  (iff (classIsTypeSafe c concrete-ct)
       (classIsTypeSafe c (abstract-class-table concrete-ct))))
|#</span>

                
<span class="comment">;----------------------------------------------------------------------
</span>
<span class="comment">; Wed Aug 17 20:16:18 2005. 
</span>
(<span class="keyword">defun</span> <span class="function-name">good-stack-maps</span> (maps program)
  (<span class="keyword">if</span> (endp maps) t
    (<span class="keyword">if</span> (endp program) nil
      (<span class="keyword">let</span> ((mpc (mapoffset (car maps)))
            (pc (instroffset (car program))))
        (<span class="keyword">if</span> (equal mpc pc)
            (good-stack-maps (cdr maps) (cdr program))
          (<span class="keyword">if</span> (&lt; pc mpc)
              (good-stack-maps maps (cdr program))
            nil))))))


<span class="comment">;----------------------------------------------------------------------
</span>




































</pre>
  </body>
</html>
