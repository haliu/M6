<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01//EN">
<!-- Created by htmlize-1.16 in css mode. -->
<html>
  <head>
    <title>jvm-exceptions.lisp</title>
    <style type="text/css">
    <!--
      body {
        color: #f5deb3;
        background-color: #000000;
      }
      .builtin {
        /* font-lock-builtin-face */
        color: #b0c4de;
      }
      .comment {
        /* font-lock-comment-face */
        color: #ff7f24;
      }
      .function-name {
        /* font-lock-function-name-face */
        color: #87cefa;
      }
      .keyword {
        /* font-lock-keyword-face */
        color: #00ffff;
      }
      .string {
        /* font-lock-string-face */
        color: #ffa07a;
      }
      .type {
        /* font-lock-type-face */
        color: #98fb98;
      }
      a {
        color: inherit;
        background-color: inherit;
        font: inherit;
        text-decoration: inherit;
      }
      a:hover {
        text-decoration: underline;
      }
    -->
    </style>
  </head>
  <body>
    <pre>
(<span class="keyword">in-package</span> <span class="string">"JVM"</span>)
(include-book <span class="string"><a href="jvm-type-value.lisp.html">"../M6-DJVM-shared/jvm-type-value"</a></span>)
(include-book <span class="string"><a href="jvm-object-manipulation-primitives.lisp.html">"../M6-DJVM-shared/jvm-object-manipulation-primitives"</a></span>)
(include-book <span class="string"><a href="jvm-thread.lisp.html">"../M6-DJVM-shared/jvm-thread"</a></span>)
(include-book <span class="string"><a href="jvm-thread-primitives.lisp.html">"../M6-DJVM-shared/jvm-thread-primitives"</a></span>)
(include-book <span class="string"><a href="jvm-linker.lisp.html">"../M6-DJVM-shared/jvm-linker"</a></span>)
(include-book <span class="string"><a href="jvm-object-type-hierachy.lisp.html">"../M6-DJVM-shared/jvm-object-type-hierachy"</a></span>)
(include-book <span class="string"><a href="jvm-monitor-primitives.lisp.html">"../M6-DJVM-shared/jvm-monitor-primitives"</a></span>)
(include-book <span class="string"><a href="jvm-state.lisp.html">"../M6-DJVM-shared/jvm-state"</a></span>)
(include-book <span class="string"><a href="jvm-obj.lisp.html">"../M6-DJVM-shared/jvm-obj"</a></span>)


(include-book <span class="string">"ordinals/e0-ordinal"</span> <span class="builtin">:dir</span> <span class="builtin">:system</span>)
(set-well-founded-relation e0-ord-&lt;)


<span class="comment">;; <a href="../common/primitives.lisp.html">primitives</a> to manipulate exceptions
;; 1. find the appropriate exception handler
;; 2. find the error message contained in the exception.
</span>

<span class="comment">;; Thu Apr  8 19:39:17 2004
;;
;; Only called from the JVM when current-thread is -1 which I will assert when
;; current-thread is -1, no thread is thrown!!
;; 
</span>
(acl2::set-verify-guards-eagerness 2)

(<span class="keyword">defun</span> <span class="function-name">ERROR_THROW</span> (i s)
  (<span class="keyword">declare</span> (xargs <span class="builtin">:guard</span> t))
  <span class="comment">;; I could assert <a href="../DJVM/consistent-state.lisp.html">consistent-state</a> in <a href="../DJVM/consistent-state.lisp.html">consistent-state</a>.  however that is not
</span>  <span class="comment">;; defined, yet!  Thu Apr 8 19:41:49 2004. the same problem as with
</span>  <span class="comment">;; <a href="jvm-loader.lisp.html">jvm-loader</a> One could combine guard verification with
</span>  <span class="comment">;; consistency-perserving. 
</span>  (<span class="keyword">declare</span> (ignore i))
  s)


(<span class="keyword">defun</span> <span class="function-name">wff-exception-hander</span> (handler)
  (and (consp handler)
       (true-listp handler)
       (equal (car handler) 'handler)
       (equal (len handler) 5)
       (integerp (nth 1 handler)) 
       (integerp (nth 2 handler))
       (integerp (nth 3 handler))
       (wff-type-rep (nth 4 handler))))
       


(<span class="keyword">defun</span> <span class="function-name">handler-start</span> (handler)
  (<span class="keyword">declare</span> (xargs <span class="builtin">:guard</span> (wff-exception-hander handler)))
  (nth 1 handler))

(<span class="keyword">defun</span> <span class="function-name">handler-end</span> (handler)
  (<span class="keyword">declare</span> (xargs <span class="builtin">:guard</span> (wff-exception-hander handler)))
  (nth 2 handler))

(<span class="keyword">defun</span> <span class="function-name">handler-entry-point</span> (handler)
  (<span class="keyword">declare</span> (xargs <span class="builtin">:guard</span> (wff-exception-hander handler)))
  (nth 3 handler))

<span class="comment">;;;
;;; DJVM will check the entry point at right position in an instruction stream.
;;; need to assert this as part of <a href="../DJVM/consistent-state.lisp.html">consistent-state</a> Thu Apr 8 19:55:39 2004
;;;
</span>
(<span class="keyword">defun</span> <span class="function-name">handler-exception-type</span> (handler)
  (<span class="keyword">declare</span> (xargs <span class="builtin">:guard</span> (wff-exception-hander handler)))
  (normalize-type-rep (nth 4 handler)))

(include-book <span class="string"><a href="jvm-exceptions-guard-verification-1.lisp.html">"../M6-DJVM-shared/jvm-exceptions-guard-verification-1"</a></span>)

(<span class="keyword">defun</span> <span class="function-name">correct-java-lang-String-class</span> (s)
  (and (wff-state s)
       (wff-class-table (class-table s))
       (wff-instance-class-table (instance-class-table s))       
       (equal (class-by-name <span class="string">"java.lang.String"</span> (instance-class-table s))
              (runtime-java-lang-String))))
       

<span class="comment">;; (defthm correct-java-lang-String-class-implies-field-access-to
;;   (implies (and (correct-java-lang-String-class s)
;;                 (bound? str-ref (heap s)))
;;            (field-access-guard "java.lang.String" "value" str-ref s)))
</span>  
<span class="comment">;;;
;;; this above is not true, we really need to know the OBJECT is
;;; consistent-object.
;;;
;;; HOWEVER consistent-object has not be defined yet!! 
;;;
;;;
;;; thus the guard is quite complicated
;;;
</span>
(<span class="keyword">defun</span> <span class="function-name">JavaString-to-ACL2-str-guard</span> (str-ref s)
  (and (wff-state s)
       (wff-heap (heap s))
       (bound? str-ref (heap s))
       (correct-java-lang-String-class s)
       (field-access-guard <span class="string">"java.lang.String"</span> <span class="string">"value"</span>  str-ref s)
       (field-access-guard <span class="string">"java.lang.String"</span> <span class="string">"offset"</span> str-ref s)
       (field-access-guard <span class="string">"java.lang.String"</span> <span class="string">"count"</span> str-ref s)
       (mylet* ((array-ref (m6-getfield <span class="string">"java.lang.String"</span> <span class="string">"value"</span> str-ref s))
                (array-obj (deref array-ref (heap s)))
                (array-data (array-data array-obj))
                (start (m6-getfield <span class="string">"java.lang.String"</span> <span class="string">"offset"</span> str-ref s))
                (len   (m6-getfield <span class="string">"java.lang.String"</span> <span class="string">"offset"</span> str-ref s))
                (codes (sub-list array-data start len)))
               (or (equal array-ref -1)
                   (and (bound? array-ref (heap s))
                        (wff-internal-array array-obj)
                        (integerp start)
                        (integerp len)
                        (&lt;= 0 start)
                        (&lt;= 0 len)
                        (&lt; (+ start len) (array-bound array-obj))
                        (chars-numsp codes))))))
                        
           
<span class="comment">;; The guard is complicated but easy to establish!!
;;
;; ACL2 should be more intelliegent to figure out the minimum guard!! 
</span>
(acl2::set-verify-guards-eagerness 0)

(<span class="keyword">defun</span> <span class="function-name">JavaString-to-ACL2-str</span> (str-ref s)
  (<span class="keyword">declare</span> (xargs <span class="builtin">:guard</span> (JavaString-to-ACL2-str-guard str-ref s)))
  (mylet* ((array-ref (m6-getfield <span class="string">"java.lang.String"</span> <span class="string">"value"</span>  str-ref s))
           (start     (m6-getfield <span class="string">"java.lang.String"</span> <span class="string">"offset"</span> str-ref s))
           (len       (m6-getfield <span class="string">"java.lang.String"</span> <span class="string">"count"</span>  str-ref s))
           (array-obj (deref array-ref (heap s)))
           (array-data (array-data array-obj))
           (codes      (sub-list array-data start len)))
          (<span class="keyword">if</span> (equal array-ref -1)
              <span class="string">""</span>
            (make-acl2-string (code-to-chars codes)))))


(<span class="keyword">defun</span> <span class="function-name">throw-exception2</span> (obj-ref s)
  (prog2$ (acl2::cw <span class="string">"uncaught exception ~p0!~%Stop current-thread ~p1~%"</span>
                    obj-ref (current-thread s))
          (stopThread s)))


(<span class="keyword">defun</span> <span class="function-name">find-handler</span> (handlers exception-type ip-offset s)
  (<span class="keyword">let</span> ((handler (car handlers)))
    (<span class="keyword">if</span> (endp handlers)
        (mv nil s)
      (<span class="keyword">let*</span> ((start (handler-start handler))
             (end   (handler-end   handler))
             (type  (handler-exception-type handler))
             (s1    (resolveClassReference type s))) <span class="comment">;; this can raise fatal error
</span>        (<span class="keyword">if</span> (not (no-fatal-error? s1))  <span class="comment">;; pass the fatal error on.
</span>            (mv nil s1)
          (<span class="keyword">if</span> (or (&lt; ip-offset start)
                  (&gt; ip-offset end))
              (find-handler (cdr handlers) exception-type ip-offset s)
            (mv-let (assignable s2)
                    (isAssignableTo exception-type type s1)
                    (<span class="keyword">if</span> assignable
                        (mv handler s2)
                      (find-handler (cdr handlers) exception-type ip-offset s2)))))))))
      



(<span class="keyword">defun</span> <span class="function-name">getExceptionMessage</span> (obj-ref s)
  (<span class="keyword">let*</span> ((obj (deref obj-ref s))
         (specific-info (specific-info obj))
         (msg-ref  (specific-info-throwable-instance-message specific-info)))
    msg-ref))
    



<span class="comment">;--- <a href="../common/primitives.lisp.html">primitives</a> for dealing with monitors, exception handling need that. ---
;
;    according to JVM spec, if monitorExit is called in an incorrect state
;    the an exception need to be raised. however in KVM implementation, this is
;    not the case. In MonitorExit no exception is thrown, instead a variable is
;    used to record what kind of exception is thrown.
;
;---
</span>
<span class="comment">;; it refers to many helper functions, such as obj-monitor-by-ref, 
;; which is defined jvm-monitors.
</span>
<span class="comment">;; (mv * * *)
</span>(<span class="keyword">defun</span> <span class="function-name">monitorExit</span> (obj-ref s)
  (<span class="keyword">let</span> ((monitor (obj-monitor-by-ref obj-ref s)))
    (<span class="keyword">if</span> (not (equal (owner monitor) (current-thread s)))
        (mv 'MonitorStatusError  <span class="string">"IllegalMonitorStateException"</span> s)
      (<span class="keyword">let*</span> ((new-monitor (monitor-set-depth (- (depth monitor) 1)
                                             monitor))
             (new-state (update-obj-monitor obj-ref new-monitor s)))
        (<span class="keyword">if</span> (equal (depth new-monitor) 0)
            (mv 'MonitorStatusRelease nil (removeMonitorWait obj-ref new-state))
          (mv 'MonitorStatusOwn nil new-state))))))



<span class="comment">;; Mon Dec 29 15:44:53 2003
</span>
<span class="comment">;; (defun wff-thread-strong1 (thread)
;;   (and (wff-thread thread)
;;        (consp (thread-call-stack thread))))
</span>
<span class="comment">;; (defun wff-thread-table-strong1 (tt)
;;   (if (endp tt)
;;       t
;;     (and (wff-thread-strong1 (car tt))
;;          (wff-thread-table-strong1 (cdr tt)))))
</span>

(<span class="keyword">defun</span> <span class="function-name">call-stack-depth</span> (s)
  (<span class="keyword">let</span> ((tid (current-thread s)))
    (<span class="keyword">if</span> (equal tid -1)
        1
      (<span class="keyword">if</span> (not (wff-thread-table (thread-table s)))
          1
      (<span class="keyword">let</span> ((thd (thread-by-id tid (thread-table s))))
        (<span class="keyword">if</span> (not (current-thread-exists? s))
            1
          (<span class="keyword">let</span> ((call-stack (thread-call-stack thd)))
            (+ (len call-stack) 2))))))))


(<span class="keyword">defun</span> <span class="function-name">locked-stage</span> (s)
  (<span class="keyword">let*</span> ((curframe (current-frame s))
         (sync-obj-ref (sync-obj-ref curframe)))
    (<span class="keyword">if</span> (equal sync-obj-ref -1)
        1
      2)))


(<span class="keyword">defun</span> <span class="function-name">exception-measure</span> (stage s)
  (cons (cons (cons (call-stack-depth s) 0)
        (locked-stage s))
        stage))



(defthm build-java-visible-instance-data-only-change-heap
  (mv-let (obj s1)
          (build-a-java-visible-instance-data classnames s0)
          (<span class="keyword">declare</span> (ignore obj))
  (and    (equal (pc s1) (pc s0))
          (equal (current-thread s1) (current-thread s0))
          <span class="comment">;; (equal (heap s1) (heap s0))
</span>          (equal (thread-table   s1) (thread-table s0))
          (equal (class-table    s1) (class-table  s0))
          (equal (env            s1) (env          s0))
          (equal (error-flag     s1) (error-flag   s0))
          )))


(in-theory (disable env))
(defthm instantiate-only-change-heap
  (mv-let (obj s1)
          (instantiate classname s0)
          (<span class="keyword">declare</span> (ignore obj))
  (and    (equal (pc s1) (pc s0))
          (equal (current-thread s1) (current-thread s0))
          <span class="comment">;; (equal (heap s1) (heap s0))
</span>          (equal (thread-table   s1) (thread-table s0))
          (equal (class-table    s1) (class-table  s0))
          (equal (env            s1) (env          s0))
          (equal (error-flag     s1) (error-flag   s0))
          )))
    
(in-theory (disable instantiate))


(defthm current-thread-pushFrame0
  (equal (current-thread (pushFrame0 anyFrame s))
         (current-thread s)))


(defthm current-thread-popFrame
  (equal (current-thread (popFrame s))
         (current-thread s)))

(in-theory (disable make-thread))


(defthm wff-thread-make-thread 
  (wff-thread (make-thread id 
                           saved-pc 
                           cs
                           status
                           m-ref
                           mdepth
                           thread-ref))
  <span class="builtin">:hints</span> ((<span class="string">"Goal"</span> <span class="builtin">:in-theory</span> (enable wff-thread make-thread))))




(defthm wff-thread-table-is-preserved-by-pushFrame
  (implies (wff-thread-table (thread-table s))
           (wff-thread-table (thread-table (pushFrame0 anyFrame s)))))


(defthm wff-thread-table-is-preserved-by-popFrame
  (implies (wff-thread-table (thread-table s))
           (wff-thread-table (thread-table (popFrame s)))))

(defthm wff-thread-table-thread-id
  (implies (thread-by-id id tt)
           (equal (thread-id (thread-by-id id tt))
                  id)))


(defthm thread-exists?-implies-thread-exists?
  (implies (and (thread-by-id id tt)
                (equal (thread-id new-thread) id))
           (equal (thread-by-id id (replace-thread-table-entry (thread-by-id id tt)
                                                               new-thread tt))
                  new-thread)))

(defthm thread-id-thread
  (implies (not thread)
           (not (thread-id thread))))


<span class="comment">;; the problem is that id could be nil!! 
</span>
(defthm thread-exists?-implies-thread-exists?-2
  (implies (thread-by-id id tt)
           (thread-by-id id (replace-thread-table-entry 
                             (thread-by-id id tt)
                             (make-thread id pc cs s m md obj) tt))))


(in-theory (enable pushFrame0 popFrame))


(defthm thread-call-stack-pushFrame 
  (implies (and (thread-by-id (current-thread s) (thread-table s))
                (wff-thread-table (thread-table s))
                (equal (current-thread s) id))
           (equal (thread-call-stack 
                   (thread-by-id id
                                 (thread-table (pushFrame0 anyFrame s))))
                  (cons anyFrame (thread-call-stack (thread-by-id (current-thread s)
                                                                  (thread-table s)))))))


(defthm thread-call-stack-popFrame 
  (implies (and (thread-by-id (current-thread s) (thread-table s))
                (wff-thread-table (thread-table s))
                (equal (current-thread s) id))
           (equal (thread-call-stack 
                   (thread-by-id id
                                 (thread-table (popFrame s))))
                  (cdr (thread-call-stack (thread-by-id (current-thread s)
                                                        (thread-table s)))))))


(defthm thread-exists?-implies-thread-exists?-3
  (implies (and (thread-by-id (current-thread s) (thread-table s))
                (wff-thread-table (thread-table s))
                (equal (current-thread s) id))
           (thread-by-id id (thread-table 
                             (pushFrame0 anyFrame s)))))

(defthm thread-exists?-implies-thread-exists?-4
  (implies (and (thread-by-id (current-thread s) (thread-table s))
                (wff-thread-table (thread-table s))
                (equal (current-thread s) id))
           (thread-by-id id (thread-table (popFrame s)))))



(in-theory (disable popFrame pushFrame0))

(defthm call-stack-depth-property
   (<span class="keyword">let*</span> ((tid (current-thread s))
          (thd (thread-by-id tid (thread-table s)))
          (cs  (thread-call-stack thd)))
     (and (implies (equal tid -1) 
                   (equal (call-stack-depth s) 1))
          (implies (and (not (equal tid -1))
                        (not (current-thread-exists? s)))
                   (equal (call-stack-depth s) 1))
          (implies (and  (not (endp cs))
                         (not (equal tid -1)) <span class="comment">;; this is really annoying
</span>                         (wff-thread-table (thread-table s))
                         (current-thread-exists? s))
                   (equal (call-stack-depth (pushFrame0 anyFrame 
                                                        (popFrame s)))
                          (call-stack-depth s)))
          (implies (and (not (endp cs))
                        (not (equal tid -1))
                        (wff-thread-table (thread-table s))
                        (current-thread-exists? s))
                   (equal (call-stack-depth (popFrame s))
                          (- (call-stack-depth s) 1)))
          (implies (and (endp cs)
                        (not (equal tid -1))
                        (wff-thread-table (thread-table s))
                        (current-thread-exists? s))
                   (equal (call-stack-depth s)
                          2)))))


<span class="comment">;-----------------------
;
#| moved to jvm-loader.lisp
;; ----- start to prove load_class_only_change_class_table_error_flag_heap
|#</span>

(in-theory (disable env))
 
(defthm getClass_only_change_class_table_error_flag_heap
  (<span class="keyword">let</span> ((s1 (getClass classname s0)))
     (and    (equal (pc s1) (pc s0))
             (equal (current-thread s1) (current-thread s0))
             (equal (thread-table   s1) (thread-table s0))
             (equal (env            s1) (env          s0))
            ))) <span class="comment">;; need to find the measure for admit the load_class
</span>                <span class="comment">;; functions.
</span>

<span class="comment">;; has free variable in it.
</span>
<span class="comment">;; --- end of proving load_class_only_change
</span>(in-theory (disable getClass))


<span class="comment">;; --- start to prove find-handler does not change state ---
</span>
(in-theory (enable fatalError))
(defthm isSuperClass1-only-change-class-table-error-flag-heap
   (mv-let (assignable s1)
           (isSuperClass1 t1 t2 s0 seen)
           (<span class="keyword">declare</span> (ignore assignable))
     (and    (equal (pc s1) (pc s0))
             (equal (current-thread s1) (current-thread s0))
          <span class="comment">;; (equal (heap s1) (heap s0))
</span>             (equal (thread-table   s1) (thread-table s0))
          <span class="comment">;; (equal (class-table    s1) (class-table  s0))
</span>             (equal (env            s1) (env          s0))
          <span class="comment">;; (equal (error-flag     s1) (error-flag   s0))
</span>            )))
(in-theory (disable isSuperClass1))

<span class="comment">;; 
</span>

(defthm isAssignableTo-only-change-class-table-error-flag-heap
   (mv-let (assignable s1)
           (isAssignableTo t1 t2 s0)
           (<span class="keyword">declare</span> (ignore assignable))
     (and    (equal (pc s1) (pc s0))
             (equal (current-thread s1) (current-thread s0))
          <span class="comment">;; (equal (heap s1) (heap s0))
</span>             (equal (thread-table   s1) (thread-table s0))
          <span class="comment">;; (equal (class-table    s1) (class-table  s0))
</span>             (equal (env            s1) (env          s0))
          <span class="comment">;; (equal (error-flag     s1) (error-flag   s0))
</span>            )))



(in-theory (disable isAssignableTo))


 <span class="comment">;; --- start to prove resolveClassReference -----
</span>



(defthm load_array_class2-only-change-class-table-error-flag-heap
   (<span class="keyword">let</span> ((s1 (load_array_class2 base-type s0)))
     (and    (equal (pc s1) (pc s0))
             (equal (current-thread s1) (current-thread s0))
          <span class="comment">;; (equal (heap s1) (heap s0))
</span>             (equal (thread-table   s1) (thread-table s0))
          <span class="comment">;; (equal (class-table    s1) (class-table  s0))
</span>             (equal (env            s1) (env          s0))
          <span class="comment">;; (equal (error-flag     s1) (error-flag   s0))
</span>            )))
  <span class="comment">;; --- end of proving resolveClassReference ---- 
</span>(in-theory (disable load_array_class2))



(defthm load_array_class-only-change-class-table-error-flag-heap
   (<span class="keyword">let</span> ((s1 (load_array_class base-type s0)))
     (and    (equal (pc s1) (pc s0))
             (equal (current-thread s1) (current-thread s0))
          <span class="comment">;; (equal (heap s1) (heap s0))
</span>             (equal (thread-table   s1) (thread-table s0))
          <span class="comment">;; (equal (class-table    s1) (class-table  s0))
</span>             (equal (env            s1) (env          s0))
          <span class="comment">;; (equal (error-flag     s1) (error-flag   s0))
</span>            )))
  <span class="comment">;; --- end of proving resolveClassReference ---- 
</span>(in-theory (disable load_array_class))





(defthm resolveClassReference-only-change-class-table-error-flag-heap
   (<span class="keyword">let</span> ((s1 (resolveClassReference classname s0)))
     (and    (equal (pc s1) (pc s0))
             (equal (current-thread s1) (current-thread s0))
          <span class="comment">;; (equal (heap s1) (heap s0))
</span>             (equal (thread-table   s1) (thread-table s0))
          <span class="comment">;; (equal (class-table    s1) (class-table  s0))
</span>             (equal (env            s1) (env          s0))
          <span class="comment">;; (equal (error-flag     s1) (error-flag   s0))
</span>            )))
  <span class="comment">;; --- end of proving resolveClassReference ---- 
</span>(in-theory (disable resolveClassReference))



(defthm find_handler__only_change_class_table_error_flag_heap
   (mv-let (handler s1)
           (find-handler handlers exception-type ip-offset s0)
           (<span class="keyword">declare</span> (ignore handler))
     (and    (equal (pc s1) (pc s0))
             (equal (current-thread s1) (current-thread s0))
          <span class="comment">;; (equal (heap s1) (heap s0))
</span>             (equal (thread-table   s1) (thread-table s0))
          <span class="comment">;; (equal (class-table    s1) (class-table  s0))
</span>             (equal (env            s1) (env          s0))
          <span class="comment">;; (equal (error-flag     s1) (error-flag   s0))
</span>            )))
  <span class="comment">;; has free variable in it.
</span>
<span class="comment">;;----- end of proving find-handler does not change state
</span>(in-theory (disable find-handler))

<span class="comment">;;;; Mon Dec 29 23:17:03 2003 chose not to talk about current-thread-exists?
;;;; only talk about thread-by-id ....
;;;; but keep the following!! 
</span>
(defthm current-thread-exists-equal-2
  (<span class="keyword">let</span> ((s1 (make-state pc  (current-thread s0) hp (thread-table s0) cl env ef aux)))
    (equal (current-thread-exists? s1)
           (current-thread-exists? s0)))
  <span class="builtin">:hints</span> ((<span class="string">"Goal"</span> <span class="builtin">:in-theory</span> (enable current-thread-exists?))))



(defthm current-thread-exists?-getClass-not-changed
  (equal (current-thread-exists? (getClass classname s0))
         (current-thread-exists? s0))
  <span class="builtin">:hints</span> ((<span class="string">"Goal"</span> <span class="builtin">:in-theory</span> (enable current-thread-exists?))))



(defthm current-thread-exists?-find-handler-not-changed
  (mv-let (handler s1)
           (find-handler handlers exception-type ip-offset s0)
           (<span class="keyword">declare</span> (ignore handler))
  (equal (current-thread-exists? s1)
         (current-thread-exists? s0)))
  <span class="builtin">:hints</span> ((<span class="string">"Goal"</span> <span class="builtin">:in-theory</span> (enable current-thread-exists?))))



(defthm call-stack-depth-exists-equal-2
  (<span class="keyword">let</span> ((s1 (make-state pc  (current-thread s0) hp (thread-table s0) cl env ef aux)))
    (equal (call-stack-depth s1)
           (call-stack-depth s0)))
  <span class="builtin">:hints</span> ((<span class="string">"Goal"</span> <span class="builtin">:in-theory</span> (enable call-stack-depth))))


(defthm call-stack-depth-getClass-not-changed
  (equal (call-stack-depth (getClass classname s0))
         (call-stack-depth  s0))
  <span class="builtin">:hints</span> ((<span class="string">"Goal"</span> <span class="builtin">:in-theory</span> (enable call-stack-depth))))


(defthm call-stack-depth-find-handler-not-changed
  (mv-let (handler s1)
           (find-handler handlers exception-type ip-offset s0)
           (<span class="keyword">declare</span> (ignore handler))
  (equal (call-stack-depth s1)
         (call-stack-depth  s0)))
  <span class="builtin">:hints</span> ((<span class="string">"Goal"</span> <span class="builtin">:in-theory</span> (enable call-stack-depth))))
  

(defthm current-frame-equal-2
  (<span class="keyword">let</span> ((s1 (make-state pc  (current-thread s0) hp (thread-table s0) cl env ef aux)))
    (equal (current-frame s1)
           (current-frame s0))))


(defthm current-frame-getClass-not-changed
  (equal (current-frame (getClass classname s0))
         (current-frame s0)))

(defthm current-frame-find-handler-not-changed
  (mv-let (handler s1)
          (find-handler handlers exception-type ip-offset s0)
          (<span class="keyword">declare</span> (ignore handler))
  (equal (current-frame s1)
         (current-frame s0)))
  <span class="builtin">:hints</span> ((<span class="string">"Goal"</span> <span class="builtin">:in-theory</span> (enable current-frame))))
  



<span class="comment">;; this are used for talking about the sync-obj-ref 
</span>
(in-theory (enable current-frame))
(defthm current-frame-pushFrame0-simplify-to
  (implies (and (wff-thread-table (thread-table anyS))
                (current-thread-exists? anyS))
           (equal (current-frame (pushFrame0 anyFrame anyS))
                  anyFrame)))
                         
(in-theory (disable current-frame))

<span class="comment">;;----
</span>
(defthm update-obj-monitor-preserve-wff-thread-table-thread-exist-current-th
  (<span class="keyword">let</span> ((s1 (update-obj-monitor obj-ref m s0)))
    (and (equal (wff-thread-table (thread-table s1))
                (wff-thread-table (thread-table s0)))
         (iff   (current-thread-exists? s1)
                (current-thread-exists? s0))
         (equal (call-stack-depth s1)
                (call-stack-depth s0))
         (equal (consp (thread-call-stack (thread-by-id x (thread-table s1))))
                (consp (thread-call-stack (thread-by-id x (thread-table s0)))))
         (equal (current-thread s1) 
                (current-thread s0)))))

(in-theory (disable update-obj-monitor))


(defthm thread-by-id-replace-thread-table-entry-not-equal-equal
  (implies (and (not (equal (thread-id old) x))
                (not (equal (thread-id new) x)))
  (equal (thread-by-id x 
            (replace-thread-table-entry old
                                        new 
                                        tt))
         (thread-by-id x tt))))

<span class="comment">;; (defthm thread-by-id-replace-thread-table-entry-thread-exists?
;;   (implies (and (not (equal (thread-id old) x))
;;                 (not (equal (thread-id new) x)))
;;   (equal (thread-exists? x
;;             (replace-thread-table-entry old
;;                                         new 
;;                                         tt))
;;          (thread-exists? x tt)))
;;   :hints (("Goal" :in-theory (enable thread-exists?))))
</span>
          

<span class="comment">;; (defthm current-thread-exists-replace-thread-table-entry
;;   (let* ((th (current-thread s0))
;;          (tt (thread-table s0))
;;          (s1 (make-state pc th hp
;;                          (replace-thread-table-entry 
;;                           (thread-by-id id tt)
;;                           (make-thread id anySavePC anyCallStack anyState
;;                                       anyMonitorRef anyMonitorDepth
;;                                       anyThreadRef)
;;                           tt)
;;                         cl env ef aux)))
;;     (implies (and (not (equal th id))
;;                   (wff-thread-table-strong1 tt)
;;                   (thread-exists? id tt))
;;              (equal (current-thread-exists? s1)
;;                     (current-thread-exists? s0))))
;;   :hints (("Goal" :in-theory (enable current-thread-exists?))))
</span>


(defthm resume-thread-preserve-wff-thread-table-thread-exist-current-th
  (<span class="keyword">let</span> ((s1 (resumeThread id s0)))
    (and (equal (wff-thread-table (thread-table s1))
                (wff-thread-table (thread-table s0)))
         (iff   (current-thread-exists? s1)
                (current-thread-exists? s0))
         (equal (call-stack-depth s1)
                (call-stack-depth s0))
         (equal (consp (thread-call-stack (thread-by-id x (thread-table s1))))
                (consp (thread-call-stack (thread-by-id x (thread-table s0)))))
         (equal (current-thread s1) 
                (current-thread s0))))
  <span class="builtin">:hints</span> ((<span class="string">"Goal"</span> <span class="builtin">:cases</span> ((equal x id)))))


(in-theory (disable resumeThread))


(in-theory (disable make-monitor dequeue-h OBJ-MONITOR-BY-REF mqueue))

(defthm removeMonitorWait-preserve-wff-thread-table-thread-exist-current-th
  (<span class="keyword">let</span> ((s1 (removeMonitorWait obj-ref s0)))
    (and (equal (wff-thread-table (thread-table s1))
                (wff-thread-table (thread-table s0)))
         (iff   (current-thread-exists? s1)
                (current-thread-exists? s0))
         (equal (call-stack-depth s1)
                (call-stack-depth s0))
         (equal (consp (thread-call-stack (thread-by-id x (thread-table s1))))
                (consp (thread-call-stack (thread-by-id x (thread-table s0)))))
         (equal (current-thread s1) 
                (current-thread s0))))
  <span class="builtin">:hints</span> ((<span class="string">"Goal"</span> <span class="builtin">:cases</span> ((equal x (DEQUEUE-H (MQUEUE (OBJ-MONITOR-BY-REF OBJ-REF S0))))))))


(in-theory (disable removeMonitorWait))



(defthm monitorExit-preserve-wff-thread-table-thread-exist-current-th
   (mv-let (status exception-type s1)
           (monitorExit any-obj-ref s0)
           (<span class="keyword">declare</span> (ignore status exception-type))
           (and (equal (wff-thread-table (thread-table s1))
                       (wff-thread-table (thread-table s0)))
                (iff   (current-thread-exists? s1)
                       (current-thread-exists? s0))
                (equal (call-stack-depth s1)
                       (call-stack-depth s0))
                (equal (consp (thread-call-stack (thread-by-id x (thread-table s1))))
                       (consp (thread-call-stack (thread-by-id x (thread-table s0)))))
                (equal (current-thread s1) 
                       (current-thread s0)))))


(in-theory (disable monitorExit))


<span class="comment">;; (defthm wff-call-frame-make-frame
;;   (wff-call-frame (make-frame rpc os lc mp sf)))
</span>
<span class="comment">;;; not true. in the current Mon Dec 29 23:28:55 2003 wff-call-frame we also
;;; assert wff-formed method-ptr
</span>
(in-theory (disable make-frame return-pc operand-stack locals method-ptr sync-obj-ref))


(defthm sync-obj-ref-frame-set-sync
  (equal (sync-obj-ref (frame-set-sync-obj-ref x frame))
         x))

(in-theory (disable frame-set-sync-obj-ref))


(defthm lemma-admission 
  (implies (and  (WFF-THREAD-TABLE (THREAD-TABLE S))
                 (NOT (EQUAL (current-thread s) -1))
                 (CURRENT-THREAD-EXISTS? S)
                 (CONSP (THREAD-CALL-STACK (THREAD-BY-ID (CURRENT-THREAD S)
                                                            (THREAD-TABLE S)))))
           (EQUAL
            (CALL-STACK-DEPTH
             (PUSHFRAME0
              (FRAME-SET-SYNC-OBJ-REF -1 (CURRENT-FRAME S))
              (POPFRAME (MV-NTH 2
                                (MONITOREXIT (SYNC-OBJ-REF (CURRENT-FRAME S))
                                             S)))))
            (CALL-STACK-DEPTH S)))
  <span class="builtin">:hints</span> ((<span class="string">"Goal"</span> <span class="builtin">:in-theory</span> (disable call-stack-depth))))





(<span class="keyword">defmacro</span> <span class="function-name">m6assert</span> (s cond msg <span class="type">&amp;rest</span> action)
  `(<span class="keyword">if</span> (not ,cond)
       (fatalError ,msg ,s)
     ,@action))


(<span class="keyword">defmacro</span> <span class="function-name">m6assert2</span> (s cond msg <span class="type">&amp;rest</span> action)
  `(<span class="keyword">if</span> (not ,cond)
       (mv nil (fatalError ,msg ,s))
           ,@action))


(<span class="keyword">defun</span> <span class="function-name">invariant-exception-handling-1</span> (s)
  (and (wff-thread-table (thread-table s))
       (current-thread-exists? s)
       (not (equal (current-thread s) -1))
       (not (endp (thread-call-stack (thread-by-id (current-thread s)
                                                   (thread-table s)))))))


(<span class="keyword">defun</span> <span class="function-name">invariant-exception-handling-2</span> (s)
  (and (wff-thread-table (thread-table s))
       (current-thread-exists? s)
       (not (equal (current-thread s) -1))))




<span class="comment">;; however this invariant is not true when we allow unwinding across the custom
;; code.
</span>(<span class="keyword">defun</span> <span class="function-name">release-lock-invariant</span> (s1 s0)
  (and (equal (wff-thread-table (thread-table s1))
              (wff-thread-table (thread-table s0)))
       (iff   (current-thread-exists? s1)
              (current-thread-exists? s0))
       (equal (call-stack-depth s1)
              (call-stack-depth s0))
       (equal (consp (thread-call-stack (thread-by-id (current-thread s1) (thread-table s1))))
              (consp (thread-call-stack (thread-by-id (current-thread s0) (thread-table s0)))))
       (equal (current-thread s1) 
              (current-thread s0))))









(in-theory (disable call-stack-depth))

(in-theory (disable  method-code code-handlers instance-class-table
                     DEREF-METHOD current-method-ptr))


(defthm current-frame-pushFrame0-thread-exists
  (implies (and  (current-thread-exists? s)
                 (wff-thread-table (thread-table s)))
           (equal (current-frame (pushFrame0 frame s))
                  frame))
  <span class="builtin">:hints</span> ((<span class="string">"Goal"</span> <span class="builtin">:in-theory</span> (enable pushFrame0 current-frame current-thread-exists?))))

(defthm current-thread-exists?-pushFrame
  (implies (and (current-thread-exists? s)
                (wff-thread-table (thread-table s)))
           (current-thread-exists? (pushFrame0 any s)))
  <span class="builtin">:hints</span> ((<span class="string">"Goal"</span> <span class="builtin">:in-theory</span> (enable pushFrame0 current-thread-exists?))))

(defthm current-thread-exists?-popFrame
  (implies (and (current-thread-exists? s)
                (wff-thread-table (thread-table s)))
           (current-thread-exists? (popFrame s)))
  <span class="builtin">:hints</span> ((<span class="string">"Goal"</span> <span class="builtin">:in-theory</span> (enable popFrame current-thread-exists?))))




(in-theory (enable frame-set-sync-obj-ref))
(in-theory (disable current-thread-exists?))





(acl2::mutual-recursion  
 (<span class="keyword">defun</span> <span class="function-name">release-lock-on-sync-obj</span> (s)
  (<span class="keyword">declare</span> (xargs <span class="builtin">:measure</span> (exception-measure 1 s)))
  <span class="comment">;; guard section. 
</span>  (m6assert2 s (invariant-exception-handling-1 s) 
             <span class="string">"release-lock-on-sync-obj violates invariante"</span> 
             (<span class="keyword">let*</span> ((current-frame (current-frame s))
                    (sync-obj-ref (sync-obj-ref current-frame)))
               (<span class="keyword">if</span> (equal sync-obj-ref -1)
                   (mv nil s)
                 (mv-let (status exception-type s1)
                         (monitorExit sync-obj-ref s)
                         (<span class="keyword">if</span> (equal status 'MonitorStatusError)
                             (mv t (raise-exception exception-type 
                                                    (pushFrame0 
                                                     (frame-set-sync-obj-ref -1 current-frame)
                                                     (popFrame s1))))
                           (mv nil s1)))))))
                 

<span class="comment">;; in cldc there is no finally block. preverify have removed the jsr
;; instruction by copying the finally block to the both normal execution path
;; and exception execution path. 
</span>
(<span class="keyword">defun</span> <span class="function-name">throw-exception1</span> (obj-ref s) 
  (<span class="keyword">declare</span> (xargs <span class="builtin">:measure</span> (exception-measure 2 s)))
  (m6assert s (invariant-exception-handling-2 s) 
            <span class="string">"throw-exception invariant violated"</span>
  (<span class="keyword">let*</span> ((tid (current-thread s))
         (curthread (thread-by-id tid (thread-table s)))
         (call-stack (thread-call-stack curthread)))
    (<span class="keyword">if</span> (endp call-stack) <span class="comment">;; no more call frames, uncaught exception.
</span>        (throw-exception2 obj-ref s)
      (<span class="keyword">let*</span> ((method-ptr (current-method-ptr s))
             (cur-method (deref-method method-ptr 
                                       (instance-class-table s)))
             (exception-type (obj-type (deref obj-ref (heap s))))
             (ip-offset  (pc s))
             (handlers   (code-handlers (method-code cur-method))))
        (<span class="keyword">if</span> (equal handlers nil)
            (<span class="keyword">if</span> (equal method-ptr (RunCustomCode-Method-ptr))
                <span class="comment">;; handle exception if exception is raised within a internal
</span>                <span class="comment">;; function call. define a way how to propogate the exception
</span>                <span class="comment">;; across the custom-code. (custom code may call many java
</span>                <span class="comment">;; mehtods and the java method may raise exception and not
</span>                <span class="comment">;; catching them.
</span>                
                <span class="comment">;; trival implementation now, not  clear at all to myself now. 
</span>
                (prog2$ 
                 (acl2::debug-print
                          <span class="string">"trying to unwind past a customcode callframe!~%Stack Trace:~p0~%~%"</span>
                           (thread-call-stack (thread-by-id (current-thread s) (thread-table s))))
                 (fatalError <span class="string">"trying to unwind past a customcode --not implemented yet"</span> s))

              (mv-let (return-directly s1)
                      (release-lock-on-sync-obj  s)<span class="comment">;; strange?? 
</span>                      (m6assert s1 (release-lock-invariant s1 s) 
                                <span class="string">"should always be true release-lock-invariant"</span>
                                (<span class="keyword">if</span> return-directly 
                                    s1
                                  <span class="comment">;; BEFORE we can pop frame, we need to release the monitor if necessary. 
</span>                                  (throw-exception1 obj-ref (popFrame s1))))))
          (mv-let (thehandler s1)
                  (find-handler handlers exception-type ip-offset s)
                  (prog2$ (acl2::debug-print 
                           <span class="string">"exception ~p0 is thrown~% find handler ~p1 in current frame!~%"</span> 
                           exception-type thehandler)
                  (<span class="keyword">if</span> (not (no-fatal-error? s1))
                      s1
                    (<span class="keyword">if</span> (not (equal  theHandler nil))
                      <span class="comment">;; fake a frame and call exception handler.
</span>                      (<span class="keyword">let*</span> ((old-frame (current-frame s1))
                             (new-frame (frame-set-operand-stack
                                         (list obj-ref)
                                         old-frame)))
                        (mv-let (return-directly s2)
                                (release-lock-on-sync-obj s1)
                                (m6assert s1 (release-lock-invariant s2 s1) 
                                          <span class="string">"should always be true release-lock-invariant"</span>
                                          (<span class="keyword">if</span> (not (no-fatal-error? s2))
                                              s2
                                            (<span class="keyword">if</span> return-directly 
                                                s2
                                              (state-set-pc (handler-entry-point theHandler)
                                                            (pushFrame0 new-frame 
                                                                        (popFrame s2))))))))
                      
                      (mv-let (return-directly s2)
                              (release-lock-on-sync-obj s1)
                              (m6assert s1 (release-lock-invariant s2 s1) 
                                        <span class="string">"should always be true release-lock-invariant"</span>
                              (<span class="keyword">if</span> (not (no-fatal-error? s2))
                                  s2
                                (<span class="keyword">if</span> return-directly 
                                    s2
                                  (throw-exception1 obj-ref 
                                                    (popFrame s2))))))))))))))))
                
                
<span class="comment">;; precondition is obj-ref is always a throwable_instance.      
</span>
(<span class="keyword">defun</span> <span class="function-name">throw-exception</span> (obj-ref s)
  (<span class="keyword">declare</span> (xargs <span class="builtin">:measure</span> (exception-measure 3 s)))
  (<span class="keyword">let*</span> ((current-thread (current-thread s)))
    (<span class="keyword">if</span> (equal current-thread -1)
        (<span class="keyword">let</span> ((msg-str-ref (getExceptionMessage obj-ref s)))
          (<span class="keyword">if</span> (equal msg-str-ref -1)
              (ERROR_THROW -1 s)
            (fatalError (JavaString-to-ACL2-str msg-str-ref s) s)))
      (throw-exception1 obj-ref s)))) <span class="comment">;; unroll call frames and fake call frames
</span>                                   <span class="comment">;; to handle exception?
</span>       

         
<span class="comment">;; the assumption is that "java.lang.Throwable" is loaded.
</span>(<span class="keyword">defun</span> <span class="function-name">raise-exception1</span> (classname s)
  (<span class="keyword">declare</span> (xargs <span class="builtin">:measure</span> (exception-measure 4 s)))
  (mv-let (new-addr s1)
          (new-instance classname s)
          (throw-exception new-addr s1)))

<span class="comment">;;
;; in our implementation no-fatal-error? will ensure the class is loaded. 
;; we will prove this property. 
;; class not found will be a fatalError.
;; 
</span>
(<span class="keyword">defun</span> <span class="function-name">raise-exception</span> (classname s)
  (<span class="keyword">declare</span> (xargs <span class="builtin">:measure</span> (exception-measure 5 s)))
  (<span class="keyword">let</span> ((s1 (getClass classname s)))
    (<span class="keyword">if</span> (no-fatal-error? s1)
        (raise-exception1 classname s1)
      (alertUser 
       <span class="string">"raise-excecption: fatalError ocurred in getClass, can't find exception class indicated."</span> 
       s1)))))























</pre>
  </body>
</html>
