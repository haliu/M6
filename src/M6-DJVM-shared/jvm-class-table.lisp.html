<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01//EN">
<!-- Created by htmlize-1.16 in css mode. -->
<html>
  <head>
    <title>jvm-class-table.lisp</title>
    <style type="text/css">
    <!--
      body {
        color: #f5deb3;
        background-color: #000000;
      }
      .builtin {
        /* font-lock-builtin-face */
        color: #b0c4de;
      }
      .comment {
        /* font-lock-comment-face */
        color: #ff7f24;
      }
      .function-name {
        /* font-lock-function-name-face */
        color: #87cefa;
      }
      .keyword {
        /* font-lock-keyword-face */
        color: #00ffff;
      }
      .string {
        /* font-lock-string-face */
        color: #ffa07a;
      }
      .variable-name {
        /* font-lock-variable-name-face */
        color: #eedd82;
      }
      a {
        color: inherit;
        background-color: inherit;
        font: inherit;
        text-decoration: inherit;
      }
      a:hover {
        text-decoration: underline;
      }
    -->
    </style>
  </head>
  <body>
    <pre>
(<span class="keyword">in-package</span> <span class="string">"JVM"</span>)
(acl2::set-verify-guards-eagerness 2)
(include-book <span class="string"><a href="jvm-env.lisp.html">"../M6-DJVM-shared/jvm-env"</a></span>)
(include-book <span class="string"><a href="jvm-class-table-test-data.lisp.html">"../M6-DJVM-shared/jvm-class-table-test-data"</a></span>)
<span class="comment">;----------------------------------------------------------------------
</span>
(include-book <span class="string">"ordinals/e0-ordinal"</span> <span class="builtin">:dir</span> <span class="builtin">:system</span>)
(set-well-founded-relation e0-ord-&lt;)

(<span class="keyword">defun</span> <span class="function-name">make-class-table</span> (instance-class-table array-class-table)
  (list 'class-table 
        (cons 'instance-class-table instance-class-table)
        (cons 'array-class-table array-class-table)))

(<span class="keyword">defun</span> <span class="function-name">wff-class-table</span> (cl)
  (<span class="keyword">declare</span> (xargs <span class="builtin">:verify-guards</span> t))
  (and (equal (len cl) 3)
       (true-listp cl)
       (consp (nth 1 cl))
       (consp (nth 2 cl))
       (equal (car (nth 1 cl)) 'instance-class-table)
       (equal (car (nth 2 cl)) 'array-class-table)))


(local 
 (defthm wff-class-table-test
   (wff-class-table *test.classtable*)))

<span class="comment">;----------------------------------------------------------------------
</span>
(<span class="keyword">defun</span> <span class="function-name">make-runtime-class-rep</span> (classname super constpool fields methods
                               interfaces static-fields status accessflags
                               init-thread-id class-ref)
  (list 'class classname  <span class="comment">;; just names 
</span>               super      <span class="comment">;; name of the super
</span>               (cons 'constant_pool constpool)  <span class="comment">;; runtime representation
</span>               (cons 'fields  fields)           <span class="comment">;; non static fields 
</span>               (cons 'methods methods)          <span class="comment">;; list of methods 
</span>               (cons 'interfaces interfaces)    <span class="comment">;; interfaces 
</span>               (cons 'static-fields static-fields)   
               (cons 'status status)            <span class="comment">;; 'LOADED, 'INITIALIZED, not worry about
</span>               (cons 'access-flags accessflags)    <span class="comment">;;
</span>               (cons 'init-thread init-thread-id)  <span class="comment">;;
</span>               (cons 'class-ref class-ref)))


<span class="comment">#| KVM status bit
 #define CLASS_RAW       0 /* this value must be 0 */ ;; implicit in our STATE REP
 #define CLASS_LOADING   1                            ;;    
 #define CLASS_LOADED    2
 #define CLASS_LINKED    3
 #define CLASS_VERIFIED  4
 #define CLASS_READY     5
 #define CLASS_ERROR    -1
|#</span>

(<span class="keyword">defconst</span> <span class="variable-name">*class_raw*</span>        0) <span class="comment">;; not neccessary
</span>(<span class="keyword">defconst</span> <span class="variable-name">*class_loading*</span>    1) <span class="comment">;; not necessary
</span>(<span class="keyword">defconst</span> <span class="variable-name">*class_loaded*</span>     2) <span class="comment">;;
</span>(<span class="keyword">defconst</span> <span class="variable-name">*class_linked*</span>     3) <span class="comment">;;
</span>(<span class="keyword">defconst</span> <span class="variable-name">*class_verified*</span>   4) <span class="comment">;;
</span>(<span class="keyword">defconst</span> <span class="variable-name">*class_ready*</span>      5) <span class="comment">;;
</span>(<span class="keyword">defconst</span> <span class="variable-name">*class_error*</span>     -1)



(<span class="keyword">defun</span> <span class="function-name">wff-class-rep</span> (class-rep)
  (<span class="keyword">declare</span> (xargs <span class="builtin">:verify-guards</span> t))
  (and (true-listp class-rep)
       (equal (len class-rep) 12)
       (equal (car class-rep) 'class) 
       (consp (nth 3 class-rep))
       (consp (nth 4 class-rep))
       (consp (nth 5 class-rep))
       (consp (nth 6 class-rep))
       (consp (nth 7 class-rep))
       (consp (nth 8 class-rep))
       (consp (nth 9 class-rep))
       (consp (nth 10 class-rep))
       (consp (nth 11 class-rep))
       <span class="comment">;; may need to be strengthened.  09/08/03 
</span>       (integerp (cdr (nth 11 class-rep)))
       (true-listp (cdr (nth 3 class-rep)))
       (true-listp (cdr (nth 4 class-rep)))
       (true-listp (cdr (nth 5 class-rep)))
       (true-listp (cdr (nth 6 class-rep)))
       (true-listp (cdr (nth 7 class-rep)))
     <span class="comment">; (true-listp (cdr (nth 8 class-rep))) 
</span>       <span class="comment">;; 10/27/03  fixed after having a concrete state.
</span>       (true-listp (cdr (nth 9 class-rep)))))




(<span class="keyword">defun</span> <span class="function-name">wff-instance-class-table</span> (icl)
  (<span class="keyword">declare</span> (xargs <span class="builtin">:verify-guards</span> t))
  (<span class="keyword">if</span> (not (consp icl)) t
    (and (wff-class-rep (car icl))
         (wff-instance-class-table (cdr icl)))))

(local 
 (defthm wff-instance-class-table-test
   (wff-instance-class-table (cdr (nth 1 *test.classtable*)))))

<span class="comment">;----------------------------------------------------------------------
</span>


(<span class="keyword">defun</span> <span class="function-name">classname</span> (crep)
  (<span class="keyword">declare</span> (xargs <span class="builtin">:guard</span> (wff-class-rep crep)))
  (nth 1 crep))

(<span class="keyword">defun</span> <span class="function-name">class-ref</span> (crep)
  (<span class="keyword">declare</span> (xargs <span class="builtin">:guard</span> (wff-class-rep crep)))
  (cdr (nth 11 crep)))

(<span class="keyword">defun</span> <span class="function-name">class-accessflags</span> (crep)
  (<span class="keyword">declare</span> (xargs <span class="builtin">:guard</span> (wff-class-rep crep)))
  (cdr (nth 9 crep)))

(<span class="keyword">defun</span> <span class="function-name">constantpool</span> (crep)
  (<span class="keyword">declare</span> (xargs <span class="builtin">:guard</span> (wff-class-rep crep)))
  (cdr (nth 3 crep)))

(<span class="keyword">defun</span> <span class="function-name">super</span> (crep)
  (<span class="keyword">declare</span> (xargs <span class="builtin">:guard</span> (wff-class-rep crep)))
  (nth 2 crep))

(<span class="keyword">defun</span> <span class="function-name">interfaces</span> (crep)
  (<span class="keyword">declare</span> (xargs <span class="builtin">:guard</span> (wff-class-rep crep)))
  (cdr (nth 6 crep)))


(<span class="keyword">defun</span> <span class="function-name">fields</span>  (crep)    
  (<span class="keyword">declare</span> (xargs <span class="builtin">:guard</span> (wff-class-rep crep)))
  (cdr (nth 4 crep)))

(<span class="keyword">defun</span> <span class="function-name">methods</span>  (crep)    
  (<span class="keyword">declare</span> (xargs <span class="builtin">:guard</span> (wff-class-rep crep)))
  (cdr (nth 5 crep)))

(<span class="keyword">defun</span> <span class="function-name">static-fields</span>  (crep)    
  (<span class="keyword">declare</span> (xargs <span class="builtin">:guard</span> (wff-class-rep crep)))
  (cdr (nth 7 crep)))


(<span class="keyword">defun</span> <span class="function-name">class-status</span> (crep)
  (<span class="keyword">declare</span> (xargs <span class="builtin">:guard</span> (wff-class-rep crep)))
  (cdr (nth 8 crep)))


(<span class="keyword">defun</span> <span class="function-name">init-thread-id</span> (crep)
  (<span class="keyword">declare</span> (xargs <span class="builtin">:guard</span> (wff-class-rep crep)))
  (cdr (nth 10 crep)))

<span class="comment">;----------------------------------------------------------------------
</span>

(<span class="keyword">defun</span> <span class="function-name">class-rep-set-classname</span> (n crep)
  (<span class="keyword">declare</span> (xargs <span class="builtin">:guard</span> (wff-class-rep crep)))
  (make-runtime-class-rep 
      n
      (super     crep)
      (constantpool crep)
      (fields       crep)
      (methods      crep)
      (interfaces   crep)
      (static-fields crep)
      (class-status  crep)
      (class-accessflags crep)
      (init-thread-id    crep)
      (class-ref         crep)))

(<span class="keyword">defun</span> <span class="function-name">class-rep-set-super</span> (super crep)
  (<span class="keyword">declare</span> (xargs <span class="builtin">:guard</span> (wff-class-rep crep)))
  (make-runtime-class-rep 
      (classname crep)
      super
      (constantpool crep)
      (fields       crep)
      (methods      crep)
      (interfaces   crep)
      (static-fields crep)
      (class-status  crep)
      (class-accessflags crep)
      (init-thread-id    crep)
      (class-ref         crep)))

(<span class="keyword">defun</span> <span class="function-name">class-rep-set-constantpool</span> (cp crep)
  (<span class="keyword">declare</span> (xargs <span class="builtin">:guard</span> (wff-class-rep crep)))
  (make-runtime-class-rep 
      (classname crep)
      (super     crep)
      cp
      (fields       crep)
      (methods      crep)
      (interfaces   crep)
      (static-fields crep)
      (class-status  crep)
      (class-accessflags crep)
      (init-thread-id    crep)
      (class-ref         crep)))

(<span class="keyword">defun</span> <span class="function-name">class-rep-set-fields</span> (fs crep)
  (<span class="keyword">declare</span> (xargs <span class="builtin">:guard</span> (wff-class-rep crep)))
  (make-runtime-class-rep 
      (classname crep)
      (super     crep)
      (constantpool crep)
      fs
      (methods      crep)
      (interfaces   crep)
      (static-fields crep)
      (class-status  crep)
      (class-accessflags crep)
      (init-thread-id    crep)
      (class-ref         crep)))

(<span class="keyword">defun</span> <span class="function-name">class-rep-set-methods</span> (ms crep)
  (<span class="keyword">declare</span> (xargs <span class="builtin">:guard</span> (wff-class-rep crep)))
  (make-runtime-class-rep 
      (classname crep)
      (super     crep)
      (constantpool crep)
      (fields       crep)
      ms
      (interfaces   crep)
      (static-fields crep)
      (class-status  crep)
      (class-accessflags crep)
      (init-thread-id    crep)
      (class-ref         crep)))

(<span class="keyword">defun</span> <span class="function-name">class-rep-set-interfaces</span> (is crep)
  (<span class="keyword">declare</span> (xargs <span class="builtin">:guard</span> (wff-class-rep crep)))
  (make-runtime-class-rep 
      (classname crep)
      (super     crep)
      (constantpool crep)
      (fields       crep)
      (methods      crep)
      is
      (static-fields crep)
      (class-status  crep)
      (class-accessflags crep)
      (init-thread-id    crep)
      (class-ref         crep)))

(<span class="keyword">defun</span> <span class="function-name">class-rep-set-static-fields</span> (sfs crep)
  (<span class="keyword">declare</span> (xargs <span class="builtin">:guard</span> (wff-class-rep crep)))
  (make-runtime-class-rep 
      (classname crep)
      (super     crep)
      (constantpool crep)
      (fields       crep)
      (methods      crep)
      (interfaces   crep)
      sfs
      (class-status  crep)
      (class-accessflags crep)
      (init-thread-id    crep)
      (class-ref         crep)))

(<span class="keyword">defun</span> <span class="function-name">class-rep-set-class-status</span> (cs crep)
  (<span class="keyword">declare</span> (xargs <span class="builtin">:guard</span> (wff-class-rep crep)))
  (make-runtime-class-rep 
      (classname crep)
      (super     crep)
      (constantpool crep)
      (fields       crep)
      (methods      crep)
      (interfaces   crep)
      (static-fields crep)
      cs
      (class-accessflags crep)
      (init-thread-id    crep)
      (class-ref         crep)))

(<span class="keyword">defun</span> <span class="function-name">class-rep-set-accessflags</span> (afs crep)
  (<span class="keyword">declare</span> (xargs <span class="builtin">:guard</span> (wff-class-rep crep)))
  (make-runtime-class-rep 
      (classname crep)
      (super     crep)
      (constantpool crep)
      (fields       crep)
      (methods      crep)
      (interfaces   crep)
      (static-fields crep)
      (class-status  crep)
      afs
      (init-thread-id    crep)
      (class-ref         crep)))

(<span class="keyword">defun</span> <span class="function-name">class-rep-set-init-thread-id</span> (id crep)
  (<span class="keyword">declare</span> (xargs <span class="builtin">:guard</span> (wff-class-rep crep)))
  (make-runtime-class-rep 
      (classname crep)
      (super     crep)
      (constantpool crep)
      (fields       crep)
      (methods      crep)
      (interfaces   crep)
      (static-fields crep)
      (class-status  crep)
      (class-accessflags crep)
      id
      (class-ref         crep)))

(<span class="keyword">defun</span> <span class="function-name">class-rep-set-class-ref</span> (cref crep)
  (<span class="keyword">declare</span> (xargs <span class="builtin">:guard</span> (wff-class-rep crep)))
  (make-runtime-class-rep 
      (classname crep)
      (super     crep)
      (constantpool crep)
      (fields       crep)
      (methods      crep)
      (interfaces   crep)
      (static-fields crep)
      (class-status  crep)
      (class-accessflags crep)
      (init-thread-id    crep)
      cref))

<span class="comment">;----------------------------------------------------------------------
</span>


(defthm make-runtime-class-rep-accessor 
  (mylet* ((s (make-runtime-class-rep cn sn cp fs ms ifs sfs cs ac id crf)))
  (and (equal (classname s) cn)
       (equal (super s) sn)
       (equal (constantpool s) cp)
       (equal (fields s) fs)
       (equal (methods s) ms)
       (equal (interfaces s) ifs)
       (equal (static-fields s) sfs)
       (equal (class-status s) cs)
       (equal (class-accessflags s) ac)
       (equal (init-thread-id s) id)
       (equal (class-ref s) crf)))
  <span class="builtin">:hints</span> ((<span class="string">"Goal"</span> <span class="builtin">:in-theory</span> (enable make-runtime-class-rep))))



<span class="comment">;----------------------------------------------------------------------
</span>
(<span class="keyword">defun</span> <span class="function-name">replace-class-table-entry</span> (old-class-rep new-class-rep old-class-table)
  (<span class="keyword">declare</span> (xargs <span class="builtin">:guard</span> t))
  (<span class="keyword">if</span> (not (consp old-class-table))
      nil
    (<span class="keyword">if</span> (equal (car old-class-table) old-class-rep)
        (cons new-class-rep (cdr old-class-table))
      (cons (car old-class-table)
            (replace-class-table-entry old-class-rep new-class-rep (cdr
                                                                    old-class-table))))))


<span class="comment">;----------------------------------------------------------------------
</span>
(<span class="keyword">defun</span> <span class="function-name">wff-string-cp-entry</span> (cp-entry)
  (<span class="keyword">declare</span> (xargs <span class="builtin">:verify-guards</span> t))
  (and (consp cp-entry)
       (equal (len cp-entry) 2)
       (equal (car cp-entry) 'STRING)
       (integerp (cadr cp-entry))))


(<span class="keyword">defun</span> <span class="function-name">wff-int-cp-entry</span> (cp-entry)
  (<span class="keyword">declare</span> (xargs <span class="builtin">:verify-guards</span> t))
  (and (consp cp-entry)
       (equal (len cp-entry) 2)
       (equal (car cp-entry) 'INT)
       (int32p (cadr cp-entry))))

(<span class="keyword">defun</span> <span class="function-name">wff-long-cp-entry</span> (cp-entry)
  (<span class="keyword">declare</span> (xargs <span class="builtin">:verify-guards</span> t))
  (and (consp cp-entry)
       (equal (len cp-entry) 2)
       (equal (car cp-entry) 'LONG)
       (int64p (cadr cp-entry))))

(<span class="keyword">defun</span> <span class="function-name">wff-constant-pool-entry</span> (cp-entry)
  (<span class="keyword">declare</span> (xargs <span class="builtin">:verify-guards</span> t))
  (and (consp cp-entry)
       (equal (len cp-entry) 2)
       (or (wff-string-cp-entry cp-entry)
           (wff-int-cp-entry cp-entry)
           (wff-long-cp-entry cp-entry)
           <span class="comment">;;(wff-float-cp-entry cp-entry)
</span>           <span class="comment">;;(wff-double-cp-entry cp-entry)
</span>           <span class="comment">;; temp implementation
</span>           )))

(<span class="keyword">defun</span> <span class="function-name">wff-constant-pool</span> (cps)
  (<span class="keyword">declare</span> (xargs <span class="builtin">:verify-guards</span> t))
  (<span class="keyword">if</span> (not (consp cps)) t
    (and (wff-constant-pool-entry (car cps))
         (wff-constant-pool (cdr cps)))))


(local
 (<span class="keyword">defun</span> <span class="function-name">all-constant-pools</span> (class-reps)
   (<span class="keyword">declare</span> (xargs <span class="builtin">:guard</span> (wff-instance-class-table class-reps)))
   (<span class="keyword">if</span> (not (consp class-reps)) t
     (cons (constantpool (car class-reps))
           (all-constant-pools (cdr class-reps))))))

(local 
 (<span class="keyword">defun</span> <span class="function-name">all-wff-constant-pools</span> (cps)
  (<span class="keyword">if</span> (not (consp cps)) t
    (and (wff-constant-pool (car cps))
         (all-wff-constant-pools (cdr cps))))))

(local 
 (defthm all-wff-constant-pools-test
   (all-wff-constant-pools (all-constant-pools  (cdr (nth 1 *test.classtable*))))))

<span class="comment">;----------------------------------------------------------------------
</span>
(<span class="keyword">defun</span> <span class="function-name">cpentry-type</span> (cpentry)
  (<span class="keyword">declare</span> (xargs <span class="builtin">:guard</span> (wff-constant-pool-entry cpentry)))
  (car cpentry))

(<span class="keyword">defun</span> <span class="function-name">cpentry-value</span> (cpentry)
  (<span class="keyword">declare</span> (xargs <span class="builtin">:guard</span> (wff-constant-pool-entry cpentry)))
  (cadr cpentry))


(<span class="keyword">defun</span> <span class="function-name">make-string-cp-entry</span> (obj-ref)
  (list 'STRING obj-ref))

(<span class="keyword">defun</span> <span class="function-name">string-value-cp-entry</span> (cpentry)
  (<span class="keyword">declare</span> (xargs <span class="builtin">:guard</span> (wff-constant-pool-entry cpentry)))
  (cadr cpentry))

(<span class="keyword">defun</span> <span class="function-name">make-int-cp-entry</span> (int-value)
  (list 'INT int-value))

(<span class="keyword">defun</span> <span class="function-name">int-value-cpentry</span> (cpentry)
  (<span class="keyword">declare</span> (xargs <span class="builtin">:guard</span> (wff-constant-pool-entry cpentry)))
  (cadr cpentry))

(<span class="keyword">defun</span> <span class="function-name">make-long-cp-entry</span> (long-value)
  (list 'LONG long-value))

(<span class="keyword">defun</span> <span class="function-name">long-value-cpentry</span> (cpentry)
  (<span class="keyword">declare</span> (xargs <span class="builtin">:guard</span> (wff-constant-pool-entry cpentry)))
  (cadr cpentry))

(<span class="keyword">defun</span> <span class="function-name">make-float-cp-entry</span> (float-value)
  (list 'FLOAT float-value))
(<span class="keyword">defun</span> <span class="function-name">float-value-cpentry</span> (cpentry)
  (<span class="keyword">declare</span> (xargs <span class="builtin">:guard</span> (wff-constant-pool-entry cpentry)))
  (cadr cpentry))

(<span class="keyword">defun</span> <span class="function-name">make-double-cp-entry</span> (double-value)
  (list 'double double-value))

<span class="comment">;----------------------------------------------------------------------
</span>

<span class="comment">;----------------------------------------------------------------------
;
;  this are instance fields, what don't mention any constant value.
;
</span>
(<span class="keyword">defun</span> <span class="function-name">make-field</span> (classname fieldname fieldtype accessflags)
  (list 'field classname fieldname fieldtype 
        (cons 'accessflags accessflags)))

(<span class="keyword">defun</span> <span class="function-name">wff-field</span> (field)
  (and (equal (len field) 5)
       (true-listp field)
       (consp (nth 4 field))))

(<span class="keyword">defun</span> <span class="function-name">wff-fields-x</span> (fields)
  (<span class="keyword">if</span> (not (consp fields)) 
      (equal fields nil)
    (and (wff-field (car fields))
         (wff-fields-x (cdr fields)))))

<span class="comment">;----------------------------------------------------------------------
</span>
(<span class="keyword">defun</span> <span class="function-name">field-classname</span> (field)
  (<span class="keyword">declare</span> (xargs <span class="builtin">:guard</span> (wff-field field)))
  (nth 1 field))

(<span class="keyword">defun</span> <span class="function-name">field-fieldname</span> (field)  
  (<span class="keyword">declare</span> (xargs <span class="builtin">:guard</span> (wff-field field)))
  (nth 2 field))

(<span class="keyword">defun</span> <span class="function-name">field-fieldtype</span> (field)  
  (<span class="keyword">declare</span> (xargs <span class="builtin">:guard</span> (wff-field field)))
  (nth 3 field))

(<span class="keyword">defun</span> <span class="function-name">field-fieldaccessflags</span> (field)  
 (<span class="keyword">declare</span> (xargs <span class="builtin">:guard</span> (wff-field field)))
 (cdr (nth 4 field)))

<span class="comment">;----------------------------------------------------------------------
</span>
<span class="comment">;; these are static fields, what may refer to constant value in the constantpool
</span>
(<span class="keyword">defun</span> <span class="function-name">make-static-fields</span> (fields) 
  (cons 'static-fields fields))


(<span class="keyword">defun</span> <span class="function-name">wff-static-fields</span> (fields)
  (and (true-listp fields)
       (consp fields)))

(<span class="keyword">defun</span> <span class="function-name">static-fields-fields</span> (fields)
  (<span class="keyword">declare</span> (xargs <span class="builtin">:guard</span> (wff-static-fields fields)))
  (cdr fields))

<span class="comment">;----------------------------------------------------------------------
</span>

(<span class="keyword">defun</span> <span class="function-name">make-static-field</span> (classname fieldname fieldtype accessflags value)
  (list 'static-field 
        classname 
        fieldname 
        fieldtype 
        (cons 'accessflags accessflags)
        value))


(<span class="keyword">defun</span> <span class="function-name">wff-static-field</span> (field)
  (and (equal (len field) 6)
       (true-listp field)
       (consp (nth 4 field))))

(<span class="keyword">defun</span> <span class="function-name">static-field-classname</span>  (field) 
  (<span class="keyword">declare</span> (xargs <span class="builtin">:guard</span> (wff-static-field field)))
  (nth 1 field))
(<span class="keyword">defun</span> <span class="function-name">static-field-fieldname</span>  (field) 
  (<span class="keyword">declare</span> (xargs <span class="builtin">:guard</span> (wff-static-field field)))
  (nth 2 field))
(<span class="keyword">defun</span> <span class="function-name">static-field-fieldtype</span>  (field) 
  (<span class="keyword">declare</span> (xargs <span class="builtin">:guard</span> (wff-static-field field)))
  (nth 3 field))
(<span class="keyword">defun</span> <span class="function-name">static-field-accessflags</span> (field) 
  (<span class="keyword">declare</span> (xargs <span class="builtin">:guard</span> (wff-static-field field)))
  (cdr (nth 4 field))) <span class="comment">;; don't need cpindex
</span>
(<span class="keyword">defun</span> <span class="function-name">static-field-fieldvalue</span> (field)   
 (<span class="keyword">declare</span> (xargs <span class="builtin">:guard</span> (wff-static-field field)))
 (nth 5 field))

(<span class="keyword">defun</span> <span class="function-name">wff-static-fields-x</span> (fields)
  (<span class="keyword">if</span> (not (consp fields)) t
    (and (wff-static-field (car fields))
         (wff-static-fields-x (cdr fields)))))
                           


<span class="comment">;----------------------------------------------------------------------
;
;  since we only modify static fields value field
;
</span>
(<span class="keyword">defun</span> <span class="function-name">static-field-set-value</span> (value field)
 (<span class="keyword">declare</span> (xargs <span class="builtin">:guard</span> (wff-static-field field)))
  (make-static-field (static-field-classname field)
                     (static-field-fieldname field)
                     (static-field-fieldtype field)
                     (static-field-accessflags field)
                     value))


<span class="comment">;----------------------------------------------------------------------
;
;   Methods 
;
</span>
(<span class="keyword">defun</span> <span class="function-name">make-method</span> (classname methodname args returntype accessflags code)
  (list 'method 
        classname 
        methodname 
        (cons 'parameters args)
        (cons 'returntype returntype) 
        <span class="comment">;; Sun Apr 30 20:37:57 2006.  The cldc-class-table's format changed!! 
</span>        (cons 'accessflags accessflags)
        code))

(<span class="keyword">defun</span> <span class="function-name">wff-method-decl</span> (method-decl)
  (and (true-listp method-decl)
       (equal (len method-decl) 7)
       (consp (nth 3 method-decl))
       (consp (nth 4 method-decl))
       (consp (nth 5 method-decl))
       (true-listp (cdr (nth 3 method-decl)))
       (true-listp (cdr (nth 5 method-decl)))
       (true-listp (nth 6 method-decl))))

<span class="comment">;----------------------------------------------------------------------
</span>
(<span class="keyword">defun</span> <span class="function-name">method-classname</span>  (method)      
  (<span class="keyword">declare</span> (xargs <span class="builtin">:guard</span> (wff-method-decl method)))
  (nth 1 method))


(<span class="keyword">defun</span> <span class="function-name">method-methodname</span> (method)     
  (<span class="keyword">declare</span> (xargs <span class="builtin">:guard</span> (wff-method-decl method)))
  (nth 2 method))

(<span class="keyword">defun</span> <span class="function-name">method-args</span>       (method)      
  (<span class="keyword">declare</span> (xargs <span class="builtin">:guard</span> (wff-method-decl method)))
  (cdr (nth 3 method))) <span class="comment">;; FIXED  10/28/03. Originally missing a cdr 
</span>
(<span class="keyword">defun</span> <span class="function-name">method-returntype</span> (method)      
  (<span class="keyword">declare</span> (xargs <span class="builtin">:guard</span> (wff-method-decl method)))
  (cdr (nth 4 method))) <span class="comment">;; Sun Apr 30 20:34:21 2006. fixed after
;; cldc-class-table format changed!! 
;; Mon May  1 01:37:14 2006
</span>
(<span class="keyword">defun</span> <span class="function-name">method-accessflags</span>(method)    
  (<span class="keyword">declare</span> (xargs <span class="builtin">:guard</span> (wff-method-decl method)))
  (cdr (nth 5 method)))
(<span class="keyword">defun</span> <span class="function-name">method-code</span>       (method)  
  (<span class="keyword">declare</span> (xargs <span class="builtin">:guard</span> (wff-method-decl method)))
  (nth 6 method))

<span class="comment">;----------------------------------------------------------------------
</span>
(<span class="keyword">defun</span> <span class="function-name">make-code</span> (max-stack max-local code-length instrs exceptions stackmaps)
  (list 'code 
        (cons 'max_stack max-stack)
        (cons 'max_local max-local)
        (cons 'code_length code-length)
        (cons 'parsedcode instrs)
        (cons 'Exceptions exceptions)
        (cons 'StackMap   stackmaps)))


(<span class="keyword">defun</span> <span class="function-name">wff-code</span> (code)
  (and (equal (len code) 7)
       (true-listp code)
       (consp (nth 1 code))
       (consp (nth 2 code))
       (consp (nth 3 code))
       (consp (nth 4 code))
       (consp (nth 5 code))
       (consp (nth 6 code))))



(<span class="keyword">defun</span> <span class="function-name">code-max-stack</span> (code) 
  (<span class="keyword">declare</span> (xargs <span class="builtin">:guard</span> (wff-code code)))
  (cdr (nth 1 code)))

(<span class="keyword">defun</span> <span class="function-name">code-max-local</span> (code) 
  (<span class="keyword">declare</span> (xargs <span class="builtin">:guard</span> (wff-code code)))
  (cdr (nth 2 code)))

(<span class="keyword">defun</span> <span class="function-name">code-code-lenght</span> (code)
  (<span class="keyword">declare</span> (xargs <span class="builtin">:guard</span> (wff-code code)))
  (cdr (nth 3 code)))

(<span class="keyword">defun</span> <span class="function-name">code-instrs</span> (code)
  (<span class="keyword">declare</span> (xargs <span class="builtin">:guard</span> (wff-code code)))
  (cdr (nth 4 code)))

(<span class="keyword">defun</span> <span class="function-name">code-handlers</span> (code)
  (<span class="keyword">declare</span> (xargs <span class="builtin">:guard</span> (wff-code code)))
  (cdr (nth 5 code)))

(<span class="keyword">defun</span> <span class="function-name">code-stackmaps</span> (code)
  (<span class="keyword">declare</span> (xargs <span class="builtin">:guard</span> (wff-code code)))
  (cdr (nth 6 code)))


<span class="comment">;----------------------------------------------------------------------
</span>
(<span class="keyword">defun</span> <span class="function-name">make-accessflags</span> (flags)
  flags)

<span class="comment">;----------------------------------------------------------------------
</span>
(<span class="keyword">defun</span> <span class="function-name">wff-<a href="../DJVM/INST/inst.lisp.html">inst</a></span> (<a href="../DJVM/INST/inst.lisp.html">inst</a>)
  (and (true-listp <a href="../DJVM/INST/inst.lisp.html">inst</a>)
       (equal (len <a href="../DJVM/INST/inst.lisp.html">inst</a>) 2)
       (integerp (car <a href="../DJVM/INST/inst.lisp.html">inst</a>))
       (consp (nth 1 <a href="../DJVM/INST/inst.lisp.html">inst</a>))
       (true-listp (nth 1 <a href="../DJVM/INST/inst.lisp.html">inst</a>))))

(<span class="keyword">defun</span>  <span class="function-name">wff-insts</span> (code)
  (<span class="keyword">if</span> (not (consp code)) t
    (and (wff-inst (car code))
         (wff-insts (cdr code)))))

<span class="comment">;; Tue Mar 30 09:52:41 2004. updated 
</span>
<span class="comment">;; (defun wff-inst (instr)
;;   (and (true-listp instr)
;;        (equal (length instr) 2)
;;        (true-listp (NTH 1 instr))))
;; ;;     (equal (length (nth 1 instr)) 2)))
</span>
(<span class="keyword">defun</span> <span class="function-name">inst-offset</span> (instr)
  (<span class="keyword">declare</span> (xargs <span class="builtin">:guard</span> (wff-inst instr)))
  (car instr))

(<span class="keyword">defun</span> <span class="function-name">inst-inst</span> (instr) 
  (<span class="keyword">declare</span> (xargs <span class="builtin">:guard</span> (wff-inst instr)))
  (nth 1 instr))

(<span class="keyword">defun</span> <span class="function-name">inst-opcode</span> (instr)
  (<span class="keyword">declare</span> (xargs <span class="builtin">:guard</span> (wff-inst instr)))
  (car (inst-inst instr)))

(<span class="keyword">defun</span> <span class="function-name">inst-arg</span>    (instr)
  (<span class="keyword">declare</span> (xargs <span class="builtin">:guard</span> (and (wff-inst instr)
                              (equal (len (nth 1 instr)) 2))))
  (cadr (inst-inst instr)))


<span class="comment">;----------------------------------------------------------------------
</span>

<span class="comment">;; OLD comment: Mon Dec 22 23:40:31 2003
</span>
<span class="comment">;; the only way to create a runtime-class-rep is through the class_loader in
;; JVM. 
</span>
<span class="comment">;; maybe we should allow classname to be a class-descriptor, so that any Array
;; Class has an entry in this table, to really compare whether two array is
;; assignable, we could go through the descriptor or the object on the Java
;; heap.  another representation is to create a seperated table to record the
;; array-classes. We need a ...
</span>
<span class="comment">;; should we introduce another table to record those array-classes?? In that
;; way, we could keep internal-class-table in a uniform format.
;;
;; yes. that's what we did not.
;;
</span>
<span class="comment">;----------------------------------------------------------------------
</span>
(<span class="keyword">defun</span> <span class="function-name">make-array-type</span> (base-type)
  (list 'ARRAY base-type))


(<span class="keyword">defun</span> <span class="function-name">make-array-class-table-entry</span> (base-type accessflags new-addr)
  (list (make-array-type base-type) 
        (cons 'accessflags accessflags) new-addr))

(<span class="keyword">defun</span> <span class="function-name">wff-array-class-table-rep</span> (array-class-rep)
  (and (true-listp array-class-rep)
       (equal (len array-class-rep) 3)
       (consp (nth 1 array-class-rep))))

(<span class="keyword">defun</span> <span class="function-name">wff-array-class-table</span> (array-class-table)
  (and (true-listp array-class-table)
       (<span class="keyword">if</span> (not (consp array-class-table))
           t
         (and (wff-array-class-table-rep (car array-class-table))
              (wff-array-class-table (cdr array-class-table))))))

<span class="comment">;----------------------------------------------------------------------
</span>
(<span class="keyword">defun</span> <span class="function-name">array-sig</span> (array-class-rep) 
  (<span class="keyword">declare</span> (xargs <span class="builtin">:guard</span> (wff-array-class-table-rep array-class-rep)))
  (nth 0 array-class-rep))

(<span class="keyword">defun</span> <span class="function-name">array-access-flags</span> (array-class-rep) 
  (<span class="keyword">declare</span> (xargs <span class="builtin">:guard</span> (wff-array-class-table-rep array-class-rep)))
  (cdr (nth 1 array-class-rep)))

(<span class="keyword">defun</span> <span class="function-name">array-class-ref</span>    (array-class-rep) 
  (<span class="keyword">declare</span> (xargs <span class="builtin">:guard</span> (wff-array-class-table-rep array-class-rep)))
  (nth 2 array-class-rep))

<span class="comment">;; once loaded this array-class-table doesn't change.
</span>
(<span class="keyword">defun</span> <span class="function-name">add-array-class-table-entry</span> (ent table)
  (cons ent table))

<span class="comment">;----------------------------------------------------------------------
</span>

<span class="comment">;; for provide array-class-table is to provide a translation to a unique
;; class-ref, so that someone may call Class.forName() return a unique
;; references.
</span>
<span class="comment">;----------------------------------------------
</span>
<span class="comment">;----------------------------------------------------------------------
</span>
(<span class="keyword">defun</span> <span class="function-name">class-by-name</span> (class-name dcl)
  (<span class="keyword">declare</span> (xargs <span class="builtin">:guard</span> (wff-instance-class-table dcl)))
  (<span class="keyword">if</span> (not (consp dcl))
      nil
   (<span class="keyword">if</span> (equal (classname (car dcl)) class-name)
      (car dcl)
      (class-by-name class-name (cdr dcl)))))


(<span class="keyword">defun</span> <span class="function-name">isClassTerm</span> (Class)
  (and (consp Class)
       (equal (len (cdr Class)) 11)))  <span class="comment">;; not an accurate definition here 
</span>


(<span class="keyword">defun</span> <span class="function-name">class-exists?</span> (cn icl)
  (<span class="keyword">declare</span> (xargs <span class="builtin">:guard</span> (wff-instance-class-table icl)))
  (isClassTerm (class-by-name cn icl))) <span class="comment">;; not nil
</span>
<span class="comment">;; 1. <a href="../DJVM/INST/base.lisp.html">base</a> type could be a loaded array-class 
;; 2. <a href="../DJVM/INST/base.lisp.html">base</a> type could be a loaded instance-class
;; 3. <a href="../DJVM/INST/base.lisp.html">base</a> type could be a primitive type.
</span>
(<span class="keyword">defun</span> <span class="function-name">array-class-by-name</span> (array-type array-class-table)
  (<span class="keyword">declare</span> (xargs <span class="builtin">:guard</span> (wff-array-class-table array-class-table)))
  (<span class="keyword">if</span> (not (consp array-class-table))
      nil
    (<span class="keyword">if</span> (equal (array-sig (car array-class-table)) array-type)
        (car array-class-table)
      (array-class-by-name array-type (cdr array-class-table)))))

<span class="comment">;----------------------------------------------------------------------
</span>
(<span class="keyword">defun</span> <span class="function-name">isInterface</span> (class-rep)
  (<span class="keyword">declare</span> (xargs <span class="builtin">:guard</span> (wff-class-rep class-rep)))
  (mem '*interface* (class-accessflags class-rep)))

<span class="comment">;; assuming when class-rep is loaded, the super is also loaded. 
</span>(<span class="keyword">defun</span> <span class="function-name">super-exists</span> (class-rep) 
  (<span class="keyword">declare</span> (xargs <span class="builtin">:guard</span> (wff-class-rep class-rep)))
  (not (equal (super class-rep) <span class="string">""</span>)))

(<span class="keyword">defun</span> <span class="function-name">class-rep-in-error-state?</span> (class-rep) 
  (<span class="keyword">declare</span> (xargs <span class="builtin">:guard</span> (wff-class-rep class-rep)))
  (equal (class-status class-rep) *CLASS_ERROR*))

<span class="comment">;----------------------------------------------------------------------
</span>


<span class="comment">;----------------------------------------------------------------------
;----------------------------------------------------------------------
</span>
<span class="comment">;; From consistent-state.lisp Tue Jan 13 15:35:05 2004
</span>


<span class="comment">;----------------------------------------------------------------------
;
; defining concepts of wff class-table and consistent-class-hierachy!!
;
; We need this to define properly-guarded isSubclassOf?? 
; 
; Tue Jan 13 15:18:13 2004. The purpose is to reuse the same definition in DJVM
; and the actual JVM. We want JVM's operations being guarded, but we don't
; check for them.. We want to "guard verify" them. As long as top level guard
; satisfy (and we should they satisfy) then. execution will not causing guard
; failuring in any point of program execution!!
;
;
</span>

(<span class="keyword">defun</span> <span class="function-name">all-class-names</span> (cl)
  (<span class="keyword">declare</span> (xargs <span class="builtin">:guard</span> (wff-instance-class-table cl)))
  (<span class="keyword">if</span> (not (consp cl)) nil
    (cons (classname (car cl))
          (all-class-names (cdr cl)))))


(<span class="keyword">defun</span> <span class="function-name">unseen-classes</span> (cl seen)
  (<span class="keyword">declare</span> (xargs <span class="builtin">:measure</span> (wff-instance-class-table cl)
                  <span class="builtin">:guard</span> (and (wff-instance-class-table cl)
                              (true-listp seen))))
  (len (set-diff (all-class-names cl) seen)))

(<span class="keyword">defun</span> <span class="function-name">unseen-classes-x</span> (ns cl seen mode)
  (<span class="keyword">declare</span> (xargs <span class="builtin">:guard</span> (and (wff-instance-class-table cl)
                              (true-listp seen))))
  (<span class="keyword">cond</span> ((equal mode 'NODE) (cons (cons (+ 1 (unseen-classes cl seen)) 0) 0))
        ((equal mode 'LIST) (cons (cons (+ 1 (unseen-classes cl seen)) 0) 
                                  (len ns)))
        (t 0)))


(<span class="keyword">defun</span> <span class="function-name">all-interfaces-bounded?</span> (interfaces cl)
  (<span class="keyword">declare</span> (xargs <span class="builtin">:guard</span> (wff-instance-class-table cl)))
  (<span class="keyword">if</span> (not (consp interfaces)) t
    (and (class-exists? (car interfaces) cl)
         (isInterface (class-by-name (car interfaces) cl))
         (all-interfaces-bounded? (cdr interfaces) cl))))




(<span class="keyword">defun</span> <span class="function-name">class-hierachy-consistent1-class-n</span> (n cl)
  <span class="comment">;; 
</span>  <span class="comment">;; 1. super ends with "java.lang.Object" 
</span>  <span class="comment">;; 2. interfaces all bounded and are in fact interfaces.
</span>  <span class="comment">;; 3. Somewhere we need to assert no loop
</span>  <span class="comment">;;
</span>  <span class="comment">;;
</span>  (<span class="keyword">declare</span> (xargs <span class="builtin">:guard</span> (wff-instance-class-table cl)))
  (and (class-exists? n cl)
       (<span class="keyword">if</span> (equal n <span class="string">"java.lang.Object"</span>)
           (<span class="keyword">let</span> ((class-rep (class-by-name n cl)))
             (and (not (class-exists? (super class-rep) cl))
                  (all-interfaces-bounded? (interfaces class-rep) cl)))
         (<span class="keyword">let</span> ((class-rep (class-by-name n cl)))
           (and (class-exists? (super class-rep) cl)
                (all-interfaces-bounded? (interfaces class-rep) cl))))))


(<span class="keyword">defun</span> <span class="function-name">class-hierachy-consistent1-aux</span> (classes cl)
  (<span class="keyword">declare</span> (xargs <span class="builtin">:guard</span> (and (wff-instance-class-table cl)
                              (wff-instance-class-table classes))))
  (<span class="keyword">if</span> (not (consp classes)) t
    (and (class-hierachy-consistent1-class-n (classname (car classes)) cl)
         <span class="comment">;;; NOTE: Here using (class (car classes)) is different from testing
</span>         <span class="comment">;;; (car classes). Current usage allows some invalid description in
</span>         <span class="comment">;;; class-table. Otherwise we need to assert no-dups explicitly
</span>         <span class="comment">;;; We are using the same interface to assert property then it is
</span>         <span class="comment">;;; good. 
</span>         (class-hierachy-consistent1-aux (cdr classes) cl))))


(<span class="keyword">defun</span> <span class="function-name">class-hierachy-consistent1</span> (cl)
  (<span class="keyword">declare</span> (xargs <span class="builtin">:guard</span> (wff-instance-class-table cl)))
  (class-hierachy-consistent1-aux cl cl)) 
  <span class="comment">;;
</span>  <span class="comment">;; this only assert the fact that no class-rep refers an undefined 
</span>  <span class="comment">;; entity in super field and interfaces field
</span>  <span class="comment">;;
</span>  <span class="comment">;; Thus self contained. 
</span>  <span class="comment">;; 
</span>
(defthm class-exists?-implies-mem-all-class-names 
  (implies (and (class-exists? n cl)
                (wff-instance-class-table cl))
           (mem n (all-class-names cl))))


<span class="comment">;;  
</span>(<span class="keyword">defun</span> <span class="function-name">superclass-chain-no-loop-class-n</span> (n1 cl seen)
  (<span class="keyword">declare</span> (xargs <span class="builtin">:guard</span> (and (wff-instance-class-table cl)
                              (true-listp seen))
                  <span class="builtin">:measure</span> (unseen-classes cl seen)))
  <span class="comment">;;
</span>  <span class="comment">;; for termination, I also need cl is wff-instance-class-table we need to be
</span>  <span class="comment">;; able to show n1 if bounded, then it is a member of all classes
</span>  <span class="comment">;;
</span>  (<span class="keyword">if</span> (not (wff-instance-class-table cl)) nil
    (<span class="keyword">if</span> (not (class-exists? n1 cl)) t
      (<span class="keyword">if</span> (mem n1 seen) nil
        (<span class="keyword">let</span> ((n2 (super (class-by-name n1 cl))))
          <span class="comment">;; this definition is a trickier. 
</span>          <span class="comment">;; termination should be ok.
</span>          (superclass-chain-no-loop-class-n n2 cl (cons n1 seen)))))))


<span class="comment">;; I could merge this with the above one.  09/08/03 
</span>
<span class="comment">;;  Mon Nov 15 18:25:44 2004
</span>(<span class="keyword">defun</span> <span class="function-name">interfaces-chains-no-loop-class-n</span> (n-or-ns cl seen mode)
  (<span class="keyword">declare</span> (xargs <span class="builtin">:guard</span> (and (wff-instance-class-table cl)
                              (true-listp seen))
                  <span class="comment">;; I could assert stronger guard such as 
</span>                  <span class="comment">;; all n, ns are also bounded. 
</span>                  <span class="builtin">:measure</span> (unseen-classes-x n-or-ns cl seen mode)))
  (<span class="keyword">let</span> ((n  n-or-ns)
        (ns n-or-ns)) 
    (<span class="keyword">if</span> (not (wff-instance-class-table cl)) nil 
      <span class="comment">;; need for termintation!!
</span>      (<span class="keyword">cond</span> ((equal mode 'NODE)
             (<span class="keyword">if</span> (mem n seen) nil
               (<span class="keyword">if</span> (not (class-exists? n cl)) nil 
                 <span class="comment">;; if super interface is not bound then fail!!
</span>                   (<span class="keyword">let</span> ((ns (interfaces (class-by-name n cl))))
                     (interfaces-chains-no-loop-class-n
                      ns cl (cons n seen) 'LIST)))))
            ((equal mode 'LIST)
             (<span class="keyword">if</span> (not (consp ns)) t
               (and (interfaces-chains-no-loop-class-n (car ns) cl seen 'NODE)
                    (interfaces-chains-no-loop-class-n (cdr ns) cl seen 'LIST))))))))

<span class="comment">;; ;; Mon Nov 15 18:25:08 2004
;; (defun interfaces-chains-no-loop-class-n (n-or-ns cl seen mode)
;;   (declare (xargs :guard (and (wff-instance-class-table cl)
;;                               (true-listp seen))
;;                   ;; I could assert stronger guard such as 
;;                   ;; all n, ns are also bounded. 
;;                   :measure (unseen-classes-x n-or-ns cl seen mode)))
;;   (let ((n  n-or-ns)
;;         (ns n-or-ns)) 
;;     (if (not (wff-instance-class-table cl)) nil 
;;       ;; need for termintation!!
;;       (cond ((equal mode 'NODE)
;;              (if (mem n seen) nil
;;                (if (not (class-exists? n cl)) t
;;                    (let ((ns (interfaces (class-by-name n cl))))
;;                      (interfaces-chains-no-loop-class-n
;;                       ns cl (cons n seen) 'LIST)))))
;;             ((equal mode 'LIST)
;;              (if (not (consp ns)) t
;;                (and (interfaces-chains-no-loop-class-n (car ns) cl seen 'NODE)
;;                     (interfaces-chains-no-loop-class-n (cdr ns) cl seen 'LIST))))))))
</span>

<span class="comment">;; ;; I could merge this with the above one.  09/08/03 
;; (defun interfaces-chains-no-loop-class-n (n-or-ns cl seen mode)
;;   (declare (xargs :guard (and (wff-instance-class-table cl)
;;                               (true-listp seen))
;;                   ;; I could assert stronger guard such as 
;;                   ;; all n, ns are also bounded. 
;;                   :measure (unseen-classes-x n-or-ns cl seen mode)))
;;   (let ((n  n-or-ns)
;;         (ns n-or-ns)) 
;;     (if (not (wff-instance-class-table cl)) nil 
;;       ;; need for termintation!!
;;       (cond ((equal mode 'NODE)
;;              (if (not (class-exists? n cl)) t  ;;; !!!!!!!!!!!!!!
;;                (if (mem n seen) nil            ;;; !!!!!!!!!!!!!! 
;;                                                ;;; Need to reverse these two
;;                                                ;;; lines!! 
;;                    (let ((ns (interfaces (class-by-name n cl))))
;;                      (interfaces-chains-no-loop-class-n
;;                       ns cl (cons n seen) 'LIST)))))
;;             ((equal mode 'LIST)
;;              (if (not (consp ns)) t
;;                (and (interfaces-chains-no-loop-class-n (car ns) cl seen 'NODE)
;;                     (interfaces-chains-no-loop-class-n (cdr ns) cl seen 'LIST))))))))
</span>

(<span class="keyword">defun</span> <span class="function-name">class-hierachy-consistent2-class-n</span> (n cl)
  (<span class="keyword">declare</span> (xargs <span class="builtin">:guard</span> (wff-instance-class-table cl)))
  <span class="comment">;; this one I want to assert no loop through superclass chain and super
</span>  <span class="comment">;; interface chain.
</span>  <span class="comment">;;
</span>  <span class="comment">;; The problem is shall I mix this part with the other part?   
</span>  <span class="comment">;; 
</span>  <span class="comment">;; Shall I assert all interface's super must be java.lang.Object?
</span>  (and (superclass-chain-no-loop-class-n n cl nil)
       (interfaces-chains-no-loop-class-n n cl nil 'NODE)))


(<span class="keyword">defun</span> <span class="function-name">class-hierachy-consistent2-aux</span> (classes cl)
  (<span class="keyword">declare</span> (xargs <span class="builtin">:guard</span> (and (wff-instance-class-table classes)
                              (wff-instance-class-table cl))))
  (<span class="keyword">if</span> (not (consp classes)) t
    (and (class-hierachy-consistent2-class-n (classname (car classes)) cl)
         (class-hierachy-consistent2-aux  (cdr classes) cl))))

(<span class="keyword">defun</span> <span class="function-name">class-hierachy-consistent2</span> (cl)
  (<span class="keyword">declare</span> (xargs <span class="builtin">:guard</span> (wff-instance-class-table cl)))
  (class-hierachy-consistent2-aux cl cl))



(<span class="keyword">defun</span> <span class="function-name">consistent-class-hierachy</span> (cl)
  (<span class="keyword">declare</span> (xargs <span class="builtin">:verify-guards</span> t))
  <span class="comment">;; although 
</span>  (and (wff-instance-class-table cl)
       (class-hierachy-consistent1 cl)
       (class-hierachy-consistent2 cl)))


<span class="comment">;----------------------------------------------------------------------
</span>

<span class="comment">;; The third thing we need to assert about the internal class table is 
;; it is in fact loaded from the external class table. 
;; We only need to assert, class hierachy is not changed! tags of value in the
;; consistent pool is not changed. 
;; 
;; We also need to assert that static field's type all right? No we don't 
;; if Static field doesn't exist, we could just thrown an error in both
;; machine. However a sensible JVM implementation of loader should load that
;; field correctly. (part of the correctness of loader then) 
;;
;; WE DON'T EVEN NEED TO ASSERT FIELDS ARE ALL RIGHT. BECAUSE EVERYTHING IS
;; ENCODED IN THE FIELD CP.  09/09/03 ??? REALLY???  THE ASSIGNMENT COMPATIBLE
;; TEST IS DONE AFTER RESOLUTION. RESOLUTION IS GUARANTEED TO FIND THE RIGHT
;; TYPE. IN BCV, NO RESOLUTION IS DONE. BCV JUST TRUST AT RUNTIME RESOLUTION
;; PROCEDURE WILL FIND THE FIELD OF RIGHT TYPE.
</span>


(<span class="keyword">defun</span> <span class="function-name">constantpool-loaded-from</span> (cpentries cpentries-s)
  (<span class="keyword">declare</span> (xargs <span class="builtin">:guard</span> (and (wff-constant-pool cpentries)
                              (wff-constant-pool-s cpentries-s))))
  (<span class="keyword">cond</span> ((not (consp cpentries)) (not (consp cpentries-s)))
        ((not (consp cpentries-s)) nil)
        (t (and (equal (cpentry-type (car cpentries))
                       (cpentry-type-s (car cpentries-s)))
                (constantpool-loaded-from (cdr cpentries)
                                          (cdr cpentries-s))))))

<span class="comment">;; (defun wff-class-rep-static (class-rep)
;;   (declare (xargs :verify-guards t))
;;   (and (true-listp class-rep)
;;        (equal (len class-rep) 8)
;;        (equal (car class-rep) 'class) 
;;        (consp (nth 3 class-rep))
;;        (consp (nth 4 class-rep))
;;        (consp (nth 5 class-rep))
;;        (consp (nth 6 class-rep))
;;        (consp (nth 7 class-rep))
;;        (true-listp (cdr (nth 3 class-rep)))
;;        (true-listp (cdr (nth 4 class-rep)))
;;        (true-listp (cdr (nth 5 class-rep)))
;;        (true-listp (cdr (nth 6 class-rep)))
;;        (true-listp (cdr (nth 7 class-rep)))))
</span>
<span class="comment">;; moved to <a href="jvm-env.lisp.html">jvm-env</a>
</span>
(<span class="keyword">defun</span> <span class="function-name">wff-class-fields</span> (class-fields)
  (<span class="keyword">if</span> (not (consp class-fields)) 
      (equal class-fields nil)
    (and (wff-field (car class-fields))
         (wff-class-fields (cdr class-fields)))))

(<span class="keyword">defun</span> <span class="function-name">wff-class-method-decls</span> (method-decls)
  (<span class="keyword">if</span> (not (consp method-decls))
      (equal method-decls nil)
    (and (wff-method-decl (car method-decls))
         (wff-class-method-decls (cdr method-decls)))))

(defthm wff-class-rep-implies-true-listp-constant-pool
  (implies (wff-class-rep class-rep)
           (true-listp (constantpool class-rep)))
  <span class="builtin">:hints</span> ((<span class="string">"Goal"</span> <span class="builtin">:in-theory</span> (enable wff-class-rep
                                     constantpool)))
  <span class="builtin">:rule-classes</span> <span class="builtin">:forward-chaining</span>)


(<span class="keyword">defun</span> <span class="function-name">wff-class-rep-strong</span> (class-rep)
  (and (wff-class-rep class-rep)
       (wff-class-fields (fields class-rep))
       (wff-static-fields-x (static-fields class-rep))
       (wff-class-method-decls (methods class-rep))
       (wff-constant-pool (constantpool class-rep))))
                         

<span class="comment">;; Note. still need to add assertions about methods etc. Fri Jul 2 17:03:49
;; 2004
</span>
<span class="comment">;; Fri Aug  6 16:02:26 2004. Now we come to jvm-linker.lisp.
;; we add wff-method-decls
;; 
;; We will need to prove loader produce such wff-class-rep
;; we will need to add assertions to the wff-class-static!! 
;; 
;; Fri Aug 6 16:55:21 2004. It seems that it has already been incorporated.
;; 
;;
;; let it be now.
;; 
</span>
<span class="comment">;------------------------------------------------------------
</span>
(<span class="keyword">defconst</span> <span class="variable-name">*primitive-types*</span> '(char short int float double long boolean byte))

(<span class="keyword">defun</span> <span class="function-name">primitive-type?</span> (type)
  (mem type *primitive-types*))


(<span class="keyword">defun</span> <span class="function-name">array-type?</span> (type-sig)
  (and (true-listp type-sig)
       (equal (len type-sig) 2)
       (equal (car type-sig) 'ARRAY)))


(<span class="keyword">defun</span> <span class="function-name">reference-type</span> (type)
  (or (stringp type)
      (array-type? type)))


(<span class="keyword">defun</span> <span class="function-name">default-value</span> (type)
  (<span class="keyword">cond</span> ((equal type 'BYTE)  0)
        ((equal type 'SHORT) 0)
        ((equal type 'INT)   0)
        ((equal type 'LONG)  0)
        ((equal type 'FLOAT) <span class="string">"0.0"</span>)
        ((equal type 'DOUBLE) <span class="string">"0.0"</span>)<span class="comment">;
</span>        ((equal type 'CHAR)   0)
        ((equal type 'BOOLEAN)  0)
        ((reference-type type) -1) <span class="comment">;; use -1 as null pointer.
</span>        ((array-type? type) -1)    <span class="comment">;;
</span>        (t 'NOT-DEFINED))) 

<span class="comment">;----------------------------------------------------------------------
</span>
(<span class="keyword">defun</span> <span class="function-name">array-base-type</span> (array-type)
  (<span class="keyword">declare</span> (xargs <span class="builtin">:guard</span> (array-type? array-type)))
  (nth 1 array-type))


(<span class="keyword">defun</span> <span class="function-name">type-size</span> (type-desc)
  (<span class="keyword">if</span> (or (equal type-desc 'LONG)
          (equal type-desc 'DOUBLE))
      2
    1))

<span class="comment">;----------------------------------------------------------------------
;; (acl2::set-verify-guards-eagerness 0)
</span>

(<span class="keyword">defun</span> <span class="function-name">wff-type-rep</span> (type-rep)
  (or (primitive-type? type-rep)
      (and (consp type-rep)
           (or (and (true-listp type-rep) <span class="comment">;; Wed Jun  1 19:27:07 2005
</span>                    (equal (car type-rep) 'class)
                    (equal (len type-rep) 2)
                    (stringp (cadr type-rep))) 
               <span class="comment">;; Tue Apr  6 18:33:46 2004. Modified to 
</span>               <span class="comment">;; prevent (class 'uninitializedThis. 
</span>               (and (array-type? type-rep)
                    (wff-type-rep (array-base-type type-rep)))))))
              


<span class="comment">;; (defun wff-type-rep (type-rep)
;;   (or (primitive-type? type-rep)
;;       (and (consp type-rep)
;;            (or (and (equal (car type-rep) 'class)
;;                     (equal (len type-rep) 2)
;;                     (stringp (cadr type-rep))) 
;;                ;; Tue Apr  6 18:33:46 2004. Modified to 
;;                ;; prevent (class 'uninitializedThis. 
;;                (and (array-type? type-rep)
;;                     (wff-type-rep (array-base-type type-rep)))))))
</span>              



<span class="comment">;;; we also need to assert that it is true-listp
;;; so that we can prove 
;;;
;;; (fix-sig (normalize-type-rep type)) equal type
</span> 

(<span class="keyword">defun</span> <span class="function-name">normalize-type-rep</span> (type-rep)
  (<span class="keyword">declare</span> (xargs <span class="builtin">:guard</span> (wff-type-rep type-rep)))
  (<span class="keyword">if</span> (primitive-type? type-rep)
      type-rep
    (<span class="keyword">if</span> (consp type-rep)
        (<span class="keyword">cond</span> ((equal (car type-rep) 'class)
               (cadr type-rep))
              ((Array-Type? type-rep) 
               (make-array-type (normalize-type-rep 
                                 (array-base-type type-rep))))
              (t type-rep))
      type-rep)))

(<span class="keyword">defun</span> <span class="function-name">wff-type-reps</span> (type-reps)
  (<span class="keyword">if</span> (not (consp type-reps)) t
    (and (wff-type-rep (car type-reps))
         (wff-type-reps (cdr type-reps)))))

(<span class="keyword">defun</span> <span class="function-name">normalize-type-reps</span> (types)
  (<span class="keyword">declare</span> (xargs <span class="builtin">:guard</span> (wff-type-reps types)))
  (<span class="keyword">if</span> (not (consp types))
      nil
    (cons (normalize-type-rep (car types))
          (cdr types))))

<span class="comment">;------------------------------------------------------------
</span>

(<span class="keyword">defun</span> <span class="function-name">wff-fields-s</span> (static-fields)
  (<span class="keyword">if</span> (not (consp static-fields)) t
    (and (wff-field-s (car static-fields))
         (wff-type-rep (field-fieldtype-s (car static-fields)))
         (wff-fields-s (cdr static-fields)))))


<span class="comment">;-----------------------------------
</span>
(<span class="keyword">defun</span> <span class="function-name">runtime-instance-field-rep</span> (sfield classname)
  (<span class="keyword">declare</span> (xargs <span class="builtin">:guard</span> (and (wff-field-s sfield)
                              (wff-type-rep (field-fieldtype-s sfield)))))
  (make-field classname 
              (field-fieldname-s sfield) 
              (normalize-type-rep (field-fieldtype-s sfield))
              (field-fieldaccessflags-s sfield)))  <span class="comment">;; throw away the cpindex
</span>                                                   <span class="comment">;; fields in the sfield
</span>

(<span class="keyword">defun</span> <span class="function-name">runtime-instance-fields-rep1</span> (static-fields classname)
  (<span class="keyword">declare</span> (xargs <span class="builtin">:guard</span> (wff-fields-s static-fields)))
  (<span class="keyword">if</span> (not (consp static-fields))
      nil
    (<span class="keyword">if</span> (static-field?-s (car static-fields))
          (runtime-instance-fields-rep1 (cdr static-fields) classname)
    (cons (runtime-instance-field-rep (car static-fields) classname)
          (runtime-instance-fields-rep1 (cdr static-fields) classname)))))

(<span class="keyword">defun</span> <span class="function-name">runtime-instance-fields-rep</span> (static-field-table classname)
  (<span class="keyword">declare</span> (xargs <span class="builtin">:guard</span> (wff-fields-s static-field-table)))
  (runtime-instance-fields-rep1 static-field-table classname))

(<span class="keyword">defun</span> <span class="function-name">getCPvalue</span> (i dynamic-cp) 
  (<span class="keyword">declare</span> (xargs <span class="builtin">:guard</span> (and (wff-constant-pool dynamic-cp)
                              (true-listp dynamic-cp)
                              (integerp i)
                              (&lt;= 0 i)
                              (&lt; i (len dynamic-cp)))))
  (cpentry-value (nth i dynamic-cp)))

<span class="comment">;;; Thu Nov  4 18:27:33 2004
;;; Revised to correct the problem
;;; Misuses the cp entry as the static field's initial value!! 
;;;
</span>


(<span class="keyword">defun</span> <span class="function-name">runtime-static-field-rep</span> (sfield classname dynamic-cp)
  (<span class="keyword">declare</span> (xargs <span class="builtin">:guard</span> (and (wff-field-s sfield)
                              (wff-type-rep (field-fieldtype-s sfield))
                              (wff-constant-pool dynamic-cp)
                              (true-listp dynamic-cp)
                              (or (equal (field-cpindex-s sfield) -1)
                                  (and  (integerp (field-cpindex-s sfield))
                                        (&lt;= 0 (field-cpindex-s sfield))
                                        (&lt; (field-cpindex-s sfield) (len dynamic-cp)))))))
  (make-static-field classname 
              (field-fieldname-s sfield) 
              (normalize-type-rep (field-fieldtype-s sfield))
              (field-fieldaccessflags-s sfield)
              (<span class="keyword">if</span> (equal (field-cpindex-s sfield) -1)  
                  (default-value (normalize-type-rep (field-fieldtype-s sfield)))
                (getCPvalue (field-cpindex-s sfield) dynamic-cp))))
      

<span class="comment">;; ;;; Thu Jan  5 18:40:04 2006
</span>
<span class="comment">;; (defun value-type-ok (type1 type2)
;;   (and (primitive-type? type1)
;;        (equal type1 type2)))
</span>

(<span class="keyword">defun</span> <span class="function-name">value-type-ok</span> (cp-type1 field-type2)
   (and (primitive-type? cp-type1)
        (or (and (not (equal cp-type1 'INT))
                 (equal cp-type1 field-type2))
            (and (equal cp-type1 'INT)
                 (or (equal field-type2 'BOOLEAN)
                     (equal field-type2 'BYTE)
                     (equal field-type2 'CHAR)
                     (equal field-type2 'SHORT)
                     (equal field-type2 'INT))))))


(<span class="keyword">defun</span> <span class="function-name">value-type-ok-2</span> (type value)
  (and (primitive-type? type)
       (<span class="keyword">cond</span> ((equal type 'BOOLEAN) (jvmBOOLEANp value))
             ((equal type 'BYTE)    (BYTEp value))
             ((equal type 'CHAR)    (CHARp value))
             ((equal type 'SHORT)   (SHORTp value))
             ((equal type 'INT)     (INT32p value))
             ((equal type 'LONG)    (INT64p value))
             ((equal type 'FLOAT)   (jvmFloatp value))
             ((equal type 'DOUBLE)  (Doublep value)))))




(local (in-theory (disable wff-constant-pool-entry)))

(defthm nth-in-bound-wff-constant-pool-entry
  (implies (and (&lt;= 0 i) 
                (&lt; i (len cps))
                (wff-constant-pool cps))
           (wff-constant-pool-entry (nth i cps))))

<span class="comment">;; (i-am-here) ;; Thu Jan  5 20:29:27 2006
</span>
<span class="comment">;; (defun wff-static-cp-entry-ok (static-field dynamic-cp)
;;   (declare (xargs :guard (and (wff-field-s static-field)
;;                               (static-field?-s static-field)
;;                               (wff-constant-pool dynamic-cp)
;;                               (true-listp dynamic-cp))))
;;   (or (and (equal (field-cpindex-s static-field) -1)
;;            (equal (field-fieldtype-s static-field) '"java.lang.String"))
;;       (and (integerp (field-cpindex-s static-field))
;;            (&lt;= 0 (field-cpindex-s static-field))
;;            (&lt; (field-cpindex-s static-field) (len dynamic-cp))
;;            (value-type-ok (cpentry-type (nth (field-cpindex-s static-field)
;;                                              dynamic-cp))
;;                           (field-fieldtype-s static-field)))))
;;;
;;; Wed Nov 10 20:51:44 2004 Why? 
</span>


(<span class="keyword">defun</span> <span class="function-name">wff-static-cp-entry-ok</span> (static-field dynamic-cp)
  (<span class="keyword">declare</span> (xargs <span class="builtin">:guard</span> (and (wff-field-s static-field)
                              (static-field?-s static-field)
                              (wff-constant-pool dynamic-cp)
                              (true-listp dynamic-cp)
                              (wff-type-rep (field-fieldtype-s static-field)))))
  (or (and (equal (field-cpindex-s static-field) -1)
           (or (equal (field-fieldtype-s static-field) 'BOOLEAN)
               (equal (field-fieldtype-s static-field) 'BYTE)
               (equal (field-fieldtype-s static-field) 'CHAR)
               (equal (field-fieldtype-s static-field) 'SHORT)
               (equal (field-fieldtype-s static-field) 'INT)
               (equal (field-fieldtype-s static-field) 'LONG)
               (reference-type (normalize-type-rep (field-fieldtype-s static-field)))))
      <span class="comment">;; note. only this two type are currently supported!! 
</span>           <span class="comment">;; Wed Nov 10 21:56:33 2004
</span>           <span class="comment">;;
</span>           <span class="comment">;; should have moved this into wff-class-rep-static!! 
</span>           <span class="comment">;;
</span>           (and (integerp (field-cpindex-s static-field))
                (&lt;= 0 (field-cpindex-s static-field))
                (&lt; (field-cpindex-s static-field) (len dynamic-cp))
                (value-type-ok (cpentry-type (nth (field-cpindex-s static-field)
                                                  dynamic-cp))
                               (field-fieldtype-s static-field))
                (value-type-ok-2 (field-fieldtype-s static-field)
                                 (cpentry-value (nth (field-cpindex-s
                                                      static-field)
                                                     dynamic-cp))))))


<span class="comment">;;
;; &gt;V            (DEFUN STATIC-FIELD?-S (FIELD)
;;                      (DECLARE (XARGS :GUARD (WFF-FIELD-S FIELD)))
;;                      (MEM '*STATIC*
;;                           (FIELD-FIELDACCESSFLAGS-S FIELD)))
</span>
<span class="comment">;; (i-am-here) ;; Thu Jan  5 20:24:52 2006
</span>
(<span class="keyword">defun</span> <span class="function-name">wff-static-cp-ok</span> (static-fields dynamic-cp)
  (<span class="keyword">declare</span> (xargs <span class="builtin">:guard</span> (and (wff-fields-s static-fields)
                              (true-listp dynamic-cp)
                              (wff-constant-pool dynamic-cp))))
  (<span class="keyword">if</span> (not (consp static-fields)) t
    (<span class="keyword">if</span> (not (static-field?-s (car static-fields)))
        (wff-static-cp-ok (cdr static-fields) dynamic-cp)
      (and (wff-static-cp-entry-ok (car static-fields) dynamic-cp)
           (wff-static-cp-ok (cdr static-fields) dynamic-cp)))))


(<span class="keyword">defun</span> <span class="function-name">runtime-static-fields-rep1</span> (static-fields classname dynamic-cp)
  (<span class="keyword">declare</span> (xargs <span class="builtin">:guard</span> (and (wff-fields-s static-fields)
                              (true-listp dynamic-cp)
                              (wff-constant-pool dynamic-cp)
                              (wff-static-cp-ok static-fields dynamic-cp))))
  (<span class="keyword">if</span> (not (consp static-fields))
      nil
    (<span class="keyword">if</span> (not (static-field?-s (car static-fields)))
          (runtime-static-fields-rep1 (cdr static-fields) classname dynamic-cp)
    (cons (runtime-static-field-rep (car static-fields) classname dynamic-cp)
          (runtime-static-fields-rep1 (cdr static-fields) classname dynamic-cp)))))


(<span class="keyword">defun</span> <span class="function-name">runtime-static-fields-rep</span> (static-field-table classname dynamic-cp)
  (<span class="keyword">declare</span> (xargs <span class="builtin">:guard</span> (and (wff-fields-s static-field-table)
                              (true-listp dynamic-cp)
                              (wff-constant-pool dynamic-cp)
                              (wff-static-cp-ok static-field-table dynamic-cp))))
  (runtime-static-fields-rep1 static-field-table classname dynamic-cp))



(<span class="keyword">defun</span> <span class="function-name">runtime-code-rep0</span> (scode)
  (<span class="keyword">declare</span> (xargs <span class="builtin">:guard</span> (wff-code-s scode)))
  (make-code 
   (code-max-stack-s scode)
   (code-max-local-s scode)
   (code-code-length-s scode)
   (code-instrs-s    scode)
   (code-handlers-s  scode)
   (code-stackmaps-s scode)))

(<span class="keyword">defun</span> <span class="function-name">runtime-code-rep</span> (scode accessflag)
  (<span class="keyword">declare</span> (xargs <span class="builtin">:guard</span> (or (mem '*native* accessflag)
                             (mem '*abstract* accessflag)
                             (wff-code-s scode))))
  (<span class="keyword">cond</span> ((mem '*native* accessflag)   (make-code 0 0 0 nil nil nil))
        ((mem '*abstract* accessflag) (make-code 0 0 0 nil nil nil))
        (t (runtime-code-rep0 scode)))) 

(<span class="keyword">defun</span> <span class="function-name">runtime-method-rep-guard</span> (amethod)
  (and (wff-method-decl-s amethod)
       (wff-type-reps (method-args-s amethod))
       (or (equal (method-returntype-s amethod) 'VOID)
           (wff-type-rep (method-returntype-s amethod)))
       <span class="comment">;; Sat Oct 23 18:55:58 2004
</span>       (or (mem '*native* (method-accessflags-s amethod))
           (mem '*abstract* (method-accessflags-s amethod))
           (and (wff-code-s (method-code-s amethod))
                (integerp (code-max-local-s (method-code-s amethod)))
                (integerp (code-max-stack-s (method-code-s amethod)))))))
<span class="comment">;;; Mon Nov  8 19:16:03 2004. 
;;;
;;; fixed from consistent-class-decl requirement!! 
;;;
</span>
(<span class="keyword">defun</span> <span class="function-name">runtime-method-rep</span> (amethod classname)
  (<span class="keyword">declare</span> (xargs <span class="builtin">:guard</span> (runtime-method-rep-guard  amethod)))
  (make-method classname 
              (method-methodname-s  amethod) 
              (normalize-type-reps (method-args-s        amethod))
              (<span class="keyword">if</span> (equal (method-returntype-s amethod) 'VOID)
                  'VOID
                (normalize-type-rep  (method-returntype-s  amethod)))
              (method-accessflags-s amethod)
              (runtime-code-rep 
               (method-code-s  amethod) (method-accessflags-s amethod))))

(<span class="keyword">defun</span> <span class="function-name">runtime-method-rep-guards</span> (methods)
  (<span class="keyword">if</span> (not (consp methods)) t
      (and (runtime-method-rep-guard (car methods))
           (runtime-method-rep-guards (cdr methods)))))

(<span class="keyword">defun</span> <span class="function-name">runtime-methods-rep1</span> (methods classname)
  (<span class="keyword">declare</span> (xargs <span class="builtin">:guard</span> (runtime-method-rep-guards methods)))
  (<span class="keyword">if</span> (not (consp methods))
      nil
    (cons (runtime-method-rep (car methods) classname)
          (runtime-methods-rep1 (cdr methods) classname))))

<span class="comment">;(i-am-here)
</span>
(<span class="keyword">defun</span> <span class="function-name">runtime-methods-rep</span> (static-method-table classname)
  (<span class="keyword">declare</span> (xargs <span class="builtin">:guard</span> (runtime-method-rep-guards static-method-table)))
  (runtime-methods-rep1 static-method-table classname))



<span class="comment">;----------------------------------------------------------------------
</span>
(<span class="keyword">defun</span> <span class="function-name">wff-fields-s-x</span> (fields)
  (<span class="keyword">if</span> (not (consp fields)) t
    (and (wff-field-s (car fields))
         (wff-fields-s-x (cdr fields)))))


<span class="comment">;; (defun wff-class-rep-static-strong (class-rep)
;;   (and (wff-class-rep-static class-rep)
;;        (wff-fields-s (fields-s class-rep))
;;        ;; missing assertions about fields being wff. 
;;        (wff-fields-s-x (fields-s class-rep))
;;        (runtime-method-rep-guards (methods-s class-rep))
;;        (wff-constant-pool-s (constantpool-s class-rep))))
</span>

(defthm nth-in-bound-wff-constant-pool-entry-s
  (implies (and (&lt;= 0 i) 
                (&lt; i (len cps))
                (wff-constant-pool-s cps))
           (wff-constant-pool-entry-s (nth i cps))))




(<span class="keyword">defun</span> <span class="function-name">wff-static-cp-entry-ok-s</span> (static-field static-cp)
  (<span class="keyword">declare</span> (xargs <span class="builtin">:guard</span> (and (wff-field-s static-field)
                              (static-field?-s static-field)
                              (wff-constant-pool-s static-cp)
                              (true-listp static-cp)
                              (wff-type-rep (field-fieldtype-s static-field)))))
  (or (and (equal (field-cpindex-s static-field) -1)
           (or (equal (field-fieldtype-s static-field) 'BOOLEAN)
               (equal (field-fieldtype-s static-field) 'BYTE)
               (equal (field-fieldtype-s static-field) 'CHAR)
               (equal (field-fieldtype-s static-field) 'SHORT)
               (equal (field-fieldtype-s static-field) 'INT)
               (equal (field-fieldtype-s static-field) 'LONG)
               (reference-type (normalize-type-rep (field-fieldtype-s static-field)))))
      (and (integerp (field-cpindex-s static-field))
           (&lt;= 0 (field-cpindex-s static-field))
           (&lt; (field-cpindex-s static-field) (len static-cp))
           (value-type-ok (cpentry-type-s (nth (field-cpindex-s static-field)
                                               static-cp))
                          (field-fieldtype-s static-field))
           (value-type-ok-2 (field-fieldtype-s static-field)
                            (cpentry-value-s (nth (field-cpindex-s static-field)
                                                  static-cp))))))



(<span class="keyword">defun</span> <span class="function-name">wff-static-cp-ok-s</span> (static-fields static-cp)
  (<span class="keyword">declare</span> (xargs <span class="builtin">:guard</span> (and (wff-fields-s static-fields)
                              (true-listp static-cp)
                              (wff-constant-pool-s static-cp))))
  (<span class="keyword">if</span> (not (consp static-fields)) t
    (<span class="keyword">if</span> (not (static-field?-s (car static-fields)))
        (wff-static-cp-ok-s (cdr static-fields) static-cp)
      (and (wff-static-cp-entry-ok-s (car static-fields) static-cp)
           (wff-static-cp-ok-s (cdr static-fields) static-cp)))))


(defthm wff-class-rep-static-implies-true-listp
  (implies (wff-class-rep-static class-rep)
           (true-listp (constantpool-s class-rep)))
  <span class="builtin">:hints</span> ((<span class="string">"Goal"</span> <span class="builtin">:in-theory</span> (enable wff-class-rep-static constantpool-s)))
  <span class="builtin">:rule-classes</span> <span class="builtin">:forward-chaining</span>)


(<span class="keyword">defun</span> <span class="function-name">all-fields-static-final</span> (fields)
  (<span class="keyword">declare</span> (xargs <span class="builtin">:guard</span> (and (wff-fields-s fields))))
  (<span class="keyword">if</span> (not (consp fields)) t
    (and (MEM '*STATIC*
              (FIELD-FIELDACCESSFLAGS-S (car FIELDs)))
         (MEM '*FINAL*
              (field-fieldaccessflags-s (car fields)))
         (all-fields-static-final (cdr fields)))))
      

(<span class="keyword">defun</span> <span class="function-name">wff-interface-class-static</span> (class-rep)
  (<span class="keyword">declare</span> (xargs <span class="builtin">:guard</span> (and (wff-class-rep-static class-rep)
                              (wff-fields-s (fields-s class-rep)))))
  (and (equal (super-s class-rep) <span class="string">"java.lang.Object"</span>)
       (all-fields-static-final (fields-s class-rep))))
  

(<span class="keyword">defun</span> <span class="function-name">collect-static-field-names</span> (fields)
  (<span class="keyword">declare</span> (xargs <span class="builtin">:guard</span> (wff-fields-s fields)))
  (<span class="keyword">if</span> (not (consp fields)) nil
    (cons (field-fieldname-s (car fields))
          (collect-static-field-names (cdr fields)))))


(<span class="keyword">defun</span> <span class="function-name">wff-class-rep-static-strong</span> (class-rep)
  (and (wff-class-rep-static class-rep)
       (wff-fields-s (fields-s class-rep))
       (nodup-set (collect-static-field-names (fields-s class-rep)))
       (or (not (mem '*interface*  (accessflags-s class-rep)))
           (wff-interface-class-static class-rep))
       (wff-fields-s-x (fields-s class-rep))
       (runtime-method-rep-guards (methods-s class-rep))
       (wff-constant-pool-s (constantpool-s class-rep))
       (wff-static-cp-ok-s (fields-s class-rep)
                           (constantpool-s class-rep))))


<span class="comment">;; (defun constantpool-loaded-from (cpentries cpentries-s)
;;   (declare (xargs :guard (and (wff-constant-pool cpentries)
;;                               (wff-constant-pool-s cpentries-s))))
;;   (cond ((not (consp cpentries)) (not (consp cpentries-s)))
;;         ((not (consp cpentries-s)) nil)
;;         (t (and (equal (cpentry-type (car cpentries))
;;                        (cpentry-type-s (car cpentries-s)))
;;                 (constantpool-loaded-from (cdr cpentries)
;;                                           (cdr cpentries-s))))))
</span>

(<span class="keyword">defun</span> <span class="function-name">fields-loaded-from</span> (fields sfields classname)
  (<span class="keyword">declare</span> (xargs <span class="builtin">:guard</span> (wff-fields-s  sfields)))
  (equal (runtime-instance-fields-rep sfields classname)
         fields))

<span class="comment">;;; Mon Jun 13 17:29:08 2005 
;;; worry about static variable later!!! 
;;;
;;
;;                              (RUNTIME-INSTANCE-FIELDS-REP
;;                                   (FIELDS-S JVM::CLASS-DESC)
</span>
<span class="comment">;;(i-am-here)
</span>
(<span class="keyword">defun</span> <span class="function-name">collect-field-names</span> (field-decls)
  (<span class="keyword">declare</span> (xargs <span class="builtin">:guard</span> (wff-class-fields field-decls)))
  (<span class="keyword">if</span> (not (consp field-decls)) nil
    (cons (field-fieldname (car field-decls))
          (collect-field-names (cdr field-decls)))))


(defthm nodup-set-fields-s-nodup-set-fields
  (implies (nodup-set (collect-static-field-names fields-s))
           (nodup-set (collect-field-names 
                       (runtime-instance-fields-rep
                        fields-s classname))))
  <span class="builtin">:hints</span> ((<span class="string">"Goal"</span> <span class="builtin">:do-not</span> '(generalize))))


(<span class="keyword">defun</span> <span class="function-name">methods-loaded-from</span> (methods static-methods classname)
  (<span class="keyword">declare</span> (xargs <span class="builtin">:guard</span> (RUNTIME-METHOD-REP-GUARDS static-methods)))
  (equal (runtime-methods-rep static-methods classname)
         methods))

(<span class="keyword">defun</span> <span class="function-name">class-is-loaded-from-helper</span> (class-rep class-rep-static)
  (<span class="keyword">declare</span> (xargs <span class="builtin">:guard</span> (and (wff-class-rep-strong class-rep) 
                              (wff-class-rep-static-strong class-rep-static))))
  (and (equal (classname  class-rep) (classname-s  class-rep-static))
       (equal (super      class-rep) (super-s      class-rep-static))
       (equal (interfaces class-rep) (interfaces-s class-rep-static))
       <span class="comment">;; Mon Jun 13 17:20:05 2005 new additions. 
</span>       (fields-loaded-from (fields class-rep) (fields-s class-rep-static)
                           (classname class-rep))
       <span class="comment">;; Thu Jan  5 13:27:18 2006
</span>       (methods-loaded-from (methods class-rep) (methods-s class-rep-static)
                            (classname-s class-rep-static))
       <span class="comment">;; we also need the access flags are preserved 
</span>       (equal (class-accessflags class-rep) (accessflags-s class-rep-static))
       (constantpool-loaded-from (constantpool class-rep)
                                 (constantpool-s class-rep-static))))
       <span class="comment">;; this also stipulated whether is it an interface type or not.
</span>


<span class="comment">;; (defun class-is-loaded-from-helper (class-rep class-rep-static)
;;   (declare (xargs :guard (and (wff-class-rep-strong class-rep) 
;;                               (wff-class-rep-static-strong class-rep-static))))
;;   (and (equal (classname  class-rep) (classname-s  class-rep-static))
;;        (equal (super      class-rep) (super-s      class-rep-static))
;;        (equal (interfaces class-rep) (interfaces-s class-rep-static))
;;        ;; we also need the access flags are preserved 
;;        (equal (class-accessflags class-rep) (accessflags-s class-rep-static))
;;        (constantpool-loaded-from (constantpool class-rep)
;;                                  (constantpool-s class-rep-static))))
;;        ;; this also stipulated whether is it an interface type or not.
</span>



(<span class="keyword">defun</span> <span class="function-name">wff-static-class-table</span> (scl)
  (<span class="keyword">declare</span> (xargs <span class="builtin">:verify-guards</span> t))
  (<span class="keyword">if</span> (not (consp scl)) t
    (and (wff-class-rep-static (car scl))
         (wff-static-class-table (cdr scl)))))

(<span class="keyword">defun</span> <span class="function-name">wff-instance-class-table-strong</span> (icl)
  (<span class="keyword">declare</span> (xargs <span class="builtin">:verify-guards</span> t))
  (<span class="keyword">if</span> (not (consp icl)) t 
    (and (wff-class-rep-strong (car icl))
         (wff-instance-class-table-strong (cdr icl)))))



(<span class="keyword">defun</span> <span class="function-name">wff-static-class-table-strong</span> (scl)
  (<span class="keyword">declare</span> (xargs <span class="builtin">:verify-guards</span> t))
  (<span class="keyword">if</span> (not (consp scl)) t
    (and (wff-class-rep-static-strong (car scl))
         (wff-static-class-table-strong (cdr scl)))))


<span class="comment">;; (defun class-by-name-s (name scl)
;;   (declare (xargs :guard (wff-static-class-table scl)))
;;   (if (not (consp scl))
;;       (mv nil nil)
;;     (if (equal (classname-s (car scl))
;;                name)
;;         (mv t (car scl))
;;       (class-by-name-s name (cdr scl)))))
</span>

(<span class="keyword">defun</span> <span class="function-name">class-exists-s?</span> (n scl)
  (<span class="keyword">declare</span> (xargs <span class="builtin">:guard</span> (wff-static-class-table scl)))
  (mv-let (found rep)
          (class-by-name-s n scl)
          (<span class="keyword">declare</span> (ignore rep))
          found))

(defthm class-exists-s-implies-wff-static-rep
   (implies (and (class-exists-s? n scl)
                 (wff-static-class-table-strong scl))
            (wff-class-rep-static-strong (mv-let (found rep)
                                                 (class-by-name-s n scl)
                                                 (<span class="keyword">declare</span> (ignore found))
                                                 rep))))


(defthm class-exists-implies-wff-rep-strong
   (implies (and (class-exists? n cl)
                 (wff-instance-class-table-strong cl))
            (wff-class-rep-strong (class-by-name n cl))))


(defthm wff-class-rep-strong-is-strong
  (implies (wff-class-rep-strong rep)
           (wff-class-rep rep))
  <span class="builtin">:rule-classes</span> <span class="builtin">:forward-chaining</span>)

(defthm wff-instance-class-table-strong-is-strong
  (implies (wff-instance-class-table-strong cl)
           (wff-instance-class-table cl))
  <span class="builtin">:rule-classes</span> <span class="builtin">:forward-chaining</span>)


(defthm wff-static-class-table-strong-is-strong
  (implies (wff-static-class-table-strong scl)
           (wff-static-class-table scl))
  <span class="builtin">:rule-classes</span> <span class="builtin">:forward-chaining</span>)


<span class="comment">;; (defthm wff-static-class-table-strong-is-strong-tmp
;;   (implies (wff-static-class-table-strong scl)
;;            (jvm::wff-static-class-table scl))
;;   :rule-classes :forward-chaining)
</span>

(defthm wff-class-static-rep-strong-is-strong
  (implies (wff-class-rep-static-strong rep)
           (wff-class-rep-static rep))
  <span class="builtin">:rule-classes</span> <span class="builtin">:forward-chaining</span>)



<span class="comment">;(in-theory (disable wff-class-rep-static-strong wff-class-rep-strong
;                    wff-class-rep
;                    class-exists? class-by-name class-by-name-s class-exists-s?))
</span>
<span class="comment">;; These are too general!!
</span>
(defthm wff-class-rep-if-exists-in-wff-instance-table
  (implies (and (class-exists? n cl)
                (wff-instance-class-table cl))
           (wff-class-rep (class-by-name n cl))))



(<span class="keyword">defun</span> <span class="function-name">class-table-is-loaded-from</span> (cl scl)
  (<span class="keyword">declare</span> (xargs <span class="builtin">:guard</span> (and (wff-instance-class-table-strong cl)
                              (wff-static-class-table-strong scl))))
  (<span class="keyword">if</span> (not (consp cl)) t
    (and (class-exists? (classname (car cl)) cl)
         (class-exists-s? (classname (car cl)) scl)
         (mv-let (def-found rep)
                 (class-by-name-s (classname (car cl)) scl)
                 (<span class="keyword">declare</span> (ignore def-found))
                 (class-is-loaded-from-helper (class-by-name (classname (car cl)) cl)
                                              rep))
         (class-table-is-loaded-from (cdr cl) scl))))

<span class="comment">;; we chose not to disable those functions. ACL2 will get it anyway!
</span>
<span class="comment">;; Thu Jan  5 15:50:23 2006
;;
</span> 

(local 
 (defthm class-table-is-loaded-from-test
   (class-table-is-loaded-from (cdr (nth 1 *test.classtable*))
                               (env-class-table *test.env*))))


<span class="comment">;----------------------------------------------------------------------
;; Thu Jan  5 15:01:26 2006
</span>
(acl2::set-verify-guards-eagerness 0)


<span class="comment">;; (defpredicate method-static-match-guard (method-s)
;;   (and (wff-method-decl-s method-s)
;;        (wff-type-reps (method-args-s method-s))
;;        (or (equal (method-returntype-s method-s) 'VOID)
;;            (wff-type-rep (method-returntype-s method-s)))))
</span>

<span class="comment">;; (defun method-static-match (name args returntype method-s)
;;   (declare (xargs :guard (method-static-match-guard method-s)))
;;   (and (equal (method-methodname-s method-s) name)
;;        (equal (normalize-type-reps (method-args-s method-s)) args)
;;        (if (equal returntype 'VOID)
;;            (equal (method-returntype-s method-s) 'VOID)
;;          (equal (normalize-type-rep (method-returntype-s method-s))
;;                 returntype))))
</span>


(<span class="keyword">defun</span> <span class="function-name">method-static-match</span> (name args returntype method-s)
  (and (equal (method-methodname-s method-s) name)
       (equal (normalize-type-reps (method-args-s method-s)) args)
       (<span class="keyword">if</span> (equal returntype 'VOID)
           (equal (method-returntype-s method-s) 'VOID)
         (equal (normalize-type-rep (method-returntype-s method-s))
                returntype))))



<span class="comment">;; (defpredicate method-by-name-s-guard (methods-s)
;;   (if (not (consp methods-s)) t
;;     (and (method-static-match-guard (car methods-s))
;;          (method-by-name-s-guard (cdr methods-s)))))
</span>


(<span class="keyword">defun</span> <span class="function-name">method-by-name-s</span> (name args returntype methods-s)
  (<span class="keyword">if</span> (not (consp methods-s))
      (mv nil nil)
    (<span class="keyword">if</span> (method-static-match name args returntype (car methods-s))
        (mv t (car methods-s))
      (method-by-name-s name args returntype (cdr methods-s)))))


<span class="comment">;; (defun method-by-name-s (name args returntype methods-s)
;;   (declare (xargs :guard (method-by-name-s-guard methods-s)))
;;   (if (not (consp methods-s))
;;       (mv nil nil)
;;     (if (method-static-match name args returntype (car methods-s))
;;         (mv t (car methods-s))
;;       (method-by-name-s name args returntype (cdr methods-s)))))
</span>

<span class="comment">;; (in-theory (disable method-static-match-guard
;;                     method-by-name-s-guard))
</span>

<span class="comment">;----------------------------------------------------------------------
</span></pre>
  </body>
</html>
