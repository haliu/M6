<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01//EN">
<!-- Created by htmlize-1.16 in css mode. -->
<html>
  <head>
    <title>jvm-loader.lisp</title>
    <style type="text/css">
    <!--
      body {
        color: #f5deb3;
        background-color: #000000;
      }
      .builtin {
        /* font-lock-builtin-face */
        color: #b0c4de;
      }
      .comment {
        /* font-lock-comment-face */
        color: #ff7f24;
      }
      .function-name {
        /* font-lock-function-name-face */
        color: #87cefa;
      }
      .keyword {
        /* font-lock-keyword-face */
        color: #00ffff;
      }
      .string {
        /* font-lock-string-face */
        color: #ffa07a;
      }
      a {
        color: inherit;
        background-color: inherit;
        font: inherit;
        text-decoration: inherit;
      }
      a:hover {
        text-decoration: underline;
      }
    -->
    </style>
  </head>
  <body>
    <pre>
(<span class="keyword">in-package</span> <span class="string">"JVM"</span>)
(include-book <span class="string"><a href="jvm-loader-primitives.lisp.html">"../M6-DJVM-shared/jvm-loader-primitives"</a></span>)
(include-book <span class="string"><a href="jvm-loader-constant-pool-primitives.lisp.html">"../M6-DJVM-shared/jvm-loader-constant-pool-primitives"</a></span>)
(include-book <span class="string"><a href="jvm-loader-inv.lisp.html">"../M6-DJVM-shared/jvm-loader-inv"</a></span>)

(include-book <span class="string">"ordinals/e0-ordinal"</span> <span class="builtin">:dir</span> <span class="builtin">:system</span>)
(set-well-founded-relation e0-ord-&lt;)

<span class="comment">;; (acl2::set-verify-guards-eagerness 0) ;; tmp implementation!! 
;;
;; Wed Mar 31 14:02:42 2004
;;
</span>(acl2::set-verify-guards-eagerness 2)

<span class="comment">; test whethter the instance class of classname is loaded. 
</span>(<span class="keyword">defun</span> <span class="function-name">class-loaded?</span> (classname s)
  (<span class="keyword">declare</span> (xargs <span class="builtin">:guard</span> (and (wff-state s)
                              (wff-class-table (class-table s))
                              (wff-instance-class-table (instance-class-table s)))))
  (isClassTerm (class-by-name classname (instance-class-table s))))

(<span class="keyword">defun</span> <span class="function-name">ArrayClassLoaded1?</span> (type l)
  (<span class="keyword">declare</span> (xargs <span class="builtin">:guard</span> (wff-array-class-table l)))
  (array-class-by-name type l))

(<span class="keyword">defun</span> <span class="function-name">ArrayClassLoaded?</span> (basetype s)
  <span class="string">"Return whether array of such a basetype has been loaded"</span>
  (<span class="keyword">declare</span> (xargs <span class="builtin">:guard</span> (and (wff-state s)
                              (wff-class-table (class-table s))
                              (wff-array-class-table (array-class-table s)))))
  (<span class="keyword">let</span> ((al (array-class-table s)))
    (ArrayClassLoaded1? (make-array-type basetype) al)))

<span class="comment">;; real loader
;;
;; this method load the class, it will be correct only when the superclasses
;; are loaded, or the class is java.lang.Object, java.lang.String,
;; java.lang.Class.
;;
;; According to the JVM spec, exception should be thrown.
;;
;; However in KVM, fatalError is thrown. Programs that relies on the exception
;; being thrown will terminate.
;; 
;; note 1: This file, we included a simplified loader, which doesn't throw exception. 
;; instead it throws a fatal exception, which means during loading no exception
;; will be thrown.  This is "faithful" to the KVM except KVM doesn't fatalError
;; in less cases, instead it mark ClASS_ERROR in a few cases.
</span>

<span class="comment">;(i-am-here)
</span>
<span class="comment">;;
;; this following function blindly load the class of name class-name
;;
</span>
(<span class="keyword">defun</span> <span class="function-name">build-a-java-visible-instance-guard-strong</span> (s)
  (and (wff-state s)
       (wff-class-table (class-table s))
       (wff-instance-class-table-strong (instance-class-table s))
       (wff-env (env s))
       (wff-static-class-table-strong (external-class-table s))
       (loader-inv s)
       (build-a-java-visible-instance-data-guard
        (all-class-names (instance-class-table s)) s)))

<span class="comment">;;
;; build-a-java-visible-instance-data-guard asserts wff-fields. 
;; 
</span>
<span class="comment">;(i-am-here)
</span>
(<span class="keyword">defun</span> <span class="function-name">load_class2_guard</span> (classname s)
  (mylet* ((env (env s))
           (class-table (class-table s))
           (scl (env-class-table env)))
    (and (wff-state s)
         (wff-env env)
         (wff-heap (heap s))
         (wff-class-table class-table)
         <span class="comment">;(build-a-java-visible-instance-guard-strong s)
</span>         <span class="comment">;; this asserts every class decl in instance-class-table is well
</span>         <span class="comment">;; formed (we can build data fields belong to those classes.
</span>         <span class="comment">;; We also need to to assert that all the super classes are loaded!! 
</span>         <span class="comment">;; but can we assert it here??
</span>         <span class="comment">;; will I still be able to prove the property? I should. 
</span>         <span class="comment">;; Wed Jun 23 18:38:17 2004
</span>         
         <span class="comment">;; Add new assertions about all supers are loaded. 
</span>         <span class="comment">;; Thu Jun 24 14:35:28 2004
</span>         (loader-inv s)
         (all-correctly-loaded? 
          (cdr (collect-superclassname classname (external-class-table s)))
          (instance-class-table s)
          (external-class-table s))
         (all-correctly-loaded? 
          (cdr (collect-superinterface classname (external-class-table s)))
          (instance-class-table s)
          (external-class-table s))
         <span class="comment">;;
</span>         <span class="comment">;; in load_class2, we only need to make sure java.lang.Object and
</span>         <span class="comment">;; java.lang.Class are loaded. java.lang.String as well. 
</span>         <span class="comment">;; 
</span>         <span class="comment">;; Before we are allowed to call load_class2, we need to assert all
</span>         <span class="comment">;; super are loaded!! 
</span>         <span class="comment">;; added to assert that classname's super are loaded.
</span>         <span class="comment">;; (build-a-java-visible-instance-guard-strong s)
</span>         (wff-static-class-table scl)
         (mv-let (found class-desc)
                 (class-by-name-s classname scl)
                 (mylet* ((static-cp  (constantpool-s class-desc))
                          (static-field-table (fields-s class-desc))
                          (static-method-table (methods-s class-desc)))
                 (or (not found)
                     (and (wff-class-rep-static class-desc)
                          (load_CP_entries_guard static-cp s)
                          (build-a-java-visible-instance-guard <span class="string">"java.lang.Class"</span> s)
                          (wff-fields-s static-field-table)
                          (runtime-method-rep-guards static-method-table))))))))


(in-theory (disable <span class="comment">;; load_CP_entries 
</span>                    wff-class-rep-static
                    add-instance-class-entry classname-s 
                    make-runtime-class-rep make-class-table
                    array-class-table  wff-state wff-heap
                    build-a-java-visible-instance-guard
                    fields-s methods-s interfaces-s))

(defthm wff-heap-implies-alistp
  (implies (wff-heap hp)
           (alistp hp)))

(defthm wff-heap-implies-alistp-specific
  (implies (wff-heap (heap s))
           (alistp (heap (mv-nth 1 (load_CP_entries cps s)))))
  <span class="builtin">:hints</span> ((<span class="string">"Goal"</span> <span class="builtin">:in-theory</span> (disable load_CP_entries))))

<span class="comment">;(i-am-here)
</span>
<span class="comment">;; (i-am-here) ;; Sat Nov  6 15:39:57 2004
</span>
<span class="comment">;; Sun Nov  7 16:02:30 2004
</span>
(defthm load-cp-entry-wff-constant-pool
  (implies (wff-constant-pool-entry-s cp)
           (wff-constant-pool-entry (car (load_cp_entry cp s)))))


(defthm load-cp-entries-wff-constant-pool
  (implies (wff-constant-pool-s cp)
           (wff-constant-pool (car (load_cp_entries cp s))))
  <span class="builtin">:hints</span> ((<span class="string">"Goal"</span> <span class="builtin">:in-theory</span> (disable wff-constant-pool-entry-s
                                      load_cp_entry
                                      wff-constant-pool-entry))))


(defthm wff-constant-pool-s-implied-by-wff-static-class-table
  (implies (and (wff-static-class-table-strong scl)
                (car (class-by-name-s classname scl)))
           (wff-constant-pool-s 
            (CDR (NTH 3
                      (MV-NTH 1
                              (CLASS-BY-NAME-S CLASSNAME scl)))))))


(defthm wff-constant-pool-s-implied-by-wff-static-class-table-constant-pool
  (implies (and (wff-static-class-table-strong scl)
                (car (class-by-name-s classname scl)))
           (wff-constant-pool-s 
            (constantpool-s 
                      (MV-NTH 1
                              (CLASS-BY-NAME-S CLASSNAME scl))))))

(defthm true-listp-load_cp_entries
  (true-listp (car (load_cp_entries cp s)))
  <span class="builtin">:hints</span> ((<span class="string">"Goal"</span> <span class="builtin">:in-theory</span> (disable load_cp_entry))))

(defthm len-equal-load-cpentries
  (equal (len (car (load_cp_entries cps s)))
         (len cps))
  <span class="builtin">:hints</span> ((<span class="string">"Goal"</span> <span class="builtin">:in-theory</span> (disable load_cp_entry))))


(defthm load_cp_entry-no-change-centry-type
  (equal (cpentry-type (car (load_cp_entry cp s)))
         (cpentry-type-s cp)))

(defthm load_cp_entry-no-change-centry-value
  (implies (primitive-type? (cpentry-type-s cp))
           (equal (cpentry-value (car (load_cp_entry cp s)))
                  (cpentry-value-s cp))))


<span class="comment">;; (defthm cdr-load_cp_entires-is-load_cp_entries-cdr
;;   (equal (cdr (car (load_cp_entries cps s)))
;;          (car (load_cp_entries (cdr cps) s)))
;;   :hints (("Goal" :in-theory (disable load_cp_entry)
;;            :do-not '(generalize))))
</span>
<span class="comment">;;;
;;; this is not true. because the different of heap object creation order!! 
;;;  
</span>

<span class="comment">;; (defthm nth-i-load_cp_entries-is-load_cp_entry_nth
;;   (equal (nth i (car (load_cp_entries cps s)))
;;          (car (load_cp_entry (nth i cps) s)))
;;   :hints (("Goal" :in-theory (disable load_cp_entry)
;;            :do-not '(generalize))))
</span>



(defthm centry-type-no-change-load_cp_entries
  (equal (cpentry-type (nth i (car (load_cp_entries cps s))))
         (cpentry-type-s (nth i cps)))
  <span class="builtin">:hints</span> ((<span class="string">"Goal"</span> <span class="builtin">:in-theory</span> (disable load_cp_entry)
           <span class="builtin">:do-not</span> '(generalize))
          (<span class="string">"Subgoal *1/2.2"</span> <span class="builtin">:expand</span> (LOAD_CP_ENTRY cps1 S))
          (<span class="string">"Subgoal *1/2.1"</span> <span class="builtin">:expand</span> (LOAD_CP_ENTRY (cons cps3 cps4) S))))


(defthm centry-value-no-change-load_cp_entries
  (implies (primitive-type? (cpentry-type-s (nth i cps)))
           (equal (cpentry-value (nth i (car (load_cp_entries cps s))))
                  (cpentry-value-s (nth i cps))))
  <span class="builtin">:hints</span> ((<span class="string">"Goal"</span> <span class="builtin">:in-theory</span> (disable 
                              cpentry-value-s
                              cpentry-value
                              load_cp_entry primitive-type?)
           <span class="builtin">:do-not</span> '(generalize))
          (<span class="string">"Subgoal *1/2.2"</span> <span class="builtin">:expand</span> (LOAD_CP_ENTRY cps1 S))
          (<span class="string">"Subgoal *1/2.1"</span> <span class="builtin">:expand</span> (LOAD_CP_ENTRY (cons cps3 cps4) S))))



<span class="comment">;; (i-am-here) ;; Wed Nov 10 20:50:15 2004
</span>
<span class="comment">;; (i-am-here) ;; Thu Jan  5 19:10:13 2006
</span>
<span class="comment">;; (i-am-here) ;; Thu Jan  5 20:48:00 2006
</span>
(defthm wff-static-cp-ok-s-implied-by-wff-static-class-table
  (implies (wff-static-cp-ok-s fields-s static-cp)
           (wff-static-cp-ok fields-s
                             (car (load_cp_entries static-cp s))))
  <span class="builtin">:hints</span> ((<span class="string">"Goal"</span> <span class="builtin">:do-not</span> '(generalize)
           <span class="builtin">:in-theory</span> (disable load_cp_entry))))
                                                       
(defthm wff-static-class-table-strong-and-exists-implies-wff-static-cp-ok-s
  (implies (and (wff-static-class-table-strong scl)
                (car (class-by-name-s name scl)))
           (wff-static-cp-ok-s 
            (fields-s (mv-nth 1 (class-by-name-s name scl)))
            (constantpool-s (mv-nth 1 (class-by-name-s name scl))))))

<span class="comment">;; (defthm  wff-static-class-table-strong-test
;;   (not (wff-static-class-table-strong scl)))
</span>
(<span class="keyword">defun</span> <span class="function-name">load_class2</span> (classname s)
  (<span class="keyword">declare</span> (xargs <span class="builtin">:guard</span> (load_class2_guard classname s)
                  <span class="builtin">:guard-hints</span> ((<span class="string">"Goal"</span> <span class="builtin">:in-theory</span> (disable load_CP_entry constantpool-s)))))
  (<span class="keyword">let*</span> ((scl (env-class-table (env s)))
         (dcl (instance-class-table s)))
         (mv-let 
          (def-found class-desc)
          (class-by-name-s classname scl)
          (<span class="keyword">if</span> (not def-found)
              (fatalError <span class="string">"java.lang.ClassNotFoundException"</span> s)
            (<span class="keyword">let</span>  ((static-cp  (constantpool-s class-desc)))
              (mv-let 
               (dynamic-cp  new-state)  
               (load_CP static-cp  s)
               (mv-let (the-Class-object new-state2)
                       (build-an-instanceClass classname new-state)
                       (<span class="keyword">let*</span> ((heap-with-strings (heap new-state2))
                              (new-address (alloc heap-with-strings))
                              (new-heap    (bind new-address the-Class-object
                                                 heap-with-strings)) 
                              <span class="comment">;; new heap
</span>                              (runtime-class-rep 
                               (make-runtime-class-rep 
                                (classname-s class-desc)
                                (super-s class-desc)
                                dynamic-cp
                                (runtime-instance-fields-rep 
                                 (fields-s class-desc) classname)                    
                                (runtime-methods-rep 
                                 (methods-s class-desc) classname)
                                 (interfaces-s class-desc)
                                (runtime-static-fields-rep 
                                 (fields-s class-desc) classname dynamic-cp)
                                *class_loaded*  <span class="comment">;;   -- 2
</span>                                (accessflags-s class-desc) 
                                -1            <span class="comment">;; indicate the non-init-thread
</span>                                new-address)) <span class="comment">;; reference to ClassObject in the java heap
</span>                              (new-dcl (add-instance-class-entry
                                              runtime-class-rep dcl))) 
                         <span class="comment">;; using cons instead of using bind.
</span>                         (prog2$ (acl2::debug-print <span class="string">"class loading ~p0 complete! ~%"</span> classname) 
                                 (update-trace new-address 
                                               (state-set-heap new-heap
                                                   (state-set-class-table
                                                    (make-class-table new-dcl 
                                                                      (array-class-table new-state2))
                                                    new-state2))))))))))))

<span class="comment">;; modified to use <a href="../common/primitives.lisp.html">primitives</a> of state-set-heap
;; state-set-class-table to hide the fact of state is composed of 7-8 slots
</span>

<span class="comment">;; (defstub loader-measure (* * *) =&gt; *)
;; --- start to prove the admissibility of the mutual recursion -
</span>(<span class="keyword">defun</span> <span class="function-name">load-class-x-guard</span> (s seen)
  (and (wff-state s)
       (wff-env (env s))
       (wff-static-class-table 
        (env-class-table (env s)))
       (true-listp seen)))


(<span class="keyword">defun</span> <span class="function-name">unloaded-class-count</span> (s seen)
  (<span class="keyword">declare</span> (xargs <span class="builtin">:guard</span> (load-class-x-guard s seen)))
  (<span class="keyword">let</span> ((cl (env-class-table (env s))))
    (+ 1 (len (set-diff (all-class-names-s cl) seen)))))


(<span class="keyword">defun</span> <span class="function-name">loader-measure</span> (stage s seen)
  (<span class="keyword">declare</span> (xargs <span class="builtin">:guard</span> (load-class-x-guard s seen)))
   (cons (cons (unloaded-class-count s seen) 0) stage))


(<span class="keyword">defun</span> <span class="function-name">load_class_1-inv</span> (classname s seen)
  (<span class="keyword">declare</span> (xargs <span class="builtin">:guard</span> (load-class-x-guard s seen)))
  (and (not (mem classname seen))
       (mem classname (all-class-names-s (env-class-table (env s))))))

(<span class="keyword">defun</span> <span class="function-name">load_class_2-inv</span> (classname s seen)
  (<span class="keyword">declare</span> (xargs <span class="builtin">:guard</span> (load-class-x-guard s seen)))
  (and (not (mem classname seen))
       (mem classname (all-class-names-s (env-class-table (env s))))))

(<span class="keyword">defun</span> <span class="function-name">trivial-inv-env-do-not-change</span> (s1 s2)
  (<span class="keyword">declare</span> (xargs <span class="builtin">:guard</span> (and (wff-state s1)
                              (wff-state s2))))
  (equal (env s1) (env s2)))



(in-theory (disable class-loaded? env env-class-table no-fatal-error? load_class2))


(<span class="keyword">defun</span> <span class="function-name">induct-measure</span> (p s seen mode)
  (<span class="keyword">declare</span> (xargs <span class="builtin">:guard</span> (load-class-x-guard s seen)))
  (<span class="keyword">cond</span> ((equal mode 3) (loader-measure 3 s seen))
        ((equal mode 2) (loader-measure 2 s seen))
        ((equal mode 1) (loader-measure 1 s seen))
        ((equal mode 0) (loader-measure (+ 4 (len p)) s seen))
        (t 0)))


(acl2::set-verify-guards-eagerness 0) 

(<span class="keyword">defun</span> <span class="function-name">load_class_x</span> (p s seen mode)
  (<span class="keyword">declare</span> (xargs <span class="builtin">:measure</span> (induct-measure p s seen mode)
                  <span class="builtin">:guard</span> (and (loader-inv s)
                              (wff-heap (heap s))
                              (class-loaded? <span class="string">"java.lang.Object"</span> s)
                              (class-loaded? <span class="string">"java.lang.Class"</span> s)
                              (true-listp seen))))
  <span class="comment">;; we may be able to write stronger guards 
</span>  <span class="comment">;; but loader-inv is only necessary.
</span>  (<span class="keyword">let</span> ((classname p)
        (interfaces p))
  (<span class="keyword">if</span> (not (no-fatal-error? s)) 
      s
    (<span class="keyword">cond</span> ((equal mode 3) 
           (prog2$ (acl2::debug-print <span class="string">" load request ~p0 received!~%"</span> classname)
                   (<span class="keyword">if</span> (class-loaded? classname s)
                       (prog2$ (acl2::debug-print <span class="string">"class  ~p0 already loaded!~%"</span> classname)
                               s)
                     (<span class="keyword">if</span> (mem classname seen)
                         (fatalError <span class="string">"java.lang.ClassCircularityError"</span> s)<span class="comment">;; ref to note 1
</span>                       (mv-let 
                        (def-found class-desc)
                        (class-by-name-s classname (external-class-table s))
                        (<span class="keyword">declare</span> (ignore class-desc))
                        (<span class="keyword">if</span> (not def-found)
                            (fatalError <span class="string">"java.lang.ClassNotFoundException"</span> s)<span class="comment">;; note 1
</span>                          (<span class="keyword">let</span> ((s1 (load_class_x classname s seen 2)))
                            (<span class="keyword">if</span> (not (trivial-inv-env-do-not-change s1 s))
                                (fatalError <span class="string">"load_class_1 violate internal inv"</span> s1)
                              (<span class="keyword">if</span> (no-fatal-error? s1)
                                  (<span class="keyword">let</span> ((s2 (load_class_x classname s1 seen 1)))
                                    (<span class="keyword">if</span> (no-fatal-error? s2)
                                        (load_class2 classname s2)
                                      s2))
                                s1)))))))))
           ((equal mode 2)
            (<span class="keyword">if</span> (not (load_class_1-inv classname s seen))
                (fatalError <span class="string">"load_class_1 violate internal inv"</span> s)
              (mv-let 
               (def-found class-desc)
               (class-by-name-s classname (external-class-table s))
               (<span class="keyword">declare</span> (ignore def-found))
               (<span class="keyword">let*</span> ((supername (super-s class-desc))
                      (new-state (load_class_x supername s (cons classname seen) 3)))
                 new-state))))
           ((equal mode 1)
            (<span class="keyword">if</span> (not (load_class_2-inv classname s seen))
                (fatalError <span class="string">"load_class_2 violate internal inv"</span> s)
              (mv-let (def-found static-class-rep)
                      (class-by-name-s classname (external-class-table s))
                      (<span class="keyword">declare</span> (ignore def-found))
                      (<span class="keyword">let</span> ((interfaces (interfaces-s static-class-rep)))
                        (load_class_x interfaces s (cons classname seen) 0)))))
           ((equal mode 0)
            (<span class="keyword">if</span> (not (consp interfaces))
                s
              <span class="comment">;; assuming no array  
</span>              <span class="comment">;; doesn't check whether a class implments a class, instead of an
</span>              <span class="comment">;; interfaces. ;; don't check access 
</span>              (<span class="keyword">if</span> (no-fatal-error? s)
                  (<span class="keyword">if</span> (mem (car interfaces) seen)
                      (fatalError <span class="string">"interface circularity"</span> s)
                    (<span class="keyword">if</span> (class-loaded? (car interfaces) s)
                        (<span class="keyword">let</span> ((class-rep (class-by-name (car interfaces)
                                                        (instance-class-table s))))
                          (<span class="keyword">if</span> (not (isInterface class-rep))
                              (fatalError <span class="string">"here class implements non interfaces"</span> s)
                            (load_class_x (cdr interfaces) s seen 0)))
                      (<span class="keyword">let*</span> ((new-s (load_class_x (car interfaces) s seen 3))
                             (class-rep (class-by-name (car interfaces)
                                                       (instance-class-table new-s))))
                        (<span class="keyword">if</span> (not (trivial-inv-env-do-not-change new-s s))
                            (fatalError <span class="string">"load_class_1 violate internal inv"</span> new-s)
                          (<span class="keyword">if</span> (no-fatal-error? new-s)
                              (<span class="keyword">if</span> (not (isInterface class-rep))
                                  (fatalError <span class="string">"class implements non interfaces"</span> new-s)
                                (load_class_x (cdr interfaces) new-s seen 0))
                            new-s)))))
                s)))
           (t s)))))

<span class="comment">;;
;; move guard verification to the later Guard verification relies on a
;; load_class_x perserve certain invariant on the class-table!!  which is
;; not easy to do guard verification before the function is admitted!!
;; Tue Apr  6 20:55:22 2004
;;
</span>
<span class="comment">;;
;; set the current thread to -1 to indicate the loading is done by JVM 
;; the obj created belongs to all threads. 
;;
</span>(acl2::set-verify-guards-eagerness 2)

(<span class="keyword">defun</span> <span class="function-name">load_class-guard</span> (s)
  (and (loader-inv s)
       (wff-heap (heap s))
       (class-loaded? <span class="string">"java.lang.Object"</span> s)
       (class-loaded? <span class="string">"java.lang.Class"</span> s)))

<span class="comment">;;(verify-guards load_class-guard)
</span>
(acl2::set-verify-guards-eagerness 0)

(<span class="keyword">defun</span> <span class="function-name">load_class</span> (classname s)
  (<span class="keyword">declare</span> (xargs <span class="builtin">:guard</span> (load_class-guard s)))
  (<span class="keyword">let</span> ((th  (current-thread s))
        (s1  (state-set-current-thread -1 s)))
    (state-set-current-thread th (load_class_x classname s1 nil 3))))

(acl2::set-verify-guards-eagerness 2)
<span class="comment">;; inferring the accessflags for array classes
</span>

(<span class="keyword">defun</span> <span class="function-name">gen-access-flags-guard</span> (base-type s)
  (and (wff-state s)
       (wff-class-table (class-table s))
       <span class="comment">;; why I need the following?? 
</span>       (<span class="keyword">if</span> (array-type? base-type)
           (and (wff-array-class-table (array-class-table s))
                (wff-array-class-table-rep 
                 (array-class-by-name base-type 
                                      (array-class-table s))))
         (<span class="keyword">if</span> (primitive-type? base-type) t
           (and (wff-instance-class-table
                 (instance-class-table s))
                (wff-class-rep (class-by-name base-type 
                                              (instance-class-table s))))))))
                         
(<span class="keyword">defun</span> <span class="function-name">gen-access-flags</span> (base-type S)<span class="comment">;; assume the base-type is loaded
</span>  (<span class="keyword">declare</span> (xargs <span class="builtin">:guard</span> (gen-access-flags-guard base-type s)
                  <span class="builtin">:guard-hints</span> ((<span class="string">"Goal"</span> <span class="builtin">:in-theory</span> (disable array-type?)))))
  (<span class="keyword">if</span> (array-type? base-type)
      (<span class="keyword">let*</span> ((array-class-rep 
              (array-class-by-name base-type
                                   (array-class-table S)))
             (access-flags  (array-access-flags array-class-rep)))
        (<span class="keyword">if</span> (mem '*public* access-flags)
            (make-accessflags '(*final* *abstract* *array_class* *public*))
          (make-accessflags '(*final* *abstract* *array_class*))))
    (<span class="keyword">if</span> (primitive-type? base-type)
        (make-accessflags '(*final* *abstract* *array_class* *public*))
      <span class="comment">;; has to be instance-class
</span>      (<span class="keyword">let*</span> ((instance-class-rep 
              (class-by-name base-type (instance-class-table S)))
             (access-flags (class-accessflags instance-class-rep)))
        (<span class="keyword">if</span> (mem '*public* access-flags)
            (make-accessflags '(*final* *abstract* *array_class* *public*))
          (make-accessflags '(*final* *abstract* *array_class*)))))))

<span class="comment">;;;; ACCESS TO THE ARRAY CLASS IS DEFINED BY CHECKING THE ACCESS TO THE BASE
;;;; TYPE!!
</span>
<span class="comment">;; this load_array_clas2  doesn't test wether this (array <a href="../DJVM/INST/base.lisp.html">base</a>) type exist or
;; not.  always build an instanceClass object that represent the class.
;; simplify the getArrayClass
</span>  
<span class="comment">;; We assume that the <a href="../DJVM/INST/base.lisp.html">base</a> class is loaded already but (array <a href="../DJVM/INST/base.lisp.html">base</a>-class)
;; haven't be loaded.
</span>
<span class="comment">;;
;; the shape of an entry in the array class table: 
;;
;;         (array-type access-flags the-class-obj-ref)
;;
;;
;;
;; (defun array-base-types (type)
;;   (if (array-type? type)
;;       (cons type (array-base-types (array-base-type type)))
;;     type))
;;
;; (defun all-array-class-loaded (
</span>


(<span class="keyword">defun</span> <span class="function-name">base-types</span> (type)
  (<span class="keyword">if</span> (array-type? type)
      (cons type (base-types (array-base-type type)))
    (list type)))

(<span class="keyword">defun</span> <span class="function-name">array-class-correctly-loaded?</span> (types s)
  (<span class="keyword">declare</span> (xargs <span class="builtin">:guard</span> (and (wff-state s)
                              (wff-class-table (class-table s))
                              (wff-instance-class-table (instance-class-table s))
                              (wff-array-class-table (array-class-table s)))))
  (<span class="keyword">if</span> (not (consp types)) t
    (and (<span class="keyword">if</span> (array-type? (car types))
             (ArrayClassLoaded? (array-base-type (car types)) s)
           (<span class="keyword">if</span> (primitive-type? (car types)) t
             (class-loaded? (car types) s)))
         (array-class-correctly-loaded? (cdr types) s))))

                           
(<span class="keyword">defun</span> <span class="function-name">array-class-table-inv-helper</span> (l s)
  (<span class="keyword">declare</span> (xargs <span class="builtin">:guard</span> (and (wff-state s)
                              (wff-class-table (class-table s))
                              (wff-instance-class-table (instance-class-table s))
                              (wff-array-class-table (array-class-table s)))))
  (<span class="keyword">if</span> (not (consp l)) t
    (and (array-type? (car l))
         (array-class-correctly-loaded? (base-types (car l)) s)
         (array-class-table-inv-helper (cdr l) s))))




(<span class="keyword">defun</span> <span class="function-name">all-array-sigs</span> (l) 
  (<span class="keyword">declare</span> (xargs <span class="builtin">:guard</span> (wff-array-class-table l)))
  (<span class="keyword">if</span> (not (consp l)) nil
    (cons (array-sig (car l))
          (all-array-sigs (cdr l)))))
      


(<span class="keyword">defun</span> <span class="function-name">load_array_class2-guard</span> (base-type s)
  (and (build-a-java-visible-instance-guard <span class="string">"java.lang.Class"</span> s)
       (wff-state s)
       (wff-heap (heap s))
       (or (not (array-type? base-type))
           (gen-access-flags-guard (array-base-type base-type) s))
       (wff-class-table (class-table s))
       (wff-instance-class-table (instance-class-table s))
       (wff-array-class-table (array-class-table s))
       (not (ArrayClassLoaded? base-type s)) 
       (array-class-table-inv-helper (all-array-sigs (array-class-table s)) s)
       <span class="comment">;; only called when base-type is not loaded! 
</span>       (<span class="keyword">if</span> (array-type? base-type)
           (ArrayClassLoaded? (array-base-type base-type) s)
         <span class="comment">;; all <a href="../DJVM/INST/base.lisp.html">base</a> type must be loaded!! 
</span>         (<span class="keyword">if</span> (primitive-type? base-type)
             t
           (class-loaded? base-type s)))))



<span class="comment">;; (defun load_array_class2-guard (base-type s)
;;   (and (build-a-java-visible-instance-guard "java.lang.Class" s)
;;        (wff-state s)
;;        (wff-heap (heap s))
;;        (or (not (array-type? base-type))
;;            (gen-access-flags-guard (array-base-type base-type) s))
;;        (wff-class-table (class-table s))
;;        (wff-instance-class-table (instance-class-table s))
;;        (wff-array-class-table (array-class-table s))
;;        (not (ArrayClassLoaded? base-type s)) 
;;        ;; only called when base-type is not loaded! 
;;        (if (array-type? base-type)
;;            (and (ArrayClassLoaded? (array-base-type base-type) s)
;;                 (array-class-table-inv-helper (base-types (array-base-type
;;                                                            base-type))
;;                                               s))
;;          ;; all <a href="../DJVM/INST/base.lisp.html">base</a> type must be loaded!! 
;;          (if (primitive-type? base-type)
;;              t
;;            (class-loaded? base-type s)))))
</span>

(acl2::set-verify-guards-eagerness 0)


(<span class="keyword">defun</span> <span class="function-name">load_array_class2</span> (base-type S)
  (<span class="keyword">declare</span> (xargs <span class="builtin">:guard</span> (load_array_class2-guard base-type s)))
  (mv-let (array-class-rep-obj new-S)
          (build-instanceClassArrayClass base-type S)
          (<span class="keyword">let*</span> ((heap (heap new-S))
                 (new-addr (alloc heap))
                 (new-heap (bind new-addr array-class-rep-obj heap))
                 (access-flags (gen-access-flags base-type S))
                 (array-class-rep 
                  (make-array-class-table-entry base-type access-flags new-addr))
                 (old-array-class-table (array-class-table S))
                 (new-array-class-table 
                  (add-array-class-table-entry array-class-rep
                                               old-array-class-table)))
            (state-set-array-class-table new-array-class-table
                                         (update-trace new-addr (state-set-heap
                                                                 new-heap
                                                                 new-s))))))


<span class="comment">;;; this create a class-rep that reps `(array ,base-type)
;;;
</span>
<span class="comment">;; what if the <a href="../DJVM/INST/base.lisp.html">base</a> class doesn't exist?  We can make the guard to say the <a href="../DJVM/INST/base.lisp.html">base</a>
;; type is loaded! So far it is not. FIXED! Tue Apr  6 21:12:39 2004
</span>
<span class="comment">;;
;; this loader will load the <a href="../DJVM/INST/base.lisp.html">base</a> array class. (different from the original loader).
;;
</span>
<span class="comment">;; (acl2::set-verify-guards-eagerness 2)
;; (defun all-array-sigs (l) 
;;   (declare (xargs :guard (wff-array-class-table l)))
;;   (if (not (consp l)) nil
;;     (cons (array-sig (car l))
;;           (all-array-sigs (cdr l)))))
</span>      

(acl2::set-verify-guards-eagerness 2)
(<span class="keyword">defun</span> <span class="function-name">load_array_class_guard</span> (s)
  (and (load_class-guard s)
       (build-a-java-visible-instance-guard <span class="string">"java.lang.Class"</span> s)
       (wff-array-class-table (array-class-table s))
       (wff-instance-class-table (instance-class-table s))
       (wff-env (env s))
       (wff-static-class-table (external-class-table s))
       (array-class-table-inv-helper (all-array-sigs (array-class-table s)) s)))


<span class="comment">;(acl2::set-verify-guards-eagerness 0)
</span>
<span class="comment">;(i-am-here)
</span>
(acl2::set-verify-guards-eagerness 0)

(<span class="keyword">defun</span> <span class="function-name">load_array_class</span> (base-type S)
  (<span class="keyword">declare</span> (xargs <span class="builtin">:guard</span> (load_array_class_guard s)))
  (<span class="keyword">if</span> (not (no-fatal-error? s))
      s
    (<span class="keyword">if</span> (ArrayClassLoaded? base-type S)
        s
      (<span class="keyword">if</span> (array-type? base-type)
          (<span class="keyword">let</span> ((s1  (load_array_class 
                      (array-base-type base-type) S)))
            (<span class="keyword">if</span> (not (no-fatal-error? s1))
                s1
              (load_array_class2 base-type s1)))
        (<span class="keyword">if</span> (primitive-type? base-type)
            (load_array_class2 base-type s)
          (<span class="keyword">if</span> (class-loaded? base-type S)
              (load_array_class2 base-type S)
            (<span class="keyword">let</span> ((s1 (load_class base-type s)))
              (<span class="keyword">if</span> (not (no-fatal-error? s1))
                  s1
                (load_array_class2 base-type s1)))))))))

(acl2::set-verify-guards-eagerness 2)

<span class="comment">;; (defun gen-access-flags-guard (base-type s)
;;   (and (wff-state s)
;;        (wff-class-table (class-table s))
;;        (if (array-type? base-type)
;;            (and (wff-array-class-table (array-class-table s))
;;                 (wff-array-class-table-rep 
;;                  (array-class-by-name base-type 
;;                                       (array-class-table s))))
;;          (if (primitive-type? base-type) t
;;            (and (wff-instance-class-table
;;                  (instance-class-table s))
;;                 (wff-class-rep (class-by-name base-type 
;;                                               (instance-class-table s))))))))
</span>
<span class="comment">;;
;;
;; (defun primitive-types (primitive-types)
;;   (if (not (consp primitive-types)) t
;;     (and (primitive-type? (car primitive-types))
;;          (primitive-types (cdr primitive-types))))
;;
;;
</span>
(<span class="keyword">defun</span> <span class="function-name">load_primitive_array_classes-guard</span> (types s)
  (<span class="keyword">if</span> (not (consp types)) t
    (and (load_array_class2-guard (car types) s)
         (load_primitive_array_classes-guard (cdr types) s))))
      

(acl2::set-verify-guards-eagerness 0)
(<span class="keyword">defun</span> <span class="function-name">load_primitive_array_classes</span> (primitive-types s)
  (<span class="keyword">declare</span> (xargs <span class="builtin">:guard</span> (load_primitive_array_classes-guard primitive-types s)))
  (<span class="keyword">if</span> (not (consp primitive-types))
      s
    (load_primitive_array_classes (cdr primitive-types) 
                                  (load_array_class2 (car primitive-types) s))))


<span class="comment">;-------------------------------
</span>
<span class="comment">;; The interface that the other part of the system will use more often.
</span>
(<span class="keyword">defun</span> <span class="function-name">getClass</span> (classname s)
  (<span class="keyword">declare</span> (xargs <span class="builtin">:guard</span> (load_class-guard s)))
  (<span class="keyword">if</span> (class-loaded? classname s)
      s
    (load_class classname s)))

(<span class="keyword">defun</span> <span class="function-name">getArrayClass11</span> (basetype S)
  (<span class="keyword">declare</span> (xargs <span class="builtin">:guard</span> (load_array_class_guard s)))
  (load_array_class basetype S))

(<span class="keyword">defun</span> <span class="function-name">getArrayClass</span> (basetype S)
  (<span class="keyword">declare</span> (xargs <span class="builtin">:guard</span> (load_array_class_guard s)))
  (<span class="keyword">if</span> (ArrayClassLoaded? basetype s)
      s
    (load_array_class basetype S)))

<span class="comment">;------------------------------
</span>
(<span class="keyword">defun</span> <span class="function-name">load-JavaSystemClasses</span> (s) 
  (<span class="keyword">let*</span> ((th (current-thread s))
         (s0 (state-set-current-thread -1 s))
         (s1 (load_class2 <span class="string">"java.lang.Object"</span> s0))
         (s2 (load_class2 <span class="string">"java.lang.Class"</span>  s1))
         (s3 (load_class2 <span class="string">"java.lang.String"</span> s2))
         (s4 (load_primitive_array_classes *primitive-types* s3))
         (s5 (load_class <span class="string">"java.lang.System"</span> s4))
         (s6 (load_class <span class="string">"java.lang.Thread"</span> s5))
         (s7 (load_class <span class="string">"java.lang.Throwable"</span> s6))
         (s8 (load_class <span class="string">"java.lang.Error"</span> s7))
         (s9 (state-set-current-thread th s8)))
    s9))
<span class="comment">;;; Wed Mar 31 21:53:47 2004. this may never guard verify because 
;;; load_class2 need a guard saying "java.lang.Object"  exists
</span>

(<span class="keyword">defun</span> <span class="function-name">load_classes</span> (nl s)
  (<span class="keyword">declare</span> (xargs <span class="builtin">:guard</span> (load_class-guard s)))
  (<span class="keyword">if</span> (not (consp nl))
      s
    (load_class (car nl) 
                (load_classes (cdr nl) s))))


<span class="comment">;------------ class loader property --------------------
</span>

(<span class="keyword">defun</span> <span class="function-name">class-exists-externally?</span> (from cl)
  (<span class="keyword">declare</span> (xargs <span class="builtin">:guard</span> (wff-static-class-table cl)))
  (mem from (all-class-names-s cl)))



(defthm fatalError-no-fatal-error?
  (implies (stringp msg)
           (not (no-fatal-error? (fatalError msg s))))
  <span class="builtin">:hints</span> ((<span class="string">"Goal"</span> <span class="builtin">:in-theory</span> (enable no-fatal-error?))))

(in-theory (disable instance-class-table isInterface super-s))

(defthm load_cp_entry_only_change_class_table_error_flag_heap
  (<span class="keyword">let</span> ((s1 (mv-nth 1 (load_cp_entry cp s0))))
    (and    (equal (pc s1) (pc s0))
            (equal (current-thread s1) (current-thread s0))
            (equal (thread-table   s1) (thread-table s0))
            (equal (env            s1) (env          s0)))))

(in-theory (disable load_cp_entry))

<span class="comment">;; these theorems are not good. Thu Jun 24 12:01:56 2004
</span>
(defthm load_cp_entries_only_change_class_table_error_flag_heap
  (<span class="keyword">let</span> ((s1 (mv-nth 1 (load_cp_entries cps s0))))
    (and    (equal (pc s1) (pc s0))
            (equal (current-thread s1) (current-thread s0))
            (equal (thread-table   s1) (thread-table s0))
            (equal (env            s1) (env          s0)))))
    


(defthm load_class2_only_change_class_table_error_flag_heap
  (<span class="keyword">let</span> ((s1 (load_class2 n s0)))
    (and    (equal (pc s1) (pc s0))
            (equal (current-thread s1) (current-thread s0))
            (equal (thread-table   s1) (thread-table s0))
            (equal (env            s1) (env          s0))))
  <span class="builtin">:hints</span> ((<span class="string">"Goal"</span> <span class="builtin">:in-theory</span> (enable load_class2))))


(defthm load_class_x_only_change_class_table_error_flag_heap
  (implies (or (equal mode 3)
               (equal mode 2)
               (equal mode 1)
               (equal mode 0))
           (<span class="keyword">let</span> ((s1 (load_class_x p s0 seen mode)))
             (and    (equal (pc s1) (pc s0))
                     (equal (current-thread s1) (current-thread s0))
                     (equal (thread-table   s1) (thread-table s0))
                     (equal (env            s1) (env          s0))))))


<span class="comment">;;  acl2 generates an good enough  induction hint.
;;  :hints (("Goal" :induct (loader-induct n_or_ifaces s0 seen mode))))
</span>
(defthm load_class_only_change_class_table_error_flag_heap
  (<span class="keyword">let</span> ((s1 (load_class classname s0)))
    (and    (equal (pc s1) (pc s0))
            (equal (current-thread s1) (current-thread s0))
            (equal (thread-table   s1) (thread-table s0))
              (equal (env            s1) (env          s0))
              )))<span class="comment">;; need to find the measure for admit the load_class
</span>



<span class="comment">;; where I need this? it's a nice property that worth proving though.
;; to admin is superclass
</span>
(<span class="keyword">defun</span> <span class="function-name">classes-exists-externally?</span> (ifaces cl)
  (<span class="keyword">if</span> (endp ifaces)
      t
    (and (class-exists-externally? (car ifaces) cl)
         (classes-exists-externally? (cdr ifaces) cl))))




(in-theory (disable isInterface))




<span class="comment">#|
;; this is not true 
(defthm no-fatal-error?-after-load-class-x-implies-class-exists-externally
  (and (implies (or (equal mode 1)
                    (equal mode 2)
                    (equal mode 3))
                (implies (no-fatal-error? (load_class_x p s seen mode))
                         (class-exists-externally? p (env-class-table (env s)))))
       (implies (equal mode 0)
                (implies (no-fatal-error? (load_class_x p s seen mode))
                         (classes-exists-externally? p (env-class-table (env s)))))))

|#</span>


(<span class="keyword">defun</span> <span class="function-name">all-not-loaded?</span> (classes seen s)
  (<span class="keyword">if</span> (endp classes)
      nil
    (and (not (class-loaded? (car classes) s))
         (all-not-loaded? (cdr classes) (cons (car classes) seen) 
                          (load_class_x (car classes) s seen 3)))))


(in-theory (disable fatalError))
<span class="comment">;; this is true 
</span>(defthm no-fatal-error?-after-load-class-x-implies-class-exists-externally
  (and (implies (or (equal mode 1)
                    (equal mode 2)
                    (equal mode 3))
                (implies (and (no-fatal-error? (load_class_x p s seen mode))
                              (not (class-loaded? p s)))
                         (class-exists-externally? p (env-class-table (env s)))))
       (implies (equal mode 0)
                (implies (and (no-fatal-error? (load_class_x p s seen mode))
                              (all-not-loaded? p seen s))
                         (classes-exists-externally? p (env-class-table (env s))))))
  <span class="builtin">:hints</span> ((<span class="string">"Goal"</span> <span class="builtin">:induct</span> (load_class_x p s seen mode))))

<span class="comment">;; Sun Jun 20 01:57:34 2004
</span>

<span class="comment">; &gt;V d          (DEFUN MAKE-STATE
;                      (IP CUR JAVAHEAP THREAD-TABLE
;                          INTERNAL-CLASS-TABLE ENV ERROR-FLAG AUX)
;                      (LIST 'STATE
;                            IP CUR (CONS 'HEAP JAVAHEAP)
;                            (CONS 'THREAD-TABLE THREAD-TABLE)
;                            INTERNAL-CLASS-TABLE
;                            ENV ERROR-FLAG AUX))
; JVM !&gt;
</span>
<span class="comment">;(i-am-here)
</span>
<span class="comment">;; (i-am-here) ;;; Fri Oct 29 17:50:48 2004
;;
;; modification to get assert heap-init-map
</span>
<span class="comment">;; heap-init-map
</span>

(<span class="keyword">defun</span> <span class="function-name">equiv-aux</span> (aux1 aux2)
  (equal (heap-init-map aux1) 
         (heap-init-map aux2)))

(defequiv equiv-aux)

(defcong equiv-aux equal (heap-init-map aux) 1)
(defcong equiv-aux equiv-aux (aux-set-trace trace aux) 2)

(defthm equiv-aux-aux-set-any
  (equiv-aux (aux-set-trace any aux)
             aux))

<span class="comment">;;; the equiv-aux is added?? !! 
;;; Fri Nov  5 13:43:01 2004
</span>
(<span class="keyword">defun</span> <span class="function-name">equiv-state-except-thread-and-trace</span> (s1 s2) 
  (and <span class="comment">;(equal (pc s1) (pc s2))
</span>       <span class="comment">;(equal (thread-table s1) (thread-table s2))
</span>       (equal (heap s1) (heap s2))
       (equal (class-table s1) (class-table s2))
       (equal (env s1) (env s2))
       (equal (error-flag s1) (error-flag s2))
       (equiv-aux (aux s1) (aux s2))))


(defequiv equiv-state-except-thread-and-trace)



(<span class="keyword">defun</span> <span class="function-name">equiv-tuple-load</span> (tuple1 tuple2)
  (and (equal (mv-nth 0 tuple1) 
              (mv-nth 0 tuple2))
       (equiv-state-except-thread-and-trace (mv-nth 1 tuple1)
                                            (mv-nth 1 tuple2))))

(<span class="keyword">defun</span> <span class="function-name">slot1-tuple-load</span> (tuple)
  (mv-nth 0 tuple))

(<span class="keyword">defun</span> <span class="function-name">slot2-tuple-load</span> (tuple)
  (mv-nth 1 tuple))

<span class="comment">;(i-am-here)
</span>
(defequiv equiv-tuple-load)


(defcong equiv-state-except-thread-and-trace equiv-tuple-load 
  (load_cp_entry cp s) 2
  <span class="builtin">:hints</span> ((<span class="string">"Goal"</span> <span class="builtin">:in-theory</span> (enable load_cp_entry))))

(local (defthm mv-to-slot 
         (and (equal (mv-nth 0 tuple)
                     (slot1-tuple-load tuple))
              (equal (mv-nth 1 tuple)
                     (slot2-tuple-load tuple)))))




(in-theory (disable slot2-tuple-load slot1-tuple-load)) 

(defcong equiv-tuple-load equiv-state-except-thread-and-trace
  (slot2-tuple-load tuple) 1)

(defcong equiv-tuple-load equal
  (slot1-tuple-load tuple) 1)

<span class="comment">;(defcong equiv-state-except-thread-and-trace equal (pc s) 1)
;(defcong equiv-state-except-thread-and-trace equal (thread-table s) 1)
</span>(defcong equiv-state-except-thread-and-trace equal (class-table s) 1)
(defcong equiv-state-except-thread-and-trace equal (heap s) 1)
(defcong equiv-state-except-thread-and-trace equal (error-flag s) 1)
(defcong equiv-state-except-thread-and-trace equal (env s) 1)
(defcong equiv-state-except-thread-and-trace equiv-aux (aux s) 1)

(in-theory (disable equiv-state-except-thread-and-trace equiv-aux aux-set-trace))

<span class="comment">;; (skip-proofs 
;;  (defcong equiv-state-except-thread-and-trace equiv-tuple-load 
;;    (load_cp_entry cp s) 2
;;    :hints (("Goal" :in-theory (disable
;;    equiv-state-except-thread-and-trace)))))
</span>
<span class="comment">;; (defcong equiv-state-except-thread-and-trace equiv-tuple-load 
;;   (load_cp_entry cp s) 2
;;   :hints (("Goal" :in-theory (disable equiv-state-except-thread-and-trace)))))
</span>


(defcong equiv-state-except-thread-and-trace equiv-tuple-load 
  (load_cp_entries cps s) 2
  <span class="builtin">:hints</span> ((<span class="string">"Goal"</span> <span class="builtin">:in-theory</span> (disable equiv-state-except-thread-and-trace))))


<span class="comment">;(i-am-here)
</span>(in-theory (disable equiv-tuple-load))

<span class="comment">; &gt;V d          (DEFUN MAKE-STATE
;                      (IP CUR JAVAHEAP THREAD-TABLE
;                          INTERNAL-CLASS-TABLE ENV ERROR-FLAG AUX)
;                      (LIST 'STATE
;                            IP CUR (CONS 'HEAP JAVAHEAP)
;                            (CONS 'THREAD-TABLE THREAD-TABLE)
;                            INTERNAL-CLASS-TABLE
;                            ENV ERROR-FLAG AUX))
</span>
<span class="comment">;; may be need to write a marco to simulate the named fields
</span>
<span class="comment">;; this is easily looping!! 
</span>
<span class="comment">; (defthm equiv-state-except-thread-and-trace-make-state
;   (equiv-state-except-thread-and-trace 
;    (make-state pc
;                anyth1
;                hp
;                tt
;                cl
;                env
;                ef
;                anyaux1)
;    (make-state pc
;                anyth2
;                hp
;                tt
;                cl
;                env
;                ef
;                anyaux2))
;   :hints (("Goal" :in-theory (enable equiv-state-except-thread-and-trace))))
</span>               


(defthm equiv-state-except-thread-and-trace-make-state
  (implies (equiv-aux anyaux1 anyaux2)
           (equal (equiv-state-except-thread-and-trace 
                   (make-state anypc1
                               anyth1
                               hp
                               anytt1
                               cl
                               env
                               ef
                               anyaux1)
                   (make-state anypc2
                               anyth2
                               hp
                               anytt2
                               cl
                               env
                               ef
                               anyaux2)) t))
  <span class="builtin">:hints</span> ((<span class="string">"Goal"</span> <span class="builtin">:in-theory</span> (enable equiv-state-except-thread-and-trace))))
               


<span class="comment">;; Sun Jun 20 00:00:42 2004. We want to prove the following. We can prove
;; stronger properties. We will prove no-fatal-error earlier.
</span>(defcong equiv-state-except-thread-and-trace
  equiv-state-except-thread-and-trace
  (fatalError any s) 2
  <span class="builtin">:hints</span> ((<span class="string">"Goal"</span> <span class="builtin">:in-theory</span> (enable equiv-state-except-thread-and-trace
                                     fatalError))))



(defcong equiv-state-except-thread-and-trace equiv-tuple-load
  (build-an-instanceClass c s) 2
  <span class="builtin">:hints</span> ((<span class="string">"Goal"</span> <span class="builtin">:in-theory</span> (e/d (equiv-tuple-load slot1-tuple-load) 
                                  (mv-to-slot
                                   equiv-state-except-thread-and-trace)))))

<span class="comment">;; (defcong equiv-state-except-thread-and-trace equiv-tuple-load
;;   (build-an-instanceClass c s) 2
;;   :hints (("Goal" :in-theory (e/d (equiv-tuple-load slot1-tuple-load) 
;;                                   (mv-to-slot
;;                                    equiv-state-except-thread-and-trace)))))
</span>

(defcong equiv-state-except-thread-and-trace equal 
  (instance-class-table s) 1
  <span class="builtin">:hints</span> ((<span class="string">"Goal"</span> <span class="builtin">:in-theory</span> (e/d (instance-class-table) ()))))

(defcong equiv-state-except-thread-and-trace equal 
  (array-class-table s) 1
  <span class="builtin">:hints</span> ((<span class="string">"Goal"</span> <span class="builtin">:in-theory</span> (e/d (array-class-table) ()))))


<span class="comment">;; (defcong equiv-state-except-thread-and-trace equiv-tuple-load
;;     (load_cp_entry any s) 2
;;     :hints (("Goal" :in-theory (e/d (load_cp_entry) (equiv-aux heap-init-map)))))
</span>
<span class="comment">;; (defthm equal-mv-nth-1-slot-2-is
;;   (equal (mv-nth 1 (load_cp_entries cps s))
;;          (slot2-tuple-load (load_cp_entries cps s)))
;;   :hints (("Goal" :in-theory (enable slot2-tuple-load))))
</span>
<span class="comment">;; (defthm heap-init-map-aux-mv-nth-is
;;   (equal (heap-init-map (aux (mv-nth 1 (load_cp_entries any s))))
;;          (heap-init-map (aux (slot2-tuple-load (load_cp_entries any s))))))
</span>

(defthm equiv-aux-aux-set-trace-rewrite
  (and (equal (equiv-aux (aux-set-trace any aux1) aux2)
              (equiv-aux aux1 aux2))
       (equal (equiv-aux aux1 (aux-set-trace any aux2))
              (equiv-aux aux1 aux2))))

(in-theory (disable aux))


(defthm equiv-aux-equiv-state
  (implies (equiv-state-except-thread-and-trace s-equiv s)
           (equal (EQUIV-AUX
                   (AUX
                    (SLOT2-TUPLE-LOAD
                     (BUILD-AN-INSTANCECLASS
                      P
                      (SLOT2-TUPLE-LOAD
                       (LOAD_CP_ENTRIES
                        cps 
                        S)))))
                   (AUX
                    (SLOT2-TUPLE-LOAD
                     (BUILD-AN-INSTANCECLASS
                      P
                      (SLOT2-TUPLE-LOAD
                       (LOAD_CP_ENTRIES
                        cps
                        S-EQUIV)))))) t))
  <span class="builtin">:hints</span> ((<span class="string">"Goal"</span> <span class="builtin">:in-theory</span> (disable build-an-instanceclass))))

<span class="comment">;;;
;;; Fri Oct 29 19:27:03 2004. 
;;;
;;; Backward chaining!! strange!! backward-chaing vs. cong reasoning.
;;;
</span>
(defcong equiv-state-except-thread-and-trace equiv-state-except-thread-and-trace
  (load_class2 p s) 2
  <span class="builtin">:hints</span> ((<span class="string">"Goal"</span> <span class="builtin">:in-theory</span> (e/d (load_class2)
                                  (build-an-instanceClass)))))

<span class="comment">; (defthm fatalerror-equiv-state-state
;   (EQUIV-STATE-EXCEPT-THREAD-AND-TRACE
;    (FATALERROR any S) s)
;   :hints (("Goal" :in-theory (enable equiv-state-except-thread-and-trace fatalerror))))
</span>
(defcong equiv-state-except-thread-and-trace equal 
  (no-fatal-error? s) 1
  <span class="builtin">:hints</span> ((<span class="string">"Goal"</span> <span class="builtin">:in-theory</span> (e/d (no-fatal-error?) ()))))


(<span class="keyword">defun</span> <span class="function-name">load_class_x_induct</span> (p s s-equiv seen mode)
  (<span class="keyword">declare</span> (xargs <span class="builtin">:measure</span> (induct-measure p s seen mode)
                  <span class="builtin">:guard</span> (and (loader-inv s)
                              (loader-inv s-equiv))))
  (<span class="keyword">let</span> ((classname p)
        (interfaces p))
  (<span class="keyword">if</span> (not (no-fatal-error? s)) 
      s
    (<span class="keyword">cond</span> ((equal mode 3) 
           (prog2$ (acl2::debug-print <span class="string">" load request ~p0 received!~%"</span>
                                      classname)
                   (<span class="keyword">cond</span> ((class-loaded? classname s)
                          (list p s s-equiv seen mode))
                         ((class-loaded? classname s-equiv)
                          (list p s s-equiv seen mode))
                         ((mem classname seen)
                          (list p s s-equiv seen mode))
                         (t (mv-let (def-found1 class-desc1)
                                    (class-by-name-s classname
                                                     (external-class-table s))
                                    (<span class="keyword">declare</span> (ignore class-desc1))
                                    (mv-let (def-found2 class-desc2)
                                            (class-by-name-s classname 
                                                             (external-class-table s-equiv))
                                            (<span class="keyword">declare</span> (ignore class-desc2))
                                            (<span class="keyword">cond</span> ((not def-found1)
                                                   (list p s s-equiv seen
                                                         mode))
                                                  ((not def-found2)
                                                   (list p s s-equiv seen
                                                         mode))
                                                  (t (<span class="keyword">let</span> ((s1 (load_class_x
                                                                classname s seen
                                                                2))
                                                           (s1-equiv (load_class_x
                                                                      classname
                                                                      s-equiv seen
                                                                      2)))
                                                       (<span class="keyword">cond</span> ((not
                                                               (trivial-inv-env-do-not-change s1 s))
                                                              (load_class_x_induct 
                                                               classname s s-equiv
                                                               seen
                                                               2))
                                                             ((not
                                                               (trivial-inv-env-do-not-change s1-equiv s))
                                                              (load_class_x_induct
                                                               classname s s-equiv
                                                               seen 2))
                                                             (t 
                                                              (<span class="keyword">cond</span>
                                                                ((not (no-fatal-error? s1))
                                                                 (load_class_x_induct
                                                                  classname s s-equiv
                                                                  seen 2))
                                                                ((not (no-fatal-error? s1-equiv))
                                                                 (load_class_x_induct
                                                                  classname s s-equiv
                                                                  seen 2))
                                                                (t 
                                                                 (list 
                                                                  (load_class_x_induct
                                                                   classname s s-equiv
                                                                   seen 2)
                                                                  (load_class_x_induct
                                                                   classname s1
                                                                   s1-equiv seen 1)))))))))))))))

          ((equal mode 2)
           (<span class="keyword">cond</span> ((not (load_class_1-inv classname s seen))
                  (list p s s-equiv seen mode))
                 ((not (load_class_1-inv classname s-equiv seen))
                  (list p s s-equiv seen mode))
                 (t (mv-let (def-found1 class-desc1)
                            (class-by-name-s classname
                                             (external-class-table s))
                            (<span class="keyword">declare</span> (ignore def-found1))
                            (mv-let (def-found2 class-desc2)
                                    (class-by-name-s classname 
                                                     (external-class-table s-equiv))
                                    (<span class="keyword">declare</span> (ignore def-found2))
                                    (<span class="keyword">let</span> ((supername1 (super-s class-desc1))
                                          (supername2 (super-s class-desc2)))
                                      (<span class="keyword">cond</span> ((not (equal supername1 supername2))
                                             (list p s s-equiv seen mode))
                                            (t (load_class_x_induct supername1 s s-equiv
                                                                    (cons classname
                                                                          seen)
                                                                    3)))))))))
          ((equal mode 1)
           (<span class="keyword">cond</span> ((not (load_class_2-inv classname s seen))
                  (list p s s-equiv seen mode))
                 ((not (load_class_2-inv classname s-equiv seen))
                  (list p s s-equiv seen mode))
                 (t (mv-let (def-found1 class-desc1)
                            (class-by-name-s classname
                                             (external-class-table s))
                            (<span class="keyword">declare</span> (ignore def-found1))
                            (mv-let (def-found2 class-desc2)
                                    (class-by-name-s classname 
                                                     (external-class-table s-equiv))
                                    (<span class="keyword">declare</span> (ignore def-found2))
                                    (<span class="keyword">let</span> ((interfaces1 (interfaces-s class-desc1))
                                          (interfaces2 (interfaces-s class-desc2)))
                                      (<span class="keyword">cond</span> ((not (equal interfaces2 interfaces1))
                                             (list p s s-equiv seen mode))
                                            (t 
                                             (load_class_x_induct interfaces1 s s-equiv 
                                                                  (cons classname seen) 0)))))))))
          ((equal mode 0)
           (<span class="keyword">cond</span> ((not (consp interfaces))
                  (list p s s-equiv seen mode))
                 ((not (no-fatal-error? s))
                  (list p s s-equiv seen mode))
                 ((not (no-fatal-error? s-equiv))
                  (list p s s-equiv seen mode))
                 (t (<span class="keyword">cond</span> ((mem (car interfaces) seen)
                           (list p s s-equiv seen mode))
                          ((and (class-loaded? (car interfaces) s)
                                (class-loaded? (car interfaces) s-equiv))
                           <span class="comment">;; I could add test of whether isInterface class-rep
</span>                           <span class="comment">;; Sun Jun 20 18:07:50 2004
</span>                           (load_class_x_induct (cdr interfaces) s s-equiv seen
                                                0))
                          ((and (not (class-loaded? (car interfaces) s))
                                (not (class-loaded? (car interfaces) s-equiv)))
                           (<span class="keyword">let</span> ((new-s (load_class_x (car interfaces) s seen 3))
                                 (new-s-equiv (load_class_x (car interfaces)
                                                            s-equiv seen 3)))
                             (<span class="keyword">cond</span> ((not (trivial-inv-env-do-not-change new-s
                                                                        s))
                                    (load_class_x_induct (car interfaces) 
                                                         s s-equiv 
                                                         seen 3))
                                   ((not (trivial-inv-env-do-not-change
                                          new-s-equiv s-equiv))
                                    (load_class_x_induct (car interfaces) 
                                                         s s-equiv 
                                                         seen 3))
                                   (t (<span class="keyword">cond</span> ((not (no-fatal-error? new-s))
                                             (load_class_x_induct (car interfaces) 
                                                                  s s-equiv 
                                                                  seen 3))
                                            ((not (no-fatal-error? new-s-equiv))
                                             (load_class_x_induct (car interfaces) 
                                                                  s s-equiv 
                                                                  seen 3))
                                            (t (list (load_class_x_induct (car
                                                                           interfaces)
                                                                          s
                                                                          s-equiv
                                                                          seen
                                                                          3)
                                                     (load_class_x_induct (cdr
                                                                           interfaces)
                                                                          new-s
                                                                          new-s-equiv 
                                                                          seen
                                                                          0))))))))))))
           (t s)))))


(defcong equiv-state-except-thread-and-trace equal (class-loaded? p s) 2
  <span class="builtin">:hints</span> ((<span class="string">"Goal"</span> <span class="builtin">:in-theory</span> (enable class-loaded?))))
  

(defcong equiv-state-except-thread-and-trace equiv-state-except-thread-and-trace
  (load_class_x p s seen mode) 2
  <span class="builtin">:hints</span> ((<span class="string">"Goal"</span> <span class="builtin">:do-not</span> '(generalize fertilize)
           <span class="builtin">:induct</span> (load_class_x_induct p s s-equiv seen mode))))

<span class="comment">; (skip-proofs 
;  (defthm error-flag-set-thread-load_class_x
;    (equal (error-flag (load_class_x p (state-set-current-thread th s) 
;                                     seen mode))
;           (error-flag (load_class_x p s seen mode)))
;    :hints (("Goal" :do-not '(generalize)
;             :in-theory (disable state-set-current-thread)))))
</span>
(defthm equiv-state-except-thread-and-trace-set-current-thread
  (equiv-state-except-thread-and-trace (state-set-current-thread th s)
                                       s)
  <span class="builtin">:hints</span> ((<span class="string">"Goal"</span> <span class="builtin">:in-theory</span> (enable equiv-state-except-thread-and-trace))))

(in-theory (disable state-set-current-thread))

(defthm no-fatal-error-set-thread-load_class_x
  (equal (no-fatal-error? (load_class_x p (state-set-current-thread th s) 
                                        seen mode))
         (no-fatal-error? (load_class_x p s seen mode))))


(defthm no-fatal-error?-after-load-implies-class-exists-externally
  (implies (and (no-fatal-error? (load_class fromClass s))
                (not (class-loaded? fromClass s)))
           (class-exists-externally? fromClass 
                                     (env-class-table (env s))))
  <span class="builtin">:hints</span> ((<span class="string">"Goal"</span>  
           <span class="builtin">:in-theory</span> (disable load_class_x state-set-current-thread
                       no-fatal-error?-after-load-class-x-implies-class-exists-externally
                       class-exists-externally?)
           <span class="builtin">:use</span> 
           ((<span class="builtin">:instance</span>
             no-fatal-error?-after-load-class-x-implies-class-exists-externally
             (mode 3) (p fromClass) (seen nil))))))
  
<span class="comment">;;; 
</span>

<span class="comment">;----------------------------------------------------------------------
;;;
;;; properties for 
;;;
</span>
(acl2::set-verify-guards-eagerness 2)

(local (in-theory (disable mv-to-slot)))

(defthm wff-state-load_class2
  (implies (wff-state s)
           (wff-state (load_class2 classname s)))
  <span class="builtin">:hints</span> ((<span class="string">"Goal"</span> <span class="builtin">:in-theory</span> (e/d (load_class2 fatalError) (load_cp_entry)))))


(defthm wff-state-load_class_x
  (implies (wff-state s)
           (wff-state (load_class_x p s seen mode)))
  <span class="builtin">:hints</span> ((<span class="string">"Goal"</span> <span class="builtin">:in-theory</span> (e/d (fatalError) ()))))


<span class="comment">;; (defthm load_class_guard-strong-l-implies-wff-statici-class-rep
;;   (implies (and (load_class2_guard-strong1 l s)
;;                 (mv-let (found class-desc)
;;                         (class-by-name-s classname l)
;;                         (declare (ignore class-desc))
;;                         found))
;;            (wff-class-rep-static class-desc))
</span>
(defthm wff-static-class-table-found-implies-wff-static-class-rep
  (mv-let (found class-desc)
          (class-by-name-s classname l)
          (implies (and (wff-static-class-table l)
                        found)
                   (wff-class-rep-static class-desc))))

(defthm wff-static-class-table-member-all-names-implies
  (mv-let (found class-desc)
          (class-by-name-s p l)
          (<span class="keyword">declare</span> (ignore found))
  (implies (and (mem p (all-class-names-s l))
                (wff-static-class-table l))
           (wff-class-rep-static class-desc))))






</pre>
  </body>
</html>
