<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01//EN">
<!-- Created by htmlize-1.16 in css mode. -->
<html>
  <head>
    <title>consistent-state.lisp</title>
    <style type="text/css">
    <!--
      body {
        color: #f5deb3;
        background-color: #000000;
      }
      .builtin {
        /* font-lock-builtin-face */
        color: #b0c4de;
      }
      .comment {
        /* font-lock-comment-face */
        color: #ff7f24;
      }
      .function-name {
        /* font-lock-function-name-face */
        color: #87cefa;
      }
      .keyword {
        /* font-lock-keyword-face */
        color: #00ffff;
      }
      .string {
        /* font-lock-string-face */
        color: #ffa07a;
      }
      a {
        color: inherit;
        background-color: inherit;
        font: inherit;
        text-decoration: inherit;
      }
      a:hover {
        text-decoration: underline;
      }
    -->
    </style>
  </head>
  <body>
    <pre>
<span class="comment">;; Mon Dec 22 21:39:11 2003. This file defines WFF predicate and
;; <a href="consistent-state.lisp.html">consistent-state</a> predicate. 
;;; Mon Dec 19 21:08:10 2005
</span>

(<span class="keyword">in-package</span> <span class="string">"DJVM"</span>)
(include-book <span class="string"><a href="djvm-state.lisp.html">"../DJVM/djvm-state"</a></span>)
(include-book <span class="string"><a href="djvm-env.lisp.html">"../DJVM/djvm-env"</a></span>)
(include-book <span class="string"><a href="djvm-class-table.lisp.html">"../DJVM/djvm-class-table"</a></span>)
(include-book <span class="string"><a href="djvm-thread.lisp.html">"../DJVM/djvm-thread"</a></span>)
(include-book <span class="string"><a href="djvm-obj.lisp.html">"../DJVM/djvm-obj"</a></span>)
(include-book <span class="string"><a href="djvm-type-value.lisp.html">"../DJVM/djvm-type-value"</a></span>)
(include-book <span class="string"><a href="djvm-linker.lisp.html">"../DJVM/djvm-linker"</a></span>)

(acl2::set-verify-guards-eagerness 2)

<span class="comment">;; WFF predicate. Used as guard for accessors 
;; tagged-value is of form (tag . value)
;
;
;  First we define wff-tagged-value
</span>
<span class="comment">; <a href="consistent-state.lisp.html">consistent-state</a> for DJVM 
</span>

<span class="comment">;; ;----------------------------------------------------------------------
;; ;
;; ;  TAG and VALUE
</span>

<span class="comment">;; (defun wff-tagged-value (tagged-value)
;;   (declare (xargs :verify-guards t))
;;   (and (consp tagged-value)
;;        (equal (len tagged-value) 1))) 
</span>

<span class="comment">;; (defun tag-of (tagged-value)
;;   (declare (xargs :guard (wff-tagged-value tagged-value)))
;;   (car tagged-value)) 
</span>
<span class="comment">;; (defun value-of (tagged-value)
;;   (declare (xargs :guard (wff-tagged-value tagged-value)))
;;   (cdr tagged-value)) value-sig
</span>

<span class="comment">;; ;----------------------------------------------------------------------
</span>
<span class="comment">;; ;; Need a reference type predicate: 
;; (defun wff-REFp (ref)
;;   (declare (xargs :verify-guards t))
;;   ;; when we assert globally syntax correct.  we need assert wff-tagged-value
;;   ;; and appropriate wff-REFp like predicate.
;;   (and (wff-tagged-value ref)
;;        (equal (tag-of ref) 'REF)
;;        (integerp (value-of ref))))
;;        ;; we probably do not to assert (integerp (value-of ref))
;;        ;; because we never only use those as key into heap. 
</span>

<span class="comment">;; (defun rREF (ref)
;;   (declare (xargs :guard (wff-REFp ref)))
;;   ;; make sure it is only called after we can establish ref is a wff-REFp
;;   (cdr ref))
</span>
<span class="comment">;; ;; only called on wff-REFp
</span>
<span class="comment">;; (defun NULLp (ref)
;;   (declare (xargs :verify-guards t))
;;   (and (wff-REFp ref)
;;        (equal (rREF ref) -1)))
</span>
<span class="comment">;; ;----------------------------------------------------------------------
</span>
<span class="comment">;; (defun wff-Heap (hp)
;;   (declare (xargs :verify-guards t))
;;   (alistp hp)) ;; minium requirement 
</span>

<span class="comment">;; (defun Valid-REFp (ref hp)
;;   ;; somethin about consistency
;;   (declare (xargs :guard (wff-Heap hp)))
;;   (and (wff-REFp ref)
;;        (bound? (rREF ref) hp)))
</span>
<span class="comment">;; ;; Note: We do not assert objected at (rREF ref) is a valid object. 
;; ;; Because that would cause mutual recurision. 
;; ;; We will be relying on the fact that every object in the heap is a
;; ;; valid-object (valid-object means its reference valued fields are REFp)
</span>
<span class="comment">;; (defun REFp (ref hp)
;;   (declare (xargs :guard (wff-Heap hp)))
;;   ;; more semantic REF bounded! 
;;   (or (NULLp ref)
;;       (Valid-REFp ref hp)))
</span>
<span class="comment">;; ;----------------------------------------------------------------------
</span>
<span class="comment">;;; moved <a href="djvm-type-value.lisp.html">djvm-type-value</a>
;;; should should
</span>
<span class="comment">;; (defun deref2 (ref hp)
;;   (declare (xargs :guard (and (wff-Heap hp)
;;                               (Valid-REFp ref hp))))
;;   ;; never deref2 a non pointer. 
;;   ;; ensure our owm implementation is right. 
</span>              
<span class="comment">;;   (binding (rREF ref) hp))
</span>
<span class="comment">;; We keep the represetation of Heap in M6 and DJVM to be the same! 
</span>
<span class="comment">;----------------------------------------------------------------------
</span>

<span class="comment">;; (defun wff-INT (tagged-value)
;;   (and (wff-tagged-value tagged-value)
;;        (equal  (tag-of tagged-value) 'INT)
;;        (integerp (value-of tagged-value)))) 
</span>

<span class="comment">;; (defun Valid-INTp (tagged-value)
;;   (and (wff-INT tagged-value)
;;        (int32p (value-of tagged-value))))
</span>
<span class="comment">;; ;;  int32p defined in primitive.lisp
</span>


<span class="comment">;----------------------------------------------------------------------
</span>
<span class="comment">;; (defun wff-class-table (cl)
;;   (declare (xargs :verify-guards t))
;;   (and (equal (len cl) 3)
;;        (true-listp cl)
;;        (consp (nth 1 cl))
;;        (consp (nth 2 cl))
;;        (equal (car (nth 1 cl)) 'instance-class-table)
;;        (equal (car (nth 2 cl)) 'array-class-table)))
</span>
<span class="comment">;; moved to jvm-class-table.lisp in M6-DJVM-shared/
;; Tue Dec 23 01:20:31 2003
</span>
<span class="comment">;;;;
;;
;; From <a href="../M6-DJVM-shared/jvm-class-table.lisp.html">jvm-class-table</a> 
;;
</span>
<span class="comment">;; does this depends on DJVM?? 
;; M6 does not check for this. 
</span>

<span class="comment">;; (defun wff-array-type (arraytype)
;;   (declare (xargs :verify-guards t))
;;   (and (consp arraytype)
;;        (equal (car arraytype) 'ARRAY)
;;        (equal (len arraytype) 2)))
</span>
<span class="comment">;; (defun array-component-type (arraytype)
;;   (declare (xargs :guard (wff-array-type arraytype)))
;;   (cadr arraytype))
</span>
<span class="comment">;; (defun primitive-type (type)
;;   (declare (xargs :verify-guards t))
;;   (or (equal type 'INT)
;;       (equal type 'ADDR) ;; different from jvm's definition.
;;       (equal type 'BYTE)
;;       (equal type 'LONG)
;;       (equal type 'SHORT)
;;       (equal type 'CHAR)));; ARRAY-type MAY NEED THIS
;;                              ;; need to deal with LONG, etc.  
</span>
<span class="comment">;; (defun primitive-opvalue-type (type) 
;;   (declare (xargs :verify-guards t))
;;    (or (equal type 'INT)
;;        (equal type 'ADDR)
;;        (equal type 'LONG)))
</span>

<span class="comment">;;
;; Notice BYTE SHORT CHAR etc will not appear on the OPSTACK
;; they could only appear in ARRAY OBJECT's SPEC.
;;
;; For example: baload, bastore will convert byte into/back from integer.
;;
</span>
<span class="comment">;; (mutual-recursion 
;;  (defun reference-type-s (type cl)
;;    ;; why reference-type-s should it just be reference-type
;;    ;; this recursive.
;;    (declare (xargs :guard (wff-instance-class-table cl)
;;                    :measure (cons (+ (acl2-count type) 1) 1)))
;;    (or (equal type 'NULL) ;; never used. ;; we represent NULL with (REF . -1)
;;        (array-type-s type cl)
;;        (class-exists? type cl)))
</span> 
<span class="comment">;;  (defun array-type-s (type cl)
;;    (declare (xargs :guard (wff-instance-class-table cl)
;;                    :measure (cons (+ (acl2-count type) 1) 0)))
;;    (and (wff-array-type type)
;;         (or (primitive-type (array-component-type type))
;;             (reference-type-s (array-component-type type) cl)))))
</span>

<span class="comment">;; How to deal with isArrayType does it recursively check for component type
;; being a either a primitive type or reference-type
</span>
<span class="comment">;; We need to able to say, all values in a <a href="consistent-state.lisp.html">consistent-state</a> have proper type.
;;
;; The difference with M3, is handling of NULL type and ARRAY 
;;
;; Can we have an array of NULL in the defensive machine? 
</span>
<span class="comment">;----------------------------------------------------------------------
;
; The question is now do we want to write a completely different set of
; class-exists? class-by-name primitives. (because the domain of their
; application will be different. Will it be different?? (Can we keep the class
; table and heap the same? (in Defensive and non defensive machine?)
; 
;  Only on OPSTACK and LOCALS, we need TAG information to distinguish INT from
;  FLOAT or RETURN ADDRESS and HEAP REFERENCE (since we only support int, so
;  only need to distinguish. Since we put a (REF . pointer) around a ref value,
;  we may as well put an (INT . value) around an int value. to make it more
;  uniform. 
;
;  We could keep heap and class table, thread table the same (even ref doesn't
;  has (REF . pointer) around a pointer. (because from the class table we know
;  the type!! SAVE some work of untagging. We need to implement getfield and
;  putfield correctly to deal with what type of object it is putting out. 
;  
;  Decision: keep the heap and class table the same. Special care about
;  consistent-heap and consistent-class-table predicate (need fix)
;  
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
</span>
<span class="comment">;;(ld "../M6/no-dup-set-facts.lisp")
</span>
<span class="comment">;;; the following is consistent-class-hierachy!! move to djvm-class-table!!
</span>

<span class="comment">;; (defun all-class-names (cl)
;;   (declare (xargs :guard (wff-instance-class-table cl)))
;;   (if (not (consp cl)) nil
;;     (cons (classname (car cl))
;;           (all-class-names (cdr cl)))))
</span>

<span class="comment">;; (defun unseen-classes (cl seen)
;;   (declare (xargs :measure (wff-instance-class-table cl)
;;                   :guard (and (wff-instance-class-table cl)
;;                               (true-listp seen))))
;;   (len (set-diff (all-class-names cl) seen)))
</span>
<span class="comment">;; (defun unseen-classes-x (ns cl seen mode)
;;   (declare (xargs :guard (and (wff-instance-class-table cl)
;;                               (true-listp seen))))
;;   (cond ((equal mode 'NODE) (cons (cons (+ 1 (unseen-classes cl seen)) 0) 0))
;;         ((equal mode 'LIST) (cons (cons (+ 1 (unseen-classes cl seen)) 0) 
;;                                   (len ns)))
;;         (t 0)))
</span>
<span class="comment">;; ;; 
;; ;;
</span>


<span class="comment">;; ;; (defun isInterfaceType (class-decl)
;; ;;   (declare (xargs :guard (wff-class-rep class-decl)))
;; ;;   (mem '*interface* (class-accessflags class-decl)))
</span>

<span class="comment">;; (defun all-interfaces-bounded? (interfaces cl)
;;   (declare (xargs :guard (wff-instance-class-table cl)))
;;   (if (not (consp interfaces)) t
;;     (and (class-exists? (car interfaces) cl)
;;          (isInterface (class-by-name (car interfaces) cl))
;;          (all-interfaces-bounded? (cdr interfaces) cl))))
</span>



<span class="comment">;; (defun class-hierachy-consistent1-class-n (n cl)
;;   ;; 
;;   ;; 1. super ends with "java.lang.Object" 
;;   ;; 2. interfaces all bounded and are in fact interfaces.
;;   ;; 3. Somewhere we need to assert no loop
;;   ;;
;;   ;;
;;   (declare (xargs :guard (wff-instance-class-table cl)))
;;   (and (class-exists? n cl)
;;        (if (equal n "java.lang.Object")
;;            (let ((class-rep (class-by-name n cl)))
;;              (and (not (class-exists? (super class-rep) cl))
;;                   (all-interfaces-bounded? (interfaces class-rep) cl)))
;;          (let ((class-rep (class-by-name n cl)))
;;            (and (class-exists? (super class-rep) cl)
;;                 (all-interfaces-bounded? (interfaces class-rep) cl))))))
</span>

<span class="comment">;; ; (defun subseqx (l1 l2)
;; ;   (declare (xargs :verify-guards t))
;; ;   (if (equal l1 l2) t
;; ;     (if (not (consp l2)) nil
;; ;         (subseqx l1 (cdr l2)))))
</span>


<span class="comment">;; ; (defthm wff-instance-class-table-hireachy-wff-class-rep
;; ;   (implies (and (class-exists? n cl)
;; ;                 (wff-instance-class-table cl))
;; ;            (wff-class-rep (class-by-name n cl))))
</span>

<span class="comment">;; (defun class-hierachy-consistent1-aux (classes cl)
;;   (declare (xargs :guard (and (wff-instance-class-table cl)
;;                               (wff-instance-class-table classes))))
;;   (if (not (consp classes)) t
;;     (and (class-hierachy-consistent1-class-n (classname (car classes)) cl)
;;          ;;; NOTE: Here using (class (car classes)) is different from testing
;;          ;;; (car classes). Current usage allows some invalid description in
;;          ;;; class-table. Otherwise we need to assert no-dups explicitly
;;          ;;; We are using the same interface to assert property then it is
;;          ;;; good. 
;;          (class-hierachy-consistent1-aux (cdr classes) cl))))
</span>

<span class="comment">;; (defun class-hierachy-consistent1 (cl)
;;   (declare (xargs :guard (wff-instance-class-table cl)))
;;   (class-hierachy-consistent1-aux cl cl)) 
;;   ;;
;;   ;; this only assert the fact that no class-rep refers an undefined 
;;   ;; entity in super field and interfaces field
;;   ;;
;;   ;; Thus self contained. 
</span>

<span class="comment">;; (defthm class-exists?-implies-mem-all-class-names 
;;   (implies (and (class-exists? n cl)
;;                 (wff-instance-class-table cl))
;;            (mem n (all-class-names cl))))
</span>

<span class="comment">;; ;;  
;; (defun superclass-chain-no-loop-class-n (n1 cl seen)
;;   (declare (xargs :guard (and (wff-instance-class-table cl)
;;                               (true-listp seen))
;;                   :measure (unseen-classes cl seen)))
;;   ;;
;;   ;; for termination, I also need cl is wff-instance-class-table we need to be
;;   ;; able to show n1 if bounded, then it is a member of all classes
;;   ;;
;;   (if (not (wff-instance-class-table cl)) nil
;;     (if (not (class-exists? n1 cl)) t
;;       (if (mem n1 seen) nil
;;         (let ((n2 (super (class-by-name n1 cl))))
;;           ;; this definition is a trickier. 
;;           ;; termination should be ok.
;;           (superclass-chain-no-loop-class-n n2 cl (cons n1 seen)))))))
</span>

<span class="comment">;; ;; I could merge this with the above one.  09/08/03 
;; (defun interfaces-chains-no-loop-class-n (n-or-ns cl seen mode)
;;   (declare (xargs :guard (and (wff-instance-class-table cl)
;;                               (true-listp seen))
;;                   ;; I could assert stronger guard such as 
;;                   ;; all n, ns are also bounded. 
;;                   :measure (unseen-classes-x n-or-ns cl seen mode)))
;;   (let ((n  n-or-ns)
;;         (ns n-or-ns)) 
;;     (if (not (wff-instance-class-table cl)) nil 
;;       ;; need for termintation!!
;;       (cond ((equal mode 'NODE)
;;              (if (not (class-exists? n cl)) t
;;                (if (mem n seen) nil
;;                    (let ((ns (interfaces (class-by-name n cl))))
;;                      (interfaces-chains-no-loop-class-n
;;                       ns cl (cons n seen) 'LIST)))))
;;             ((equal mode 'LIST)
;;              (if (not (consp ns)) t
;;                (and (interfaces-chains-no-loop-class-n (car ns) cl seen 'NODE)
;;                     (interfaces-chains-no-loop-class-n (cdr ns) cl seen 'LIST))))))))
</span>


<span class="comment">;; (defun class-hierachy-consistent2-class-n (n cl)
;;   (declare (xargs :guard (wff-instance-class-table cl)))
;;   ;; this one I want to assert no loop through superclass chain and super
;;   ;; interface chain.
;;   ;;
;;   ;; The problem is shall I mix this part with the other part?   
;;   ;; 
;;   ;; Shall I assert all interface's super must be java.lang.Object?
;;   (and (superclass-chain-no-loop-class-n n cl nil)
;;        (interfaces-chains-no-loop-class-n n cl nil 'NODE)))
</span>

<span class="comment">;; (defun class-hierachy-consistent2-aux (classes cl)
;;   (declare (xargs :guard (and (wff-instance-class-table classes)
;;                               (wff-instance-class-table cl))))
;;   (if (not (consp classes)) t
;;     (and (class-hierachy-consistent2-class-n (classname (car classes)) cl)
;;          (class-hierachy-consistent2-aux  (cdr classes) cl))))
</span>
<span class="comment">;; (defun class-hierachy-consistent2 (cl)
;;   (declare (xargs :guard (wff-instance-class-table cl)))
;;   (class-hierachy-consistent2-aux cl cl))
</span>

<span class="comment">;; ;; The third thing we need to assert about the internal class table is 
;; ;; it is in fact loaded from the external class table. 
;; ;; We only need to assert, class hierachy is not changed! tags of value in the
;; ;; consistent pool is not changed. 
;; ;; 
;; ;; We also need to assert that static field's type all right? No we don't 
;; ;; if Static field doesn't exist, we could just thrown an error in both
;; ;; machine. However a sensible JVM implementation of loader should load that
;; ;; field correctly. (part of the correctness of loader then) 
;; ;;
;; ;; WE DON'T EVEN NEED TO ASSERT FIELDS ARE ALL RIGHT. BECAUSE EVERYTHING IS
;; ;; ENCODED IN THE FIELD CP.  09/09/03 ??? REALLY???  THE ASSIGNMENT COMPATIBLE
;; ;; TEST IS DONE AFTER RESOLUTION. RESOLUTION IS GUARANTEED TO FIND THE RIGHT
;; ;; TYPE. IN BCV, NO RESOLUTION IS DONE. BCV JUST TRUST AT RUNTIME RESOLUTION
;; ;; PROCEDURE WILL FIND THE FIELD OF RIGHT TYPE.
</span>
<span class="comment">;; (defun consistent-class-hierachy (cl)
;;   (declare (xargs :verify-guards t))
;;   ;; although 
;;   (and (wff-instance-class-table cl)
;;        (class-hierachy-consistent1 cl)
;;        (class-hierachy-consistent2 cl)))
</span>

<span class="comment">;----------------------------------------------------------------------
</span>

<span class="comment">;----------------------------------------------------------------------
</span>

<span class="comment">;; (defun constantpool-loaded-from (cpentries cpentries-s)
;;   (declare (xargs :guard (and (wff-constant-pool cpentries)
;;                               (wff-constant-pool-s cpentries-s))))
;;   (cond ((not (consp cpentries)) (not (consp cpentries-s)))
;;         ((not (consp cpentries-s)) nil)
;;         (t (and (equal (cpentry-type (car cpentries))
;;                        (cpentry-type-s (car cpentries-s)))
;;                 (constantpool-loaded-from (cdr cpentries)
;;                                           (cdr cpentries-s))))))
</span>
<span class="comment">;; ;; (defun wff-class-rep-static (class-rep)
;; ;;   (declare (xargs :verify-guards t))
;; ;;   (and (true-listp class-rep)
;; ;;        (equal (len class-rep) 8)
;; ;;        (equal (car class-rep) 'class) 
;; ;;        (consp (nth 3 class-rep))
;; ;;        (consp (nth 4 class-rep))
;; ;;        (consp (nth 5 class-rep))
;; ;;        (consp (nth 6 class-rep))
;; ;;        (consp (nth 7 class-rep))
;; ;;        (true-listp (cdr (nth 3 class-rep)))
;; ;;        (true-listp (cdr (nth 4 class-rep)))
;; ;;        (true-listp (cdr (nth 5 class-rep)))
;; ;;        (true-listp (cdr (nth 6 class-rep)))
;; ;;        (true-listp (cdr (nth 7 class-rep)))))
</span>
<span class="comment">;; ;; moved to <a href="../M6-DJVM-shared/jvm-env.lisp.html">jvm-env</a>
</span>

<span class="comment">;; (defun wff-class-rep-strong (class-rep)
;;   (and (wff-class-rep class-rep)
;;        (wff-constant-pool (constantpool class-rep))))
</span>

<span class="comment">;; (defun wff-class-rep-static-strong (class-rep)
;;   (and (wff-class-rep-static class-rep)
;;        (wff-constant-pool-s (constantpool-s class-rep))))
</span>

<span class="comment">;; (defun class-is-loaded-from-helper (class-rep class-rep-static)
;;   (declare (xargs :guard (and (wff-class-rep-strong class-rep) 
;;                               (wff-class-rep-static-strong class-rep-static))))
;;   (and (equal (classname  class-rep) (classname-s  class-rep-static))
;;        (equal (super      class-rep) (super-s      class-rep-static))
;;        (equal (interfaces class-rep) (interfaces-s class-rep-static))
;;        ;; we also need the access flags are preserved 
;;        (equal (class-accessflags class-rep) (accessflags-s class-rep-static))
;;        (constantpool-loaded-from (constantpool class-rep)
;;                                  (constantpool-s class-rep-static))))
;;        ;; this also stipulated whether is it an interface type or not.
</span>

<span class="comment">;; (defun wff-static-class-table (scl)
;;   (declare (xargs :verify-guards t))
;;   (if (not (consp scl)) t
;;     (and (wff-class-rep-static (car scl))
;;          (wff-static-class-table (cdr scl)))))
</span>
<span class="comment">;; (defun wff-instance-class-table-strong (icl)
;;   (declare (xargs :verify-guards t))
;;   (if (not (consp icl)) t 
;;     (and (wff-class-rep-strong (car icl))
;;          (wff-instance-class-table-strong (cdr icl)))))
</span>


<span class="comment">;; (defun wff-static-class-table-strong (scl)
;;   (declare (xargs :verify-guards t))
;;   (if (not (consp scl)) t
;;     (and (wff-class-rep-static-strong (car scl))
;;          (wff-static-class-table-strong (cdr scl)))))
</span>

<span class="comment">;; ;; (defun class-by-name-s (name scl)
;; ;;   (declare (xargs :guard (wff-static-class-table scl)))
;; ;;   (if (not (consp scl))
;; ;;       (mv nil nil)
;; ;;     (if (equal (classname-s (car scl))
;; ;;                name)
;; ;;         (mv t (car scl))
;; ;;       (class-by-name-s name (cdr scl)))))
</span>

<span class="comment">;; (defun class-exists-s? (n scl)
;;   (declare (xargs :guard (wff-static-class-table scl)))
;;   (mv-let (found rep)
;;           (class-by-name-s n scl)
;;           (declare (ignore rep))
;;           found))
</span>
<span class="comment">;; (defthm class-exists-s-implies-wff-static-rep
;;    (implies (and (class-exists-s? n scl)
;;                  (wff-static-class-table-strong scl))
;;             (wff-class-rep-static-strong (mv-let (found rep)
;;                                                  (class-by-name-s n scl)
;;                                                  (declare (ignore found))
;;                                                  rep))))
</span>

<span class="comment">;; (defthm class-exists-implies-wff-rep-strong
;;    (implies (and (class-exists? n cl)
;;                  (wff-instance-class-table-strong cl))
;;             (wff-class-rep-strong (class-by-name n cl))))
</span>

<span class="comment">;; (defthm wff-class-rep-strong-is-strong
;;   (implies (wff-class-rep-strong rep)
;;            (wff-class-rep rep))
;;   :rule-classes :forward-chaining)
</span>
<span class="comment">;; (defthm wff-instance-class-table-strong-is-strong
;;   (implies (wff-instance-class-table-strong cl)
;;            (wff-instance-class-table cl))
;;   :rule-classes :forward-chaining)
</span>

<span class="comment">;; (defthm wff-static-class-table-strong-is-strong
;;   (implies (wff-static-class-table-strong scl)
;;            (wff-static-class-table scl))
;;   :rule-classes :forward-chaining)
</span>

<span class="comment">;; ;; (defthm wff-static-class-table-strong-is-strong-tmp
;; ;;   (implies (wff-static-class-table-strong scl)
;; ;;            (jvm::wff-static-class-table scl))
;; ;;   :rule-classes :forward-chaining)
</span>

<span class="comment">;; (defthm wff-class-static-rep-strong-is-strong
;;   (implies (wff-class-rep-static-strong rep)
;;            (wff-class-rep-static rep))
;;   :rule-classes :forward-chaining)
</span>


<span class="comment">;; ;(in-theory (disable wff-class-rep-static-strong wff-class-rep-strong
;; ;                    wff-class-rep
;; ;                    class-exists? class-by-name class-by-name-s class-exists-s?))
</span>
<span class="comment">;; ;; These are too general!!
</span>
<span class="comment">;; (defthm wff-class-rep-if-exists-in-wff-instance-table
;;   (implies (and (class-exists? n cl)
;;                 (wff-instance-class-table cl))
;;            (wff-class-rep (class-by-name n cl))))
</span>


<span class="comment">;; (defun class-table-is-loaded-from (cl scl)
;;   (declare (xargs :guard (and (wff-instance-class-table-strong cl)
;;                               (wff-static-class-table-strong scl))))
;;   (if (not (consp cl)) t
;;     (and (class-exists? (classname (car cl)) cl)
;;          (class-exists-s? (classname (car cl)) scl)
;;          (mv-let (def-found rep)
;;                  (class-by-name-s (classname (car cl)) scl)
;;                  (declare (ignore def-found))
;;                  (class-is-loaded-from-helper (class-by-name (classname (car cl)) cl)
;;                                               rep))
;;          (class-table-is-loaded-from (cdr cl) scl))))
</span>
<span class="comment">;; ;; we chose not to disable those functions. ACL2 will get it anyway!
</span>
<span class="comment">;;;; moved to <a href="djvm-class-table.lisp.html">djvm-class-table</a>
</span>

<span class="comment">;;
;; If we know class-hierachy-consistent 
;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
</span>
<span class="comment">;; We need to move this to 
</span>
<span class="comment">;; (defun isJavaSubclassOf-guard (c1 c2 cl)
;;   (declare (xargs :verify-guards t))
;;   (and (consistent-class-hierachy cl)
;;        (isClassTerm (class-by-name c1 cl))
;;        (isClassTerm (class-by-name c2 cl))))
</span>       

<span class="comment">;; ;; I would add isJavaSuclassOf with an extra seen parameter.  We need to prove
;; ;; that under no loop hypothesis, with seen and without seen it is the
;; ;; same. Basically, we proved it for bytecode verifier's isAssignable check.
</span>
<span class="comment">;; (defun isJavaSubClassOf-measure (cl seen)
;;   (declare (xargs :guard (and (wff-instance-class-table cl)
;;                               (true-listp seen))))
;;   (unseen-classes cl seen))
</span>

<span class="comment">;; (defun isJavaSubclassof1 (c1 c2 cl seen)
;;   (declare (xargs :guard (and (consistent-class-hierachy cl)
;;                               (true-listp seen))
;;                   :measure (isJavasubclassOf-measure cl seen)))
;;   ;; I need to wff-instance-class-table assert this class-rep
</span>
<span class="comment">;;   ;; I think for Defensive Machine I have the liberty to define
;;   ;; isJavaSubclassof with an extra parameter of seen
</span>
<span class="comment">;;   ;;
;;   ;; 09/08/03 This is the test of the defensive machine's Class Hierachy!!
;;   ;; need special handling of termination ... 
;;   ;;
;;   ;; isJavaSubclassOf should be different from BCV's isJavaSubclassOf 
;;   ;; because class table are different (can we reuse it??)
;;   ;; We can define as long as two class table are equivalent in some
;;   ;; sense. isJavaSubclassOf will return the same value.
;;   ;; 
;;   ;; What do I want? 
;;   ;;
;;   ;; Decision reuses BCV's definition. We will need to the use static
;;   ;; class-table? 
;;   ;;
;;   ;;
;;   ;; redefining it is painful. 
;;   ;;
;;   ;; We need to prove current CL has some relation with BCV's SCL --- The
;;   ;; portion of class hierachy cl describes matches what is in scl which relies
;;   ;; on the correctness of class loader (relies on something we have proved)
;;   ;; 
;;   ;; The issue is whether I need to write a second class loader? should
;;   ;; defensive machine's loader check for more things? Can I reuse? Class
;;   ;; loader does not change opstack and locals, only change class table and
;;   ;; heap. and we decided to keep the heap and class table the same with
;;   ;; non-defensive version. So Good. we could reuse class-loader. (However, we
;;   ;; do we need to extend the current class loader to check class implement
;;   ;; what it declare to implement? NO. We don't. Runtime resolution will catch
;;   ;; that!!! So far so good. 
;;   ;; 
;;   ;; 
;;   ;; All superclass of c1 appears in cl 
;;   ;; 
;;   ;; Reuse BCV's version (however we need to make sure BCV's class table is in
;;   ;; some sense matches with non-defensive machine's class table (which add a
;;   ;; few extra fields.) 
;;   ;;
;;   (if (not (consistent-class-hierachy cl)) nil
;;     (and (class-exists? c1 cl)
;;          (class-exists? c2 cl)
;;          (not (mem c1 seen))
;;          (or (equal c1 c2)
;;              (let* ((SubClass (class-by-name c1 cl))
;;                     (c3 (super SubClass)))
;;                (isJavaSubclassOf1 c3 c2 cl (cons c1 seen)))))))
</span>
<span class="comment">;; ;; how guard works?? 
</span>
<span class="comment">;; ;; this function is easy to admit. 
;; ;; Shall I use this definition? 
;; ;; I could prove under the consistent-class-hierachy hyp. 
;; ;; without test on seen it is admissible 
;; ;; 
;; ;; This proof is done for "typechecker.lisp"
;; ;; SKIP.
;; ;;
;; ;; 
;; ;; basically a collect-super cons subclass to seen does not matter. 
;; ;;
;; ;; What's the point of defining consistent-class-hierachy if it is not used to
;; ;; justify the termination? It is used elsewhere...
</span>
<span class="comment">;; (defun isJavaSubclassOf (c1 c2 cl)
;;   (declare (xargs :guard (and (consistent-class-hierachy cl)
;;                               (wff-class-rep c1) 
;;                               (wff-class-rep c2))))  ;;  10/28/03 
;;   ;; The parameter is class-rep instead of class name. 
;;   (isJavaSubclassOf1 (classname c1) (classname c2) cl nil))
</span>

<span class="comment">;; (defun isJavaClassAssignmentCompatible (rtype type cl)
;;   (declare (xargs :guard (and (consistent-class-hierachy cl)
;;                               (class-exists? rtype cl)
;;                               (class-exists? type cl))))
;;   ;; make sure this function is only called when we know class-exists.
;;   ;;  09/09/03 
</span>  
<span class="comment">;;   ;; Assuming that rtype and type are both class names 
;;   ;; the most straightforward and precise result.
;;   ;; should I return a pair as a result? (complicated), return nil if not
;;   ;; valid.
;;   ;; 
;;   ;; invariant that rtype and type are bounded types. 
;;   ;;
;;   ;; here rtype and type are expect to be classnames.
;;   ;;
;;   ;; This function is only used in <a href="consistent-state.lisp.html">consistent-state</a> predicate. We don't check
;;   ;; whether interface slots have correctly labeled value. (We can't guarantee
;;   ;; that in CLDC. In J2SE, maybe we could.
;;   ;;
;;   ;; Checking implementation relation in CLDC BCV and Defensive JVM is
;;   ;; weak. and delayed to runtime. 
;;   ;;
;;   (let ((SlotType  (class-by-name type cl))
;;         (ValueType (class-by-name rtype cl))) ;; BUG  10/28/03 
;;     (cond  ; ((or (class-exists? rtype cl)
;;            ;     (class-exists? type  cl)) nil)
;;            ;; make it explicit that above cause is nil
;;            ;;
;;            ;; Moved it to Guard. We are sure that this method is not even
;;            ;; called.        
;;            ;;
</span>
<span class="comment">;;            ((isInterface SlotType)  t)
;;             ;; check for a marker in class description
;;             ;; if yes. Return t
;;             ;;
;;            (t (isJavaSubclassOf ValueType SlotType cl)))))
</span>
<span class="comment">;;             ;;This needs an invariant that ValueType's supers all exists in cl
;;             ;; Because this is used in consistent-state. This should be
;;             ;; guaranteed. 
;;             ;;
;;             ;; Otherwise, the isSubclassOf's return value will not be accurate.
</span>
<span class="comment">;; ;; In consistent-state, it does not matter that we have an interface variable
;; ;; that hold an value does not implement that interface. Check is done at the
;; ;; runtime. BCV does not guarantee anything in that case. 
</span>
<span class="comment">;; ;; 
</span>
<span class="comment">;; Tue Jan 13 01:17:04 2004 moved to djvm-class-hierachy-aux.lisp
</span>
<span class="comment">;; (defun isClassType (t1)
;;   (stringp t1)) 
;; ;; FIXED  10/28/03 for the wrong assumption in isJavaAssignmentCompatible
;; ;; originally t1 was expected to be (class &lt;something&gt;)
;; ;; 
</span>
<span class="comment">;; (defun isArrayType (t1)
;;   (and (consp t1)
;;        (equal (len t1) 2)
;;        (equal (car t1) 'array)))
</span>

<span class="comment">;; (defun wff-type-desc (type-desc)
;;   (or (primitive-type type-desc)
;;       (isClassType type-desc)
;;       (isArrayType type-desc)))
;; ;;
</span>
<span class="comment">;; (defun classname-classtype (ctype)
;;   (declare (xargs :guard (isClassType ctype)))
;;   ctype) ;; FIXED  10/28/03. see above fix for isClassType
</span>
<span class="comment">;; (defun compound (x)
;;   (consp x))
</span>
<span class="comment">;; (defun isJavaLangObject (type)
;;   (equal type '(class  "java.lang.Object")))
</span>
<span class="comment">;; ; -- used only on arrayType
;; (defun component-type (aArrayType)
;;   (declare (xargs :guard (isArrayType aArrayType)))
;;   (cadr aArrayType))
</span>
<span class="comment">;; Need to decide whether to write use the same set of functions and (prove
;; class tables are in some sense equivalent in BCV and 
;;
;;; DJVM's test!!
</span>
<span class="comment">;; (defun isJavaAssignmentCompatible (rtype type cl)
;;   (declare (xargs :guard (consistent-class-hierachy cl)))
;;   ;; in this, we won't expect to see Oneword, or Twoword, or top
;;   ;; We don't even see rtype being byte, short, boolean
;;   ;; Because there are operations that implicit convert values.
;;   ;; Do we allow to assign an int to a long? no.
;;   ;; we have explicit instructions that does the convertion. (i2l, i2d)
;;   ;; however i2b, b2i doesn't change the type of value on the OPSTACK
</span>
<span class="comment">;;   ;; FIX. rtype and type could be just a string. not always (class &lt;something&gt;)
;;   ;;  10/28/03.  
</span>
<span class="comment">;;   (cond ((primitive-type rtype)
;;            (and (primitive-opvalue-type rtype)
;;                 (equal rtype type)))
;;           ((equal rtype 'NULL)
;;            ;; Do I want to write the most specific rule possible?
;;            ;; which means if type is not valid, I return nil
;;            ;; Decision, relaxing a bit. 
;;            ;; We can expect that type are valid type 
;;            ;;
;;            ;; reference-type-s ??
;;            ;;
;;            ;; let me check it at level of isAssignable level.
;;            ;;
;;            (or (isClassType type)
;;                (isArrayType type)))
;;           ;; this only assert that the synatx is
;;           ;; correct. To check whether something is really a class type, we may
;;           ;; need to check reference-type-s and array-type-s.
</span>        
<span class="comment">;;           ;; if I see NULL is type, still return nil
;;           ;; SlotType must be a valid type. 
;;           ((isClassType rtype)
;;            (and (isClassType type)
;;                 (class-exists? (classname-classtype rtype) cl) 
;;                 (class-exists? (classname-classtype type) cl)
;;                 ;; added to make sure the guard of isJavaAssignmentCompatible is satisfied. 
;;                 (isJavaClassAssignmentCompatible (classname-classtype rtype)
;;                                                  (classname-classtype type)
;;                                                  cl)))
;;           ((isArrayType rtype)
;;            (cond ((isClassType type)
;;                   (or (and 
;;                        (class-exists?  (classname-classtype type) cl)
;;                        (isInterface (class-by-name
;;                                          (classname-classtype type) cl)))
;;                       ;; treat differently as long as type is an interface, it
;;                       ;; will be assignable.
;;                       ;;
;;                       ;; IN BCV this is tested as whether rtype implement Array
;;                       ;; interface. 
;;                       ;;
;;                       (isJavaLangObject type)))
;;                  (t (and (isArrayType type)
;;                          (let ((x (component-type rtype))
;;                                (y (component-type type)))
;;                            (or (and (primitive-type x)
;;                                     (primitive-type y)
;;                                     (equal x y))
;;                                (and (compound x)
;;                                     (compound y)
;;                                     (isJavaAssignmentCompatible x y cl))))))))))
</span>               

<span class="comment">;; (defun assignmentCompatible (rtype type cl)
;;   (declare (xargs :guard (consistent-class-hierachy cl)))
</span>
<span class="comment">;;   ;; this assignmentCompable has to deal with interface proported to be
;;   ;; implemented actually get implemented?  No. We only use the information
;;   ;; from the class hierachy's tree.
;;   ;;
;;   ;; 
;;   ;; Maybe I should skip proof something to avoid the problem while still stick
;;   ;; with the dynamic loading in both defensive and non-defensive JVM?
;;   ;; 
;;   ;; THIS VERSION WILL WORK LIKE ISASSIGNABLE in BCV. 
;;   ;; WE NEED TO WRITE/REUSE THE VERSION IN THE NON-DEFENSIVE MACHINE
;;   ;; 
;;   ;; WE WILL MAKE SURE THIS VERSION DOES NOT CAUSE CLASS LOADING.
;;   ;; BECAUSE WE USE THIS TO EXPRESS THE CONSISTENT STATE concept.
;;   ;;
;;   ;; WE still need another version for test InstanceOf, <a href="INST/AASTORE.lisp.html">AASTORE</a> etc
;;   ;; (reuse non-defensive version)
;;   ;; 
;;   ;;
;;   ;; There are several ways to write AssignmentCompatible.  
</span>
<span class="comment">;;   ;; One is copy BCV's
;;   ;; check (which is efficient, but it is not straight forward.
;;   (and (or (primitive-type rtype)
;;            (reference-type-s rtype cl))
;;        (or (primitive-type type)
;;            (reference-type-s type cl))
;;        (isJavaAssignmentCompatible rtype type cl)))
</span>

<span class="comment">;; ;  The obligation of assignmentCompatible is 
;; ; 
;; ;  value of rtype is assignable to of "type" type
;; ;
;; ;  A PROOF needs to be ESTABLISHED 
;; ;  
;; ;  isAssignable? in the BCV is equal to assignmentCompatible
;; ;  when type are well formed and  satisfy reference-type-s or primitive-type
;; ;
;; ; We need to prove assignmentCompatible is BCV's isAssignable 
;; ; When class table is correctly loaded from env's class table and type refered
;; ; is in side the system.
;; ;
;; ; However isAssignable uses the full spec of type (class "java.lang.Object")
;; ; etc. assignmentCompatible in M3 use abbreviated "java.lang.Object" instead of
;; ; (class "java.lang.Object")
;; ;
;; ;
;; ; need to get the package name right!! 
;; ;
</span>

<span class="comment">; (defun correctly-loaded? (classname class-table env-class-table)
;   (mv-let (found class-rep-static)
;           (class-by-name-s classname env-class-table)
;           (declare (ignore found))
;           (and (class-is-loaded? classname class-table)
;                (class-is-loaded-from 
;                                  (class-by-name classname class-table) 
;                                  class-rep-static))))
;
; (defun all-correctly-loaded? (supers class-table env-class-table)
;   (if (endp supers)
;       t
;     (and (correctly-loaded? (car supers) class-table env-class-table)
;          (all-correctly-loaded? (cdr supers) class-table env-class-table))))
;
; (defun loader-inv-helper1 (class-rep class-table env-class-table)
;   (let* ((classname (classname class-rep))
;          (supers    (collect-assignableToName classname env-class-table)))
;     (all-correctly-loaded? supers class-table env-class-table))) 
;
;
; (defun loader-inv-helper (classes class-table env-class-table)
;   (if (endp classes)
;       t
;     (and (loader-inv-helper1 (car classes) class-table env-class-table)
;          (loader-inv-helper (cdr classes) class-table env-class-table))))
</span>

<span class="comment">; (defun class-is-loaded-from (cl scl)
;   (m6::loader-inv-helper cl cl scl))
</span>

<span class="comment">; (defun class-is-loaded-from (cl scl)
</span>
<span class="comment">;   (m6::loader-inv-helper cl cl scl))
</span>

<span class="comment">;; SKIP-PROOFS
</span>
<span class="comment">; (skip-proofs 
;  (defthm isAssignable-and-valid-class-table-implies-assignmentCompatible
;    (implies (and (bcv::isAssignable from to env)
;                  (equal (bcv::classtableEnvironment env) scl)
;                  (class-table-loaded-from cl scl)
;                  (class-exists? from cl)
;                  (class-exists? to cl))
;             ;; however from, to must be the full type spec.
;             ;; need to tweak assignmentCompatible.
;             ;; however concept class-is-defined has not been defined.
;             ;; nor class-table-loaded-from is defined so far. August 12, 2003
;             (assignmentCompatible from to cl))))
</span>
<span class="comment">;;; 
;;; WE PROBABLY WANT TO DEFINE THIS ASSIGNMENT COMPATIBLE with respect to SCL
;;; instead of the RUNTIME cl.  08/27/03 
;;; 
;;; HOWEVER MY CURRENT IMPLEMENTATION USE RUNTIME CLASS TABLE SO ABOVE THEOREM
;;; ARE USEFULL.
;;;
;;; Runtime checking really talks about the cl instead of the static cl
;;;
;;; cl here could be an array-class need to deal with array types. 
;;; 
</span>
<span class="comment">;;
;; THIS IS NOT TRUE because of handling of INTERFACE CLASS SHOULD
;; <a href="consistent-state.lisp.html">consistent-state</a> also ignore interface issue as BCV does?  for example, an
;; array of type certain interfaces, contains some aribtary object, should it
;; be considered to be consistent? 
;;
;; BECAUSE INVOKEINTERFACE etc will be checked at RUNTIME anyway. 
;;
;; THIS MAY BE TRUE, if we copy from BCV's isAssignableTo
;; 
;; So the conclusion is AssignmentCompatible copy from BCV, 
;; isAssignableTo copy from Non-defensive machine. 
;;
;; WE FOLLOWED A DIFFERENT PATH.  09/09/03 
;;
;; HOWEVER, our <a href="consistent-state.lisp.html">consistent-state</a> is becoming weaker!! NOT SO GOOD.
;;
</span>
<span class="comment">;;(in-theory (disable assignmentCompatible))
</span>
<span class="comment">;;         
;; consistency is not the only requirement 
;; 
</span>

<span class="comment">; (defun make-common-info (hashcode monitor class-ptr) 
;   (list 'common-info hashcode monitor class-ptr)) 
</span>
<span class="comment">; (defun hashcode  (cminfo)   (nth 1 cminfo)) ;; a number 
; (defun monitor   (cminfo)   (nth 2 cminfo))
; (defun class-ptr (cminfo)   (nth 3 cminfo))
</span>
<span class="comment">; (defun obj-hashcode  (object)   (hashcode  (common-info object))) ;; a number 
; (defun obj-monitor   (object)   (monitor   (common-info object))) ;; a composite structure
; (defun obj-class-ptr (object)   (class-ptr (common-info object))) ;; a number 
</span>
<span class="comment">; (defun obj-type (obj)  ;; object's runtime type.
;   (obj-class-ptr obj))  
</span>

<span class="comment">;; (defun wff-internal-heap-obj (obj)
;;   (and (true-listp obj)
;;        (equal (len obj) 4)
;;        (equal (car obj) 'object)))
</span>
<span class="comment">;; ; (defun wff-internal-array (array-obj)
;; ;    (and (wff-internal-heap-obj array-obj)
;; ;         (wff-ARRAY-specific-info (specific-info array-obj))))
</span>

<span class="comment">;; (defun wff-class-ptr (class-ptr)
;;   (or ;; (isClassType class-ptr)
;;       ;; (stringp class-ptr) ;;  FIX: 10/27/03 to comply with M6's
;;       ;;  usage. cf. consistent-test.lisp  
;;       (isClassType class-ptr) ;;  10/28/03 FIX. changed the definition of
;;                            ;;  isClassType
;;       (isArrayType class-ptr)))
</span>

<span class="comment">;; (defun wff-common-info-strong (common-info)
;;   (and (true-listp common-info)
;;        (equal (len common-info) 4)
;;        (wff-class-ptr (nth 3 common-info))))
</span>

<span class="comment">;; (defun wff-jvp (jvp)
;;    (alistp jvp))
</span>
<span class="comment">;; (defun wff-specific-info (specific-info)
;;   (and (true-listp specific-info)
;;        (consp specific-info)
;;        (equal (car specific-info) 'specific-info)
;;        (cond ((equal (nth 1 specific-info) 'ARRAY) 
;;               (and (equal (len specific-info) 4)
;;                    (integerp (nth 3 specific-info))
;;                    (equal (len (nth 2 specific-info)) (nth 3 specific-info))))
;;              (t t))))
</span>

<span class="comment">;; ; (defun make-object (commoninfo specific-info java-visible-part)
;; ;   (list 'object commoninfo specific-info java-visible-part))
</span>
<span class="comment">;; ; (defun common-info   (object)     (nth 1 object))
;; ; (defun specific-info (object)     (nth 2 object))    ;; the format depends on types
;; ; (defun java-visible-portion (object) (nth 3 object))
</span>

<span class="comment">;; ;; (defun common-info (obj)
;; ;;   (declare (xargs :guard (wff-internal-heap-obj obj)))
;; ;;   (nth 1 obj))
</span>
<span class="comment">;; ;; (defun specific-info (obj)
;; ;;   (declare (xargs :guard (wff-internal-heap-obj obj)))
;; ;;   (nth 2 obj))
</span>
<span class="comment">;; ;; (defun java-visible-portion (obj)
;; ;;   (declare (xargs :guard (wff-internal-heap-obj obj)))
;; ;;   (nth 3 obj))
</span>

<span class="comment">;; (defun wff-obj-strong (obj)
;;   (and (wff-internal-heap-obj obj)
;;        (wff-common-info-strong (common-info obj))
;;        (wff-specific-info (specific-info obj))
;;        (wff-jvp (java-visible-portion obj))))
</span>
<span class="comment">;;;
;;; Tue Jan 13 01:20:29 2004: moved to <a href="djvm-obj.lisp.html">djvm-obj</a>
;;;
</span>


<span class="comment">;; (defun class-ptr (common-info)
;;   (declare (xargs :guard (wff-common-info-strong common-info)))
;;   (nth 3 common-info))
</span>
<span class="comment">;; (defun obj-class-ptr (object)   
;;   (declare (xargs :guard (wff-obj-strong object)))
;;   (class-ptr (common-info object))) ;; a number 
</span>


<span class="comment">;; (defun obj-type (obj)  ;; object's runtime type.
;;   (declare (xargs :guard (wff-obj-strong obj)))
;;   (obj-class-ptr obj))
</span>

<span class="comment">;; (defun wff-heap-strong (hp)
;;   (and (wff-heap hp)
;;        (if (not (consp hp)) t  
;;          (and (wff-obj-strong (cdar hp))
;;               (wff-heap-strong (cdr hp))))))
</span>

<span class="comment">;; (in-theory (disable wff-obj-strong))
;; ;; I could disable more functions to really restrict how ACL2 will prove it.
;; ;; for now. just disable wff-obj,
</span>
<span class="comment">;;; moved to djvm-heap.lisp
</span>

<span class="comment">;; (defun ADDRp (v) 
;;   (integerp v))
</span>
<span class="comment">;; (defun CHARp (v)
;;   ;; temp implementation
;;   ;; should be 16 bit unsigned integer.
;;   ;;
;;   (integerp v))
</span>
<span class="comment">;;
;; moved to djvm-type-value.lisp
;; Tue Jan 13 01:30:41 2004
;;
</span>

<span class="comment">;; (defthm wff-obj-strong-implies-wff-obj
;;   (implies (wff-obj-strong obj)
;;            (wff-obj obj))
;;   :hints (("Goal" :in-theory (enable wff-obj-strong))))
</span>
<span class="comment">;; (defthm wff-obj-strong-implies-wff-common-info
;;   (implies (wff-obj-strong obj)
;;            (wff-common-info (common-info obj)))
;;   :hints (("Goal" :in-theory (enable wff-obj-strong))))
</span>

<span class="comment">;; (in-theory (disable wff-obj wff-common-info common-info))
</span>
<span class="comment">;;;; moved to <a href="djvm-obj.lisp.html">djvm-obj</a>
</span>
<span class="comment">;;;; consistent value!!
</span>

(<span class="keyword">defun</span> <span class="function-name">consistent-value</span> (tagged-value type cl hp)
  <span class="comment">;; consistent-value with respect to the interal class table it will be
</span>  (<span class="keyword">declare</span> (xargs <span class="builtin">:guard</span> (and (consistent-class-hierachy cl)
                              (wff-heap-strong hp))))
  <span class="comment">;; the guard here is not very perfect.
</span>  (<span class="keyword">if</span> (not (wff-tagged-value tagged-value)) nil
    (<span class="keyword">let</span> ((vtype (tag-of  tagged-value))
          (value (value-of tagged-value)))
      (<span class="keyword">cond</span> ((primitive-type? type)
             (and (equal vtype type)
                  (<span class="keyword">cond</span> ((equal type 'INT)  (INT32p value))
                        ((equal type 'ADDR) (ADDRp value))
                        ((equal type 'CHAR) (CHARp value)) <span class="comment">;; caught by
</span>                                                           <span class="comment">;; <a href="consistent-state.lisp.html">consistent-state</a>
</span>                        <span class="comment">;; Mon May 30 14:29:42 2005
</span>                        ((equal type 'BOOLEAN) (jvmBOOLEANp value))
                        ((equal type 'SHORT)   (SHORTp value))
                        ((equal type 'BYTE)    (BYTEp value))
                        ((equal type 'FLOAT)   (jvmFLOATp value))
                        ((equal type 'DOUBLE)  (DOUBLEp value))

                        <span class="comment">;; 10/27/03 
</span>                        ((equal type 'LONG) (INT64p value))
                        <span class="comment">;; not adequate to handle it.
</span>                        (t nil))))
            ((NULLp tagged-value) t)
            ((REFp tagged-value hp)
             (<span class="keyword">let*</span> ((ref tagged-value)
                    (obj (deref2 ref hp)) 
                    (rtype (obj-type obj)))
               (assignmentCompatible rtype type cl)))
            (t nil)))))

<span class="comment">;----------------------------------------------------------------------
;
; Mon May 30 14:41:42 2005
</span>
(defthm default-value-is-consistent-value
  (implies (or (primitive-type? type)
               (reference-type type)
               (Array-type? type))
           (consistent-value (tag (default-value type) type) type cl hp)))

<span class="comment">;----------------------------------------------------------------------
</span>

<span class="comment">;; assignmentCompatible is used in consistent-state.  We need have an invariant
;; that if in the system there is a value appear to have a certain type, then
;; all type that it is assignableTo is also loaded. Thus assignmentCompatible
;; does not change state!! in a consistent state. IsAssignableTo in fact does
;; not change state!! (NO. it changes) Because class loading has a certain
;; invariant .. (unless in the case of testing of instanceOf (and assign object
;; to array!!)
;; 
;; However all testing that appears in the <a href="consistent-state.lisp.html">consistent-state</a> testing won't
;; change state!!
;;
;; Sun Oct 24 19:44:22 2004
;;
;; REFER to CLDC BCV SPEC' class hierachy graph Remember to get the assignment
;; relation to be transitive.
;;
;;; 
;;; Deviation from BCV's SPEC!!
;;;
</span> 
<span class="comment">;; If type is an interface type, every reference type can assign to it
;;
</span>
<span class="comment">;;
;; Do we want a straightforward assignmentCompatible definition or a definition
;; looks exactly like isAssignableTo in the JVM (and the bytecode verifier
;; (NOTE: BCV's isAssignableTo is different from the one in JVM)
;; 
;; We can have a straightforward definition of assignmentCompatible, to prove
;; it is in some sense the same with isAssignableTo is hard. 
;; 
;;
;; Basically, we would prove that invariant in other part of the bcv
;; implementation + bcv implementation for isAssignable ensures the
;; straightforward assignableTo succeed. 
;;
;; Is this comment really true? we need some invariant about class table is
;; correctly loaded. It is true, because, the isAssignable in <a href="../BCV/typechecker.lisp.html">typechecker</a>
;; assume the types are well formed. (because (isAssignable X X env), however,
;; a straightforward assignmentCompatible would first assert the type are valid
;; type and use the transitivity relation...
;; 
;; Thus proving isAssignable equal to assignmentCompatible (if defined
;; straightforwardly), we need to prove the invariant that all types are
;; consistent types. 
;;
;; In essense, we are proving two descriptions of tree are really describing
;; the same tree, when the type involves are from a certain domain.
;; 
;; Basically, BCV's isAssignable is more ready to return true. for cases
;; outside the domain of assignmentCompatible. 
;; 
;; As theorem would SKIP-PROOFs
;; 
;;   If both types are valid types in the system, isAssignableTo returns the
;;   same value as assignmentCompatible.  
;;
</span>

<span class="comment">;; One problem is this consistency check does not match well with 
;; jvp-set-field , jvp-getfield. Need to prove theorems about setfield valid
;; data does not change consistency, get existing field returns valid data.
;; 
;;
;; Not a big problem. But we could define a consistency check that uses only
;; set-get interface?? maybe possible. That may make proof of maintaining
;; consistency being simpler. Instead of treating object as a list of alist, we
;; first defines an iterator or collector that collect the fields from class
;; defintion, we should using set-get with valid value, we get valid value
;; back. 
;; 
</span>
<span class="comment">;; (defun wff-field (field)
;;   (and (consp field)
;;        (equal (len field) 1)))
</span>

<span class="comment">;; (defun fieldname (field) 
;;   (declare (xargs :guard (wff-field field)))
;;   ;; as in a object rep
;;   (car field))
</span>
<span class="comment">;; (defun fieldvalue (field)
;;   (declare (xargs :guard (wff-field field)))
;;   (cdr field))
</span>
<span class="comment">;;;;; moved to djvm-obj.lisp. maybe we should move it to jvm-obj!!
</span> 

<span class="comment">;; 09/09/03 we DECIDED THAT WE SHOULD KEEP HEAP AND CLASS TABLE THE SAME FOR M6
;; and Defensive M6.
</span>

<span class="comment">;; (defun tag (untagged-value field-type)
;;   (if (primitive-type? field-type)
;;       (cons field-type untagged-value)
;;     (cons 'REF untagged-value)))
</span>

<span class="comment">;; 09/09/03 we DECIDED THAT WE SHOULD KEEP HEAP AND CLASS TABLE THE SAME FOR M6
;; and Defensive M6.
</span>
<span class="comment">; (defun make-field (classname fieldname fieldtype accessflags)
;   (list 'field classname fieldname fieldtype 
;         (cons 'accessflags accessflags)))
</span>
<span class="comment">; (defun field-classname (field)  (nth 1 field))
; (defun field-fieldname (field)  (nth 2 field))
; (defun field-fieldtype (field)  (nth 3 field))
; (defun field-fieldaccessflags (field)  (cdr (nth 4 field)))
</span>

(<span class="keyword">defun</span> <span class="function-name">wff-field-decl</span> (field-decl)
  (and (true-listp field-decl)
       (equal (len field-decl) 5)
       (consp (nth 4 field-decl))
       (true-listp (cdr (nth 4 field-decl)))))


<span class="comment">;; (defun field-classname (field-decl)  
;;   (declare (xargs :guard (wff-field-decl field-decl)))
;;   (nth 1 field-decl))
</span>

<span class="comment">;; (defun field-fieldname (field-decl)  
;;   (declare (xargs :guard (wff-field-decl field-decl)))
;;   (nth 2 field-decl))
</span>

<span class="comment">;; (defun field-fieldtype (field-decl) 
;;   (declare (xargs :guard (wff-field-decl field-decl)))
;;   (nth 3 field-decl))
</span>
<span class="comment">;; (defun field-fieldaccessflags (field-decl)  
;;   (declare (xargs :guard (wff-field-decl field-decl)))
;;   (cdr (nth 4 field-decl)))
</span>
<span class="comment">;;; Mon Jul 18 17:40:15 2005
;;; Now we need to assert that 
;;; field is properly initialized! 
;;;
</span>
<span class="comment">;;;
;;; However the current definition of consistent-field could not 
;;; easily incorporate this extra assertion!!! 
;;; We need a new set of consistent-field-init
;;;
</span>
(<span class="keyword">defun</span> <span class="function-name">wff-immediate-instance</span> (immediate-instance)
  (consp immediate-instance))


(<span class="keyword">defun</span> <span class="function-name">consistent-field</span> (field field-decl cl hp)
  (<span class="keyword">declare</span> (xargs <span class="builtin">:guard</span> (and (consistent-class-hierachy cl)
                              (wff-heap-strong hp))))
  (and (wff-data-field field)
       (wff-field-decl field-decl)
       (equal (fieldname field) (field-fieldname field-decl))
       (consistent-value (tag (fieldvalue field) (field-fieldtype field-decl)) 
                         (field-fieldtype field-decl) cl hp)))


<span class="comment">;; (defun consistent-field (field field-decl cl hp)
;;   (declare (xargs :guard (and (consistent-class-hierachy cl)
;;                               (wff-heap-strong hp))))
;;   (and (wff-data-field field)
;;        (wff-field-decl field-decl)
;;        (equal (fieldname field) (field-fieldname field-decl))
;;        (consistent-value (tag (fieldvalue field) (field-fieldtype field-decl)) 
;;                          (field-fieldtype field-decl) cl hp)))
</span>

<span class="comment">;;; maintain that heap being the same with non-defensive machine. 
</span>

(<span class="keyword">defun</span> <span class="function-name">consistent-fields</span> (fields field-decls cl hp)
  (<span class="keyword">declare</span> (xargs <span class="builtin">:guard</span> (and (consistent-class-hierachy cl)
                              (wff-heap-strong hp))))
  (<span class="keyword">cond</span> ((not (consp fields)) (not (consp field-decls)))
        ((not (consp field-decls)) nil)
        (t (and (consistent-field (car fields) (car field-decls) cl hp)
                (consistent-fields (cdr fields) (cdr field-decls) cl hp)))))


      
(<span class="keyword">defun</span> <span class="function-name">consistent-immedidate-instance</span> (obj-type immediate-instance cl hp)
  (<span class="keyword">declare</span> (xargs <span class="builtin">:guard</span> (and (consistent-class-hierachy cl)
                              (consp immediate-instance)
                              (wff-heap-strong hp))))
  (and (wff-immediate-instance immediate-instance)
       (equal obj-type (car immediate-instance))  
       <span class="comment">;; this is not right
</span>       (class-exists? obj-type cl)
       <span class="comment">;; does not handle array object well. 
</span>       (<span class="keyword">let</span> ((fields (cdr immediate-instance))
             (field-decls (fields (class-by-name obj-type cl))))
         (and (alistp fields) <span class="comment">;; Thu Jun  9 13:30:08 2005.
</span>              <span class="comment">;; added because GETFIELD. 
</span>              (consistent-fields fields field-decls cl hp)))))


<span class="comment">;;
;; Where I should check for java.lang.Object, or check for the superclass of
;; obj-type is nil? if I check for java.lang.Object, the termination relies on
;; an invariant that super of each eventually ends in java.lang.Object
;;
;;
;; should I use the internal class table as the "cl"??  Then I need invariant
;; about internal class table with respect to external class-table
;;
;; Prove some property of class loader, class loader preserve the consistency. 
;; consistency is important. (However if model is not accurate such proof is
;; not so meaningful
</span>

(<span class="keyword">defun</span> <span class="function-name">consistent-jvp</span> (obj-type jvp cl hp)
  (<span class="keyword">declare</span> (xargs   <span class="builtin">:guard</span> (and (consistent-class-hierachy cl)
                                (wff-heap-strong hp))
                    <span class="builtin">:measure</span> (len jvp)))
  (and (alistp jvp)
       (<span class="keyword">cond</span> ((&lt; (len jvp) 1) nil)
             ((equal (len jvp) 1) 
              (and (equal obj-type <span class="string">"java.lang.Object"</span>)
                   (consistent-immedidate-instance obj-type (car jvp) cl hp)))
             (t (and (consistent-immedidate-instance obj-type (car jvp) cl hp)
                     (<span class="keyword">let*</span> ((class-decl (class-by-name obj-type cl))
                            (super (super class-decl)))
                       (and (class-exists? super cl)
                            (consistent-jvp super (cdr jvp) cl hp))))))))




(defthm wff-obj-implies-wff-internal-heap-obj 
  (implies (wff-obj-strong obj)
           (wff-internal-heap-obj obj))
  <span class="builtin">:hints</span> ((<span class="string">"Goal"</span> <span class="builtin">:in-theory</span> (enable wff-obj)))
  <span class="builtin">:rule-classes</span> <span class="builtin">:forward-chaining</span>)

(in-theory (enable wff-obj-strong))

(<span class="keyword">defun</span> <span class="function-name">consistent-object</span> (obj hp cl) 
  (<span class="keyword">declare</span> (xargs <span class="builtin">:guard</span> (and (consistent-class-hierachy cl)
                              (wff-heap-strong hp))))
                  
  <span class="comment">;; assumping cl is consistent and is instance-class-table 
</span>  <span class="comment">;; need to check the monitor consistency? Maybe just wff is good enough
</span>  <span class="comment">;; execution of interpreter can handle it well. 
</span>  (and (wff-obj-strong obj)
       (reference-type (obj-type obj))       <span class="comment">;; more assertions.
</span>       (not (primitive-type? (obj-type obj))) <span class="comment">;; not necessary once we have above!
</span>       (<span class="keyword">if</span> (isArrayType (obj-type obj))
           t<span class="comment">;; we will check the array-consistent in a different predicated 
</span>         <span class="comment">;; here!! we could not avoid the mutural recursion in the array-object +
</span>         <span class="comment">;; instance object.!! 
</span>         <span class="comment">;; NO we can avoid it because we only eventually every pointer in an array
</span>         <span class="comment">;; has to be bound to some consistent-object or some consistent-array-object.
</span>         <span class="comment">;; by virtual of referring to an object in a consistent heap which only
</span>         <span class="comment">;; assert that one level dereference is consistent,  we can show infiniti
</span>         <span class="comment">;; level of dereference is consistent. 
</span>         <span class="comment">;; 
</span>         (and<span class="comment">;;(wff-obj-strong obj) ;; top level syntatically ok, 3 components 
</span>          <span class="comment">;; wff-obj-strong allow us to use obj-type without causing an error
</span>          (class-exists? (obj-type obj) cl) 
          (consistent-jvp (obj-type obj) (java-visible-portion obj) cl hp)))))




<span class="comment">;; (in-theory (disable consistent-class-hierachy)) 
;; seem to be a nice concept that many thing depends on it no need to open its
;; definition
</span>
<span class="comment">;;;
;;; MAYBE I SHOULD WORD ON THE GUARD OF CONSISTENT-STATE
;;;
</span>
(<span class="keyword">defun</span> <span class="function-name">consistent-heap1</span> (hp1 hp cl id)
  (<span class="keyword">declare</span> (xargs <span class="builtin">:guard</span> (and (consistent-class-hierachy cl)
                              (wff-heap-strong hp))))
  (and (integerp id)
       (alistp hp1)
       (<span class="keyword">if</span> (endp hp1) t
         (and (equal (caar hp1) id)
              (consistent-object (cdar hp1) hp cl) <span class="comment">;; consistent object or
</span>                                                   <span class="comment">;; array object 
</span>              (consistent-heap1 (cdr hp1) hp cl (+ 1 id))))))

<span class="comment">;;
;; Thinking about using record book for implemention the heap ...  what
;; benefit? record book still has not got an iterator?? so that we can say for
;; all fields, value type consistent?
;;
;; currently we are traverse the object in a "particular" order and assert
;; consistency. Our way is quite "white" box. We know the order of fields in
;; the memory layout in some sense. 
;;
;; We can't say set of all without giving away to construct such a set. And
;; proofs depend on how we construct the set.  Maybe it is necessary, because
;; we need to able to tell the membership with the set. Implicitly (high-order)
;; we can claim an object "comes" from  a consistent-heap, thus we can derive
;; many properties of the "object". We have to be very explicit in how we get
;; the "object". We may be able to benefit from the record book, which hide
;; from the representation of the objects.
;; 
</span>
<span class="comment">;; (i-am-here) ;; Sun Nov  7 19:44:38 2004
</span>
<span class="comment">;; (defun array-class-exists? (array-type acl)
;;   (declare (xargs :guard (and (alistp acl)
;;                               (wff-array-type array-type))))
;;   (bound? (array-component-type array-type) acl))
</span>
<span class="comment">;;; Sun Nov  7 22:17:25 2004
</span>
(<span class="keyword">defun</span> <span class="function-name">array-class-exists?</span> (array-type acl)
  (<span class="keyword">declare</span> (xargs <span class="builtin">:guard</span> (and (alistp acl)
                              (wff-array-type array-type))))
  (bound? array-type acl))


(<span class="keyword">defun</span> <span class="function-name">array-obj-consistent1</span> (data-array component-type hp cl)
  (<span class="keyword">declare</span> (xargs <span class="builtin">:guard</span> (and (true-listp data-array)
                              (wff-heap-strong hp)
                              (consistent-class-hierachy cl))))
  (<span class="keyword">if</span> (endp data-array) t
    (and (consistent-value (tag (car data-array) component-type) component-type cl hp)
         (array-obj-consistent1 (cdr data-array) component-type hp cl))))

<span class="comment">;;
;; we could chose to write <a href="consistent-state.lisp.html">consistent-state</a> in such a way, that we always check
;; synatx before doing anything. Thus we don't need seperate wff-XXX concept. 
;;
</span>

<span class="comment">;; (defun wff-INSTANCE_CLASS-specific-info (specific-info)
;;   (and (true-listp specific-info)
;;        (equal (len specific-info) 4)
;;        (equal (car specific-info) 'specific-info)
;;        (equal (nth 1 specific-info) 'INSTANCE_CLASS)
;;        (wff-type-desc (nth 2 specific-info))))
</span>
<span class="comment">;; (defun wff-ARRAY_CLASS-specific-info (specific-info)
;;   (and (true-listp specific-info)
;;        (equal (len specific-info) 3)
;;        (equal (car specific-info) 'specific-info)
;;        (equal (nth 1 specific-info) 'ARRAY_CLASS)
;;        (wff-type-desc (nth 2 specific-info))))
</span>

<span class="comment">;; (defun wff-ARRAY-specific-info (specific-info)
;;    (and (true-listp specific-info)
;;         (equal (len specific-info) 4)
;;         (equal (car specific-info) 'specific-info)
;;         (equal (nth 1 specific-info) 'ARRAY)
;;         (integerp (nth 3 specific-info))
;;         (true-listp (nth 2 specific-info))
;;         (equal (len (nth 2 specific-info)) (nth 3 specific-info))))
</span>
<span class="comment">;; (defun wff-STRING-specific-info (specific-info)
;;    (and (true-listp specific-info)
;;         (equal (len specific-info) 4)
;;         (equal (car specific-info) 'specific-info)
;;         (equal (nth 1 specific-info) 'STRING)
;;         (or (stringp (nth 3 specific-info))
;;             (equal (nth 3 specific-info) -1))))
;; ;;           (nullp (nth 3 specific-info)))))
;; ;;          ^^^^^^^           
</span>
<span class="comment">;; ; (defun wff-specific-info (specific-info)
;; ;   (or (wff-INSTANCE_CLASS-specific-info specific-info)
;; ;       (wff-ARRAY_CLASS-specific-info specific-info)
;; ;       (wff-ARRAY-specific-info specific-info)
;; ;       (wff-STRING-specific-info specific-info)
;; ;       (wff-GENERIC_OBJECT-specific-info specific-info)))
</span>

<span class="comment">;; (defun wff-internal-array (array-obj)
;;    (and (wff-obj-strong array-obj)
;;         (wff-array-type (obj-type array-obj))
;;         (wff-ARRAY-specific-info (specific-info array-obj))))
</span>

<span class="comment">;;; this is in conflict with shared' part's definition. 
</span>

<span class="comment">;; (defun array-bound (array-obj) 
;;   (declare (xargs :guard (wff-internal-array array-obj)))
;;   (let ((array-specific-info (specific-info array-obj)))
;;     (nth 3 array-specific-info)))
</span>

<span class="comment">;; (defun array-data (array-obj)
;;   (declare (xargs :guard (wff-internal-array array-obj)))
;;   (let ((array-specific-info (specific-info array-obj)))
;;     (nth 2 array-specific-info)))
</span>
<span class="comment">;;;;; moved to jvm-object-manipulation-primitives.lisp
</span>

<span class="comment">;;;
;;; should move those around to the shared part. Tue Jan 13 14:23:04 2004
;;;
;;;; moved to 
</span>

<span class="comment">; (defun element-at (index array)
;   (nth index (array-data array)))
</span>

<span class="comment">; (defun init-array (type count)
;   (if (zp count)
;       nil
;       (cons (default-value type) (init-array type (- count 1)))))
</span>
(<span class="keyword">defun</span> <span class="function-name">array-obj-consistent</span> (array-type array-obj hp cl)
  (<span class="keyword">declare</span> (xargs <span class="builtin">:guard</span> (and (wff-internal-array array-obj)
                              (wff-heap-strong hp)
                              (wff-array-type array-type)
                              (consistent-class-hierachy cl))))
  (<span class="keyword">let*</span> ((component-type (array-component-type array-type))
         (bound (array-bound array-obj))
         (data-array (array-data array-obj)))
    (and (equal (len data-array) bound)
         (array-obj-consistent1 data-array component-type hp cl))))


<span class="comment">;; (defun wff-array-class-table (acl)
;;   (alistp acl))
</span>
(defthm wff-array-class-table-implies-alistp
  (implies (wff-array-class-table acl)
           (alistp acl))
  <span class="builtin">:rule-classes</span> <span class="builtin">:forward-chaining</span>)



(<span class="keyword">defun</span> <span class="function-name">valid-array-type</span> (arraytype cl acl)
  <span class="comment">;; Sat Oct 30 00:25:04 2004
</span>  (<span class="keyword">declare</span> (xargs <span class="builtin">:guard</span> (and (wff-instance-class-table cl)
                              (wff-array-class-table acl))))
  (and (array-type-s arraytype cl)
       (<span class="keyword">let</span> ((basetype (array-component-type arraytype)))
         (and (ArrayClassLoaded1? (make-array-type basetype) acl)
              (<span class="keyword">if</span> (isArrayType basetype)
                  (valid-array-type basetype cl acl)
                (or (primitive-type? basetype)
                    (isClassTerm (class-by-name basetype cl))))))))

       


(<span class="keyword">defun</span> <span class="function-name">consistent-array-object</span> (obj hp cl acl)
  (<span class="keyword">declare</span> (xargs <span class="builtin">:guard</span> (and (consistent-class-hierachy cl)
                              (wff-array-class-table acl)
                              (wff-obj-strong obj)
                              (wff-heap-strong hp))))
  (<span class="keyword">let</span> ((obj-type (obj-type obj)))
    (and (wff-internal-array obj)
         (valid-array-type obj-type cl acl) <span class="comment">;; 
</span>         (array-type-s obj-type cl)
         (array-class-exists? obj-type acl)
         (array-obj-consistent obj-type obj hp cl)
         (consistent-jvp <span class="string">"java.lang.Object"</span> 
                         (java-visible-portion obj) cl hp))))
                         

<span class="comment">;;
;; basically we need to prove in a consistent-state, build a new obj, the new
;; object is consistent, etc. build an new array, the array is consistent. 
;; 
;; Does defensive machine also need to record information about whether an
;; object is initialized? check any operation before initialization?? 
;; 
;; YES!! we need to do that. object of class java.lang.Object is by default
;; initialized, other objects need an explicit call to some &lt;init&gt; method to
;; correctly mark it. We also want to show init is not called twice? YES. 
;;
;; BCV guarantees this by expecting &lt;init&gt; is invoked with (uninitialized ...) 
;; or 'uninitializedThis
;; 
;; How could be sure that constructor actually call all super's constructors??
;; Suppose A ...  B  ... C. create a raw object of A, we only call C's
;; constructor to initialize the C part and skipping B part.
;; HOWEVER this is programmer's responsibility. The constructor of A must be
;; called and called only once. This is what BCV guarantees.
;;
;; As long as programmer write correct code for A, people have not corrupted
;; the system yet, this won't cause someone create a improperly initialized
;; object.
</span>
(<span class="keyword">defun</span> <span class="function-name">consistent-heap2</span> (hp1 hp cl acl id)
  (<span class="keyword">declare</span> (xargs <span class="builtin">:guard</span> (and (consistent-class-hierachy cl)
                              (wff-array-class-table acl)
                              (integerp id)
                              (wff-heap-strong hp1)
                              (wff-heap-strong hp))))
  (and (integerp id)
       (alistp hp1)
       (<span class="keyword">if</span> (endp hp1) t
         (and (equal (caar hp1) id)
              (wff-obj-strong (cdar hp1))
              (<span class="keyword">if</span> (isArrayType (obj-type (cdar hp1)))
                  (consistent-array-object (cdar hp1) hp cl acl)
                t)
              <span class="comment">;; either not array-type or a consistent-array-obj
</span>              (consistent-heap2 (cdr hp1) hp cl acl (+ 1 id ))))))



(<span class="keyword">defun</span> <span class="function-name">consistent-heap</span> (hp cl acl)
  (<span class="keyword">declare</span> (xargs <span class="builtin">:guard</span> (and (consistent-class-hierachy cl)
                              (wff-array-class-table acl))))
  (and (wff-heap-strong hp)
       (consistent-heap1 hp hp cl 0)
       (consistent-heap2 hp hp cl acl 0)))

<span class="comment">;; WITHOUT CONSISTENT-HEAP THIS ONLY ASSERT THAT Java visible part are
;; consistent with types.
;;
;;    
;; We need some properties about operations that maintain the consistency of
;; heap
;; 
</span>
<span class="comment">;; How strong we want this is <a href="consistent-state.lisp.html">consistent-state</a> predict We want each value in
;; the state is meaningful?  thread ref really point to a real object that
;; represent the thread.
;; 
;; Only with that we could prove from a consistent state we always reach a
;; consistent state, using a defensive machine or a non-defensive machine that
;; use a bytecode verifier. 
;;
;; However safety is more than maintaining the consistency of the JVM state.
;; some policy like protected access permission must also be honored (in the
;; defensive machine they are checked at runtime) Our proof effort can be
;; considered as justifing the correctness of implementations that rely on a
;; bytecode verifier to remove certain check at runtime.
;;
;; In any execution, object is initialized before being used. 
;;
;; access control is respected (dynamic check + protected access control check)
;;
</span>
<span class="comment">;;
;; In the first step, showing consistency is low level security. 
;; 
</span>
<span class="comment">;; Our consistency of value is defined using instance-class-table, which itself
;; is created by. We need(?) to define a consistency between
;; instance-class-table. correctly-loaded? predicate? 
</span>
<span class="comment">;;
;; need something from the fourth proof.  all classes in the class table are
;; correctedly loaded from the ...
;; 
;; An interface  method is invoked with invokeinterface, the class of the
;; actual object really declared to implement the interface. This is not
;; checked by the class loader. It needs to be checked at runtime by both
;; defensive and non-defensive machines.
;;
</span>

<span class="comment">;; WHY? I need to go into this much details to define those consistent-...
;; because otherwise the leaf proofs does not make sense. Proving a trivial
;; <a href="consistent-state.lisp.html">consistent-state</a> does not say a lot.
</span>
<span class="comment">;; That loading invariant only talked about class hierachy?  it has not talked
;; about the fields and methods matches...  Do consistent-value need this fact
;; that fields matches??  maybe the hierachy info encoded in the internal
;; class-table is same with static class table are good enough. That is encoded
;; by the loader-inv. 
</span>
<span class="comment">;; notice we have two class table now. (instance-class-table, array-class-table)
</span>


<span class="comment">; (defun make-static-field (classname fieldname fieldtype accessflags value)
;   (list 'static-field 
;         classname 
;         fieldname 
;         fieldtype 
;         (cons 'accessflags accessflags)
;         value))
</span>
<span class="comment">; (defun static-field-classname  (field)  (nth 1 field))
; (defun static-field-fieldname  (field)  (nth 2 field))
; (defun static-field-fieldtype  (field)  (nth 3 field))
; (defun static-field-accessflags (field)  (cdr (nth 4 field))) ;; don't need cpindex
; (defun static-field-fieldvalue (field)  (nth 5 fields))
</span>

<span class="comment">;; (defun wff-static-field (static-field)
;;   (and (true-listp static-field)
;;        (equal (len static-field) 6)
;;        (consp (nth 4 static-field))
;;        (true-listp (cdr (nth 4 static-field)))))
</span>
<span class="comment">;; (defun static-field-classname  (field)  
;;   (declare (xargs :guard (wff-static-field field)))
;;   (nth 1 field))
;; (defun static-field-fieldname  (field)  
;;   (declare (xargs :guard (wff-static-field field)))
;;   (nth 2 field))
;; (defun static-field-fieldtype  (field)  
;;   (declare (xargs :guard (wff-static-field field)))
;;   (nth 3 field))
;; (defun static-field-accessflags (field) 
;;     (declare (xargs :guard (wff-static-field field)))
;;     (cdr (nth 4 field))) ;; don't need cpindex
;; (defun static-field-fieldvalue (field)  
;;   (declare (xargs :guard (wff-static-field field)))  
;;   (nth 5 field))
</span>
       


(<span class="keyword">defun</span> <span class="function-name">consistent-static-field</span> (classname static-field cl hp)
  (<span class="keyword">declare</span> (xargs <span class="builtin">:guard</span> (and (wff-static-field static-field)
                              (consistent-class-hierachy cl)
                              (wff-heap-strong hp))))
    (<span class="keyword">let</span>  ((cname (static-field-classname static-field))
           (ftype (static-field-fieldtype static-field))
           (fvalue (static-field-fieldvalue static-field)))
      (and (equal classname cname)
           (consistent-value (tag fvalue ftype) ftype cl hp))))

(<span class="keyword">defun</span> <span class="function-name">wff-static-fields-strong</span> (fields)
  (<span class="keyword">if</span> (not (consp fields)) t
    (and (wff-static-field (car fields))
         (wff-static-fields-strong (cdr fields)))))

(<span class="keyword">defun</span> <span class="function-name">consistent-static-fields</span> (classname static-fields cl hp)
    (<span class="keyword">declare</span> (xargs <span class="builtin">:guard</span> (and (wff-static-fields-strong static-fields)
                                (consistent-class-hierachy cl)
                                (wff-heap-strong hp))))
  <span class="comment">;; we will check that static-fields matches the fields that have static flags
</span>  <span class="comment">;; in the .class file representation
</span>  (<span class="keyword">if</span> (not (consp static-fields)) t <span class="comment">;; return t here.
</span>    (and (consistent-static-field classname (car static-fields) cl hp)
         (consistent-static-fields classname (cdr static-fields) cl hp))))


(<span class="keyword">defun</span> <span class="function-name">tag-REF</span> (v)
  (cons 'REF v))



<span class="comment">;;; Fri Nov  5 12:05:30 2004
;;; 
;;;   consistent-constantpool defined!! 
;;; 
</span>
<span class="comment">;;; So far, we only support three kinds of cpentry-type
</span>
(defthm wff-common-info-wff-obj-strong
  (implies (wff-obj-strong obj)
           (wff-common-info (common-info obj)))
  <span class="builtin">:rule-classes</span> <span class="builtin">:forward-chaining</span>)

(<span class="keyword">defun</span> <span class="function-name">consistent-constantpool-entry</span> (cp hp cl)
  (<span class="keyword">declare</span> (ignore cl))
  (<span class="keyword">declare</span> (xargs <span class="builtin">:guard</span> (and (wff-constant-pool-entry cp)
                              (wff-heap-strong hp)
                              (wff-instance-class-table cl))
                  <span class="builtin">:guard-hints</span> ((<span class="string">"Goal"</span> <span class="builtin">:in-theory</span> (enable
                                                    wff-constant-pool-entry
                                                    binding
                                                    bound?)))))
  (<span class="keyword">cond</span> ((equal (cpentry-type cp) 'INT)  (INT32p (cpentry-value cp)))
        ((equal (cpentry-type cp) 'LONG) (INT64p (cpentry-value cp)))
        ((equal (cpentry-type cp) 'STRING) 
         (and (bound? (cpentry-value cp) hp)
              (equal  (obj-type (deref (cpentry-value cp) hp))
                      <span class="string">"java.lang.String"</span>)))))

<span class="comment">;;; Fri Nov  5 12:11:54 2004. We will need to make it clear
;;; in wff-constant-pool-entry-s!! 
;;; it is already clear there. Fri Nov  5 12:18:24 2004 
</span>
(<span class="keyword">defun</span> <span class="function-name">consistent-constantpool</span> (cps hp cl)
  (<span class="keyword">declare</span> (xargs <span class="builtin">:guard</span> (and (wff-constant-pool cps)
                              (wff-heap-strong hp)
                              (wff-instance-class-table cl))))
  <span class="comment">;; (declare (ignore cps hp cl))
</span>  (<span class="keyword">if</span> (not (consp cps)) t
    <span class="comment">;; we only allow certain fields in the cps
</span>    (and (consistent-constantpool-entry (car cps) hp cl)
         (consistent-constantpool (cdr cps) hp cl)))) 


(<span class="keyword">defun</span> <span class="function-name">wff-class-rep-strongx</span> (class-decl)
  (and (wff-class-rep-strong class-decl)
       (wff-static-fields-strong (static-fields class-decl))))



<span class="comment">;; Mon Mar 29 21:30:47 2004
</span>(<span class="keyword">defun</span> <span class="function-name">consistent-handlers</span> (handlers)
  (<span class="keyword">declare</span> (ignore handlers))
  t)


(<span class="keyword">defun</span> <span class="function-name">consistent-instructions</span> (instrs)
  (<span class="keyword">declare</span> (ignore instrs))
  t)

<span class="comment">;; Mon Mar 29 21:32:16 2004 Temp implementation
</span>
(<span class="keyword">defun</span> <span class="function-name">consistent-code</span> (code) 
  (and (wff-code code)
       (integerp (code-max-Stack code))
       (integerp (code-max-local code))
       (consistent-handlers (code-handlers code))
       (consistent-instructions (code-instrs code))))


(<span class="keyword">defun</span> <span class="function-name">consistent-method-decl</span> (method-decl)
  (and (wff-method-decl method-decl)
       (true-listp (method-accessflags method-decl))
       (<span class="keyword">if</span> (or (mem '*abstract* (method-accessflags method-decl))
               (mem '*native* (method-accessflags method-decl)))
           <span class="comment">;; (not (method-code method-decl))
</span>           t <span class="comment">;; replace with it a T ;; Mon Nov  8 19:13:03 2004
</span>         (consistent-code (method-code method-decl)))))
           

(<span class="keyword">defun</span> <span class="function-name">consistent-method-decls</span> (method-decls)
  (<span class="keyword">if</span> (not (consp method-decls))
      t
    (and (consistent-method-decl (car method-decls))
         (consistent-method-decls (cdr method-decls)))))


(<span class="keyword">defun</span> <span class="function-name">consistent-class-decl</span> (class-decl cl hp)
  (<span class="keyword">declare</span> (xargs <span class="builtin">:guard</span> (and (consistent-class-hierachy cl)
                              (wff-class-rep-strongx class-decl)
                              (wff-heap-strong hp))))
  <span class="comment">;; this one only talks about value are consistent however it does not talk
</span>  <span class="comment">;; about fields, method matches. in context of dynamic loading ... intend to
</span>  <span class="comment">;; skip prove the matches.  also need to check static variables. any value
</span>  <span class="comment">;; that could show up on the op stack or local variables
</span>  (and <span class="comment">;; need ASSERTION ABOUT CONSTANT POOL be consistent, well-formed. 
</span>       <span class="comment">;; need to assert the classname being a string. Wed Nov 19 02:23:43 2003
</span>       <span class="comment">;; because we don't want a class of name 
</span>       <span class="comment">;; (array (class "java.lang.Object")) be treated as an array. 
</span>       (stringp (classname class-decl)) <span class="comment">;; need to modify loader to ensure
</span>                                        <span class="comment">;; this.
</span>       <span class="comment">;; Wed Nov 19 02:25:22 2003
</span>       <span class="comment">;; 
</span>       <span class="comment">;; Mon Mar 29 21:16:55 2004. Add assertions that method are well formed
</span>       <span class="comment">;;
</span>
       <span class="comment">;; Thu Jun  9 15:19:06 2005. need to add assertions about
</span>       <span class="comment">;; interface-class does not have fields. 
</span>       (or (not (isInterface class-decl))
           (equal (fields class-decl) nil))
       <span class="comment">;; Thu Jun  9 15:20:34 2005. 
</span>       (consistent-method-decls (methods class-decl))
       (consistent-constantpool (constantpool class-decl) hp cl)
       (consistent-value (tag-REF (class-ref class-decl)) <span class="string">"java.lang.Class"</span> cl hp)
       (Valid-REFp (tag-REF (class-ref class-decl)) hp)
       (consistent-static-fields (classname class-decl) (static-fields class-decl) cl hp)))
  <span class="comment">;; assumption this ref-value is in form (REF . value)
</span>
<span class="comment">;;  09/09/03  ALL THESE DOES NOT MATTER for <a href="INST/AALOAD.lisp.html">AALOAD</a> PROOF.
</span>
<span class="comment">;;; Mon Mar 29 21:34:14 2004. modified consistent-class-decl to assert
;;; well-formedness of method-code
;;;
</span>
(<span class="keyword">defun</span> <span class="function-name">consistent-class-decls</span> (cl1 cl hp)
    (<span class="keyword">declare</span> (xargs <span class="builtin">:guard</span> (and (consistent-class-hierachy cl)
                                (wff-heap-strong hp))))
  <span class="comment">;; this version only talks about the static field values, class-ref etc.
</span>  <span class="comment">;; with respect to the instance class-table 
</span>  <span class="comment">;; loader-inv will talk about class hierachy matches. 
</span>  (<span class="keyword">if</span> (not (consp cl1)) t
    (and (wff-class-rep-strongx (car cl1))
         (consistent-class-decl  (car cl1) cl hp)
         (consistent-class-decls (cdr cl1) cl hp))))

<span class="comment">;; (defun class-hierachy-match (cl scl)
;;;  (m6::loader-inv-helper cl cl scl))
</span>
<span class="comment">; (defun fields-declaration-match (cl scl)
;   ;; tmp implementation
;   (declare (ignore cl scl))
;   t)
</span>
<span class="comment">; (defun consistent-class-decls2 (cl scl)
;   ;; assert the class hierachy matches 
;   ;; We also need to assert that class and field matches? Do we? 
;   ;; However IN REAL JVM, BCV use the cl to do the type checking!!
;   (and (class-hierachy-match cl scl)
;        (fields-delcaration-match cl scl)))
</span>
<span class="comment">;;
;; NEED to write this out. We can skip prove it but the spec need to be
;; there. 
;;
</span>
(<span class="keyword">defun</span> <span class="function-name">consistent-class-table</span> (cl scl hp)
  (<span class="keyword">declare</span> (xargs <span class="builtin">:guard</span> (and (wff-heap-strong hp)
                              (wff-static-class-table-strong scl))))
  (and (wff-instance-class-table-strong cl)
       (consistent-class-hierachy cl)
       <span class="comment">;; all symbolic reference to super and interfaces are actually present
</span>       <span class="comment">;; not loops in supers, and interfaces. 
</span>       (class-table-is-loaded-from cl scl)
       <span class="comment">;; loaded correctly from the class-table 
</span>       <span class="comment">;;
</span>       (consistent-class-decls cl cl hp)))
       <span class="comment">;; in fact bcv also use cl. However in bcv spec, bcv use scl. N ext form
</span>       <span class="comment">;; is say cl and scl is consistent with each other
</span>       <span class="comment">;; check fields declaration match? Guaranteed by class loader.
</span>       <span class="comment">;; So far we only proved that class-hierachy-match
</span>

<span class="comment">;; this does not check the class hierachy is correct
;; runtime error? 
</span>
<span class="comment">; (defun classImplementInterface2 (rtype interfacetype cl)
;   (declare (ignore rtype interfacetype cl))
;   t)
</span>

<span class="comment">;; we need a skip proof that 
;; 
;; bytecode from from a dereferencing a valid method-ptr is one of bytecode
;; verifier have looked at. 
;; 
;(skip-proofs 
; (defthm BCV-valid-method-ptr-code-verified 
;   t)
</span>
<span class="comment">;; ;   Methods 
;; (defun make-method (classname methodname args returntype accessflags code)
;;   (list 'method 
;;         classname 
;;         methodname 
;;         (cons 'parameters args)
;;         (cons 'returntype returntype)
;;         (cons 'accessflags accessflags)
;;         code))
</span>

<span class="comment">; A typical method 
;
; (METHOD
;  "java.lang.Class" "&lt;init&gt;" (PARAMETERS)
;  (RETURNTYPE . VOID)
;  (ACCESSFLAGS *CLASS* *PRIVATE*)
;  (CODE
;      (MAX_STACK . 1)
;      (MAX_LOCAL . 1)
;      (CODE_LENGTH . 5)
;      (PARSEDCODE
;           (0 (ALOAD_0))
;           (1 (INVOKESPECIAL (METHODCP "&lt;init&gt;" "java.lang.Object" NIL VOID)))
;           (4 (RETURN))
;           (ENDOFCODE 5))
;      (EXCEPTIONS)
;      (STACKMAP)))
</span>

(<span class="keyword">defun</span> <span class="function-name">abstract-method</span> (method-rep)
  (<span class="keyword">declare</span> (xargs <span class="builtin">:guard</span> (wff-method-decl method-rep)))
  (mem '*abstract* (method-accessflags method-rep)))



<span class="comment">;; methods is a list of method
</span>


<span class="comment">;; ;; method-ptr is a ACL2 object that can be used to locate the method.
;; (defun make-method-ptr (classname methodname args-type return-type)
;;   (list 'method-ptr classname methodname args-type return-type))
</span>
<span class="comment">;; (defun wff-method-ptr (method-ptr)
;;   (and (true-listp method-ptr)
;;        (equal (len method-ptr) 5)
;; ;;     (consp (nth 3 method-ptr)) this is not necessary. in conflict with
;; ;; functions with no parameter. FIXED 10/28/03
;;        (true-listp (nth 3 method-ptr))))
</span>       


<span class="comment">;; (defun method-ptr-classname   (method-ptr) 
;;   (declare (xargs :guard (wff-method-ptr method-ptr)))
;;   (nth 1 method-ptr))
</span>
<span class="comment">;; (defun method-ptr-methodname  (method-ptr)  
;;   (declare (xargs :guard (wff-method-ptr method-ptr)))
;;   (nth 2 method-ptr))
</span>
<span class="comment">;; (defun method-ptr-args-type   (method-ptr) 
;;   (declare (xargs :guard (wff-method-ptr method-ptr)))
;;   (nth 3 method-ptr))
</span>
<span class="comment">;; (defun method-ptr-returntype  (method-ptr)  
;;   (declare (xargs :guard (wff-method-ptr method-ptr)))
;;   (nth 4 method-ptr))
</span>
<span class="comment">;;
;; this needed because we need to assert that in <a href="consistent-state.lisp.html">consistent-state</a> the
;; method-ptr points to correct location!!
;;
</span>
<span class="comment">;; (defun wff-method-decls (methods)
;;   (if (not (consp methods)) t
;;     (and (wff-method-decl (car methods))
;;          (wff-method-decls (cdr methods)))))
</span>

<span class="comment">;; (defun searchMethod (method-ptr methods)
;;   (declare (xargs :guard (and (true-listp methods)
;;                               (wff-method-decls methods)
;;                               (wff-method-ptr method-ptr))))
;;   (if (endp methods)
;;       nil
;;     (let* ((methodname (method-ptr-methodname method-ptr))
;;            (args       (method-ptr-args-type  method-ptr))
;;            (returntype (method-ptr-returntype method-ptr))
;;            (thisMethod (car methods)))
;;       (if (and (equal (method-methodname thisMethod) methodname)
;;                (equal (method-args       thisMethod) args)
;;                (equal (method-returntype thisMethod) returntype))
;;           thisMethod
;;         (searchMethod method-ptr (cdr methods))))))
</span>



<span class="comment">;; (defun deref-method (method-ptr class-table)
;;   (declare (xargs :guard (and (wff-method-ptr method-ptr)
;;                               (wff-instance-class-table class-table))))
;;   (and (class-exists? (method-ptr-classname method-ptr) class-table)
;;        (let* ((classname (method-ptr-classname method-ptr))
;;               (class-rep (class-by-name classname class-table))
;;               (methods   (methods class-rep)))
;;          (and  (wff-method-decls methods)
;;                (searchMethod method-ptr methods)))))
</span>

(<span class="keyword">defun</span> <span class="function-name">method-exists?</span> (method-ptr cl)
     (<span class="keyword">declare</span> (xargs <span class="builtin">:guard</span> (and (wff-method-ptr method-ptr)
                                 (wff-instance-class-table cl))))
     (deref-method method-ptr cl))


(defthm search-method-mem-l
  (implies (searchMethod any-ptr l)
           (mem (searchMethod any-ptr l) l))
  <span class="builtin">:rule-classes</span> <span class="builtin">:forward-chaining</span>)
  

(defthm mem-wff-method-decls-wff-method-decl
  (implies (and (mem m methods)
                (wff-method-decls methods))
           (wff-method-decl m))
  <span class="builtin">:rule-classes</span> <span class="builtin">:forward-chaining</span>)


(defthm dereef-method-if-found-then-well-formed
  (implies (deref-method any-ptr cl)
           (wff-method-decl (deref-method any-ptr cl)))
  <span class="builtin">:hints</span> ((<span class="string">"Goal"</span> <span class="builtin">:in-theory</span> (disable wff-method-decl)))
  <span class="builtin">:rule-classes</span> <span class="builtin">:forward-chaining</span>)



(in-theory (disable deref-method))
<span class="comment">;; enought theorem about deref-method on
;; wff-method-ptr return wff-method
;; if deref-method returns, it returns well formed one. 
</span>

(<span class="keyword">defun</span> <span class="function-name">valid-method-ptr</span> (method-ptr cl)
  (<span class="keyword">declare</span> (xargs <span class="builtin">:guard</span> (and (wff-method-ptr method-ptr)
                              (wff-instance-class-table cl))))
  (and (method-exists? method-ptr cl)
       (not (abstract-method (deref-method method-ptr cl)))))

<span class="comment">; (defun valid-sync-obj (obj-ref hp)
;   (declare (xargs :guard (wff-heap hp)))
;   (bound? obj-ref hp)) ;; WRONG 
</span>

(<span class="keyword">defun</span> <span class="function-name">valid-sync-obj</span> (obj-ref hp)
  (<span class="keyword">declare</span> (xargs <span class="builtin">:guard</span> (wff-heap hp)))
  (or (equal obj-ref -1)
      (bound? obj-ref hp))) <span class="comment">;; fixed  10/28/03 
;;
;; Wed Jan 14 01:36:50 2004
</span>
(<span class="keyword">defun</span> <span class="function-name">Category1</span> (tvalue)
  (and (wff-tagged-value tvalue)
       (not (equal (tag-of tvalue) 'LONG))
       (not (equal (tag-of tvalue) 'DOUBLE))))

(<span class="keyword">defun</span> <span class="function-name">Category2</span> (tvalue)
  (and (wff-tagged-value tvalue)
       (or (equal (tag-of tvalue) 'LONG)
           (equal (tag-of tvalue) 'DOUBLE))))

(<span class="keyword">defun</span> <span class="function-name">top</span> (stack)
  (<span class="keyword">declare</span> (xargs <span class="builtin">:guard</span> (consp stack)))
  (car stack))

(<span class="keyword">defun</span> <span class="function-name">pop</span> (stack)
  (<span class="keyword">declare</span> (xargs <span class="builtin">:guard</span> (consp stack)))
  (cdr stack))

(<span class="keyword">defun</span> <span class="function-name">canPopCategory1</span> (stack)
  (and (&gt;= (len stack) 1)
       (Category1 (top stack))))

(<span class="keyword">defun</span> <span class="function-name">canPopCategory2</span> (stack)
  (and (&gt;= (len stack) 2)
       (Category2 (top stack))
       (equal (top (pop stack)) '(topx . topx))))

(<span class="keyword">defun</span> <span class="function-name">topCategory1</span> (stack)
  (<span class="keyword">declare</span> (xargs <span class="builtin">:guard</span> (canPopCategory1 stack)))
  (top stack))

(<span class="keyword">defun</span> <span class="function-name">topCategory2</span> (stack)
  (<span class="keyword">declare</span> (xargs <span class="builtin">:guard</span> (canPopCategory2 stack)))
  (top stack))


(<span class="keyword">defun</span> <span class="function-name">popCategory2</span> (stack)
  (<span class="keyword">declare</span> (xargs <span class="builtin">:guard</span> (canPopCategory2 stack)))
  (pop (pop stack)))

(<span class="keyword">defun</span> <span class="function-name">popCategory1</span> (stack)
  (<span class="keyword">declare</span> (xargs <span class="builtin">:guard</span> (canPopCategory1 stack)))
  (pop stack))


(<span class="keyword">defun</span> <span class="function-name">consistent-value-x</span> (tagged-value cl hp)
  (<span class="keyword">declare</span> (xargs  <span class="builtin">:guard</span> (and (wff-tagged-value tagged-value)
                               (consistent-class-hierachy cl)
                               (wff-heap-strong hp))))
  (<span class="keyword">let</span> ((type  (tag-of tagged-value)))
    (<span class="keyword">if</span> (REFp tagged-value hp) t
      (consistent-value tagged-value type cl hp))))
  


(<span class="keyword">defun</span> <span class="function-name">consistent-opstack</span> (stack cl hp)
  (<span class="keyword">declare</span> (xargs <span class="builtin">:guard</span> (and (consistent-class-hierachy cl)
                              (wff-heap-strong hp))))
 (<span class="keyword">if</span> (not (consp stack)) (equal stack nil)
    (<span class="keyword">cond</span> ((canPopCategory1 stack)
           (and (consistent-value-x (topCategory1 stack) cl hp)
                (consistent-opstack (popCategory1 stack) cl hp)))
          ((canPopCategory2 stack)
           (and (consistent-value-x (topCategory2 stack) cl hp)
                (consistent-opstack (popCategory2 stack) cl hp))))))

<span class="comment">;; how do I check for return address being valid?? 
</span>

(<span class="keyword">defun</span> <span class="function-name">category1Loc</span> (locals)
  (and (consp locals)
       (wff-tagged-value (car locals))
       (Category1 (car locals))))

(<span class="keyword">defun</span> <span class="function-name">category2Loc</span> (locals)
  (and (consp locals)
       (consp (cdr locals))
       (wff-tagged-value (car locals))
       (Category2 (car locals))
       (wff-tagged-value (cadr locals))
       (equal (tag-of (cadr locals)) 'topx)))

<span class="comment">;; (defun category2Loc (locals)
;;   (and (consp locals)
;;        (consp (cdr locals))
;;        (wff-tagged-value (car locals))
;;        (Category2 (car locals))
;;        (equal (tag-of (car locals)) 'topx)))
</span>
(<span class="keyword">defun</span> <span class="function-name">shift1slot</span> (locals)
  (<span class="keyword">declare</span> (xargs <span class="builtin">:guard</span> (and (not (category2Loc locals))
                              (consp locals))))
  (cdr locals))

(<span class="keyword">defun</span> <span class="function-name">shift2slot</span> (locals)
  (<span class="keyword">declare</span> (xargs <span class="builtin">:guard</span> (category2Loc locals)))
  (cddr locals))

(<span class="keyword">defun</span> <span class="function-name">category1Value</span> (locals)
    (<span class="keyword">declare</span> (xargs <span class="builtin">:guard</span> (category1Loc locals)))
    (car locals))

(<span class="keyword">defun</span> <span class="function-name">category2Value</span> (locals)
    (<span class="keyword">declare</span> (xargs <span class="builtin">:guard</span> (category2Loc locals)))
    (car locals))


<span class="comment">;;
;; one different between local and opstack is that value TOP can appear in the
;; locals (representing uninitialized value)
;;
</span>

(<span class="keyword">defun</span> <span class="function-name">consistent-locals</span> (locals cl hp)
  <span class="comment">;; this one only assert a valid list of types. or top element.
</span>  (<span class="keyword">declare</span> (xargs <span class="builtin">:guard</span> (and (consistent-class-hierachy cl)
                              (wff-heap-strong hp))))
  (<span class="keyword">if</span> (not (consp locals)) (equal locals nil)
    (<span class="keyword">cond</span> ((category1Loc locals)
           (and (or (equal (tag-of (car locals)) 'topx)
                    (consistent-value-x  (category1Value locals) cl hp))
                (consistent-locals (shift1slot locals) cl hp)))
          ((category2Loc locals)
           (and (consistent-value-x (category2Value locals) cl hp)
                (consistent-locals (shift2slot locals) cl hp))))))


<span class="comment">;; ;; (defun consistent-locals (locals cl hp)
;; ;;   ;; this one only assert a valid list of types. or top element.
;; ;;   (declare (xargs :guard (and (consistent-class-hierachy cl)
;; ;;                               (wff-heap-strong hp))))
;; ;;   (if (not (consp locals)) (equal locals nil)
;; ;;     (cond ((category1Loc locals)
;; ;;            (and (consistent-value-x  (category1Value locals) cl hp)
;; ;;                 (consistent-locals (shift1slot locals) cl hp)))
;; ;;           ((category2Loc locals)
;; ;;            (and (consistent-value-x (category2Value locals) cl hp)
;; ;;                 (consistent-locals (shift2slot locals) cl hp))))))
</span>
<span class="comment">;; Tue Aug 10 14:22:28 2004
;; category1 or category2 
;; some may not be initialized TOP element.
;;
</span>
<span class="comment">;;
;; need to assert the size of the local for a consistent-state.
;;
</span>
<span class="comment">;; (defun wff-call-frame (frame)
;;   (and (true-listp frame)
;;        (equal (len frame) 6)
;;        (equal (car frame) 'frame)
;;        (consp (nth 1 frame))
;;        (consp (nth 2 frame))
;;        (consp (nth 3 frame))
;;        (wff-method-ptr (nth 4 frame))
;;        (consp (nth 5 frame))))
</span>

<span class="comment">;; ; (defun make-frame (return-pc operant-stack locals method-ptr sync-obj-ref)
;; ;   (list 'frame 
;; ;         (cons 'return_pc return-pc)
;; ;         (cons 'operand-stack operant-stack)
;; ;         (cons 'locals locals)
;; ;         method-ptr
;; ;         (cons 'sync-obj-ref sync-obj-ref)))
</span>
<span class="comment">;; (defun return-pc     (frame)    
;;   (declare (xargs :guard (wff-call-frame frame)))
;;   (cdr (nth 1 frame)))
</span>
<span class="comment">;; (defun operand-stack (frame)  
;;   (declare (xargs :guard (wff-call-frame frame)))
;;   (cdr (nth 2 frame)))
</span>
<span class="comment">;; (defun locals        (frame)   
;;   (declare (xargs :guard (wff-call-frame frame)))
;;   (cdr (nth 3 frame)))
</span>
<span class="comment">;; (defun method-ptr    (frame)  
;;   (declare (xargs :guard (wff-call-frame frame)))
;;   (nth 4 frame))
</span>
<span class="comment">;; (defun sync-obj-ref  (frame) 
;;   (declare (xargs :guard (wff-call-frame frame)))
;;   (cdr (nth 5 frame)))
</span>

<span class="comment">;;; moved to jvm-thread.lisp
</span>
<span class="comment">;;;;;;;;;;;;;;;;;; Wed Jan 14 02:00:21 2004 I AM HERE!!!!  ;;;;;;;;;;;;;;;;;;;;;
</span>
(in-theory (disable wff-heap))

<span class="comment">;; (acl2::set-verify-guards-eagerness 2)
</span>
(<span class="keyword">defun</span> <span class="function-name">consistent-frame-max-local</span> (frame cl)
  (mylet* ((method (deref-method (method-ptr frame) cl)))
          (and (wff-call-frame frame)
               (wff-method-ptr (method-ptr frame))
               (wff-instance-class-table cl)
               (wff-method-decl method)
               (or (mem '*abstract* (method-accessflags method))
                   (mem '*native*   (method-accessflags method))
                   (and (wff-code (method-code method))
                        (integerp (method-maxlocals method))
                        (&lt;= (len (locals frame))
                            (method-maxlocals method)))))))
  
<span class="comment">;(i-am-here)
</span>
<span class="comment">;;
;; We need to add a new assertion to say that all method code are well formed!! 
;;
</span>
<span class="comment">;; (defun wff-method-codes (methods)
;;   (if (not (consp methods)) t
;;     (and (wff-method-decl (car methods))
;;          (wff-code (method-code (car methods)))
;;          (integerp (method-maxlocals (car methods)))
;;          (integerp (method-maxstack  (car methods)))
;;          (wff-method-codes (cdr methods)))))
</span>

<span class="comment">;; (defun wff-methods-instance-class-rep (class-decl)
;;   (and (wff-class-rep class-decl)
;;        (wff-method-codes (methods class-decl))))
</span>

<span class="comment">;; (defun wff-methods-instance-class-table-strong (classes)
;;   (if (not (consp classes)) t
;;     (and (wff-methods-instance-class-rep (car classes))
;;          (wff-methods-instance-class-table-strong (cdr classes)))))
</span>

<span class="comment">;;; Sun May 16 21:07:10 2004. Note. class constructed by static class table may
;;; not be <a href="consistent-state.lisp.html">consistent-state</a> using above definition. For example: Native
;;; methods!!. Need to fix class loader to normalize the method
;;; representation!! or fix jvm2acl2!! Fix jvm2acl2, to always generated
;;; correctly formed methods. so that class loader just copying will be good
;;; enough!  
;;;                     Sun Oct 17 15:51:44 2004. already fixed!! 
;;; 
;;; 
;;; Sun Oct 17 15:48:01 2004. We need to assert that there is no frame that
;;; corresponds to some abstract method!! 
;;; 
</span>
<span class="comment">; (i-am-here) ;; Sun Oct 17 15:55:21 2004
</span>
(<span class="keyword">defun</span> <span class="function-name">consistent-frame</span> (frame cl hp)
  (<span class="keyword">declare</span> (xargs <span class="builtin">:guard</span> (and (consistent-class-hierachy cl)
                              (wff-heap-strong hp))))

  (mylet* ((method (deref-method (method-ptr frame) cl)))
          (and (wff-call-frame frame)
               (consistent-opstack (operand-stack frame) cl hp)
               (consistent-locals  (locals frame) cl hp)
               (consistent-frame-max-local frame cl)
               <span class="comment">;; return-pc' validity check could not be checked at frame level 
</span>               <span class="comment">;; we need caller frame to decide whether it is consistent
</span>               <span class="comment">;; 
</span>               <span class="comment">;; Tue Mar 30 16:10:14 2004 we did not check that len of locals is less
</span>               <span class="comment">;; than max-local. check at runtime
</span>               (wff-method-ptr (method-ptr frame))
               (valid-method-ptr (method-ptr frame) cl)
               (valid-sync-obj   (sync-obj-ref frame) hp)
               
               <span class="comment">;; Mon May 17 11:59:18 2004
</span>               <span class="comment">;; fixed to add assertions about max-stack!! 
</span>
               <span class="comment">;; Sun Oct 17 15:47:41 2004
</span>               (wff-method-decl method)
               <span class="comment">;; (not (mem '*abstract* (method-accessflags method)))
</span>               <span class="comment">;; Mon Oct 18 10:34:47 2004. It appears that valid-method-ptr
</span>               <span class="comment">;; already asserted that not abstract!! 
</span>               (not (mem '*abstract* (method-accessflags method)))
               (or (mem '*native* (method-accessflags method))
                   (and (wff-code (method-code method))
                        (integerp (method-maxlocals method))
                        (integerp (method-maxstack method))
                        (&lt;= (len (operand-stack frame))
                            (method-maxstack method)))))))


<span class="comment">;; seems to cause an infinite loop! 
</span>
(<span class="keyword">defun</span> <span class="function-name">consistent-call-stack</span> (callstack cl hp)
  (<span class="keyword">declare</span> (xargs <span class="builtin">:guard</span> (and (consistent-class-hierachy cl)
                              (wff-heap-strong hp))))
  <span class="comment">;; tmp implementation 
</span>  <span class="comment">;;
</span>  <span class="comment">;; should assert that each method pointer point to valid place, saved-pc
</span>  <span class="comment">;; within bound? values on op stack and locals and sync obj are valid.
</span>  <span class="comment">;; 
</span>  <span class="comment">;; sync object is pointing to a valid object.
</span>  <span class="comment">;;
</span>  <span class="comment">;; What else? 
</span>  <span class="comment">;;
</span>  <span class="comment">;; Should I assert the last frame must be a frame of particular form
</span>  <span class="comment">;;
</span>  <span class="comment">;; At least one frame? Let me leave this thing out in a different assertion 
</span>  <span class="comment">;; I will not try assert that return addresses are right in this consistent-call-stack
</span>
  (<span class="keyword">if</span> (not (consp callstack)) t
    (and (consistent-frame (car callstack) cl hp)
         (consistent-call-stack (cdr callstack) cl hp))))

<span class="comment">;;(i-am-here)
</span>
(<span class="keyword">defun</span> <span class="function-name">wff-invocation-frame</span> (frame cl)
  (<span class="keyword">declare</span> (xargs <span class="builtin">:guard</span> (wff-instance-class-table cl)))
  (mylet* ((method (deref-method (method-ptr frame) cl)))
  (and (wff-call-frame frame)
       (wff-method-ptr (method-ptr frame))
       (valid-method-ptr (method-ptr frame) cl)
       (wff-method-decl method)
       (OR (MEM '*NATIVE*
                (METHOD-ACCESSFLAGS METHOD))
           (AND (WFF-CODE (METHOD-CODE METHOD))
                (INTEGERP (METHOD-MAXLOCALS METHOD))
                (INTEGERP (METHOD-MAXSTACK METHOD))
                (&lt;= (LEN (OPERAND-STACK FRAME))
                    (method-maxstack method)))))))


(<span class="keyword">defun</span> <span class="function-name">consistent-adjacent-frame-guard</span> (caller callee cl)
  (and (wff-instance-class-table cl)
       (wff-invocation-frame caller cl)
       (wff-invocation-frame callee cl)
       (not (mem '*native* 
                 (method-accessflags 
                  (deref-method (method-ptr caller) cl))))))

                                    
(<span class="keyword">defun</span> <span class="function-name">valid-offset-into</span> (pc instrs)
  (<span class="keyword">if</span> (not (consp instrs)) nil
    (and (wff-inst (car instrs))
         (or (equal (inst-offset (car instrs)) pc)
             (valid-offset-into pc (cdr instrs))))))
  
                  

(<span class="keyword">defun</span> <span class="function-name">consistent-adjacent-frame</span> (caller callee cl)
  (<span class="keyword">declare</span> (xargs <span class="builtin">:guard</span> (consistent-adjacent-frame-guard caller callee cl)))
  (and (equal (return-pc callee)
              (resume-pc caller))
       <span class="comment">;; awkward of fact of
</span>       <span class="comment">;; introducing now symbols. 
</span>       (valid-offset-into (return-pc callee) 
                          (method-code (deref-method (method-ptr caller) cl)))
       (&lt;= (+ (len (operand-stack caller))
              (type-size (method-ptr-returntype (method-ptr callee))))
           (method-maxstack (deref-method (method-ptr caller) cl)))))
                                          
                                          

(<span class="keyword">defun</span> <span class="function-name">consistent-call-stack-linkage</span> (callstack cl)
  (<span class="keyword">declare</span> (xargs <span class="builtin">:guard</span> (wff-instance-class-table cl)))
  (<span class="keyword">if</span> (not (consp callstack)) t
    (<span class="keyword">if</span> (not (consp (pop callstack)))
        <span class="comment">;;; the first frame of a thread. 
</span>        (and (wff-invocation-frame (top callstack) cl)
             (equal (return-pc (top callstack)) 'KILL_THREAD)) 
      <span class="comment">;; may need fix
</span>      <span class="comment">;; later!! 
</span>      <span class="comment">;; not very necessary to asser this. 
</span>      (<span class="keyword">let*</span> ((caller (top (pop callstack)))
             (callee (top callstack)))
        (and (wff-invocation-frame caller cl)
             (wff-invocation-frame callee cl)
             (or (mem '*native* 
                      (method-accessflags (deref-method (method-ptr caller)
                                                        cl)))
                 (consistent-adjacent-frame caller callee cl))
             (consistent-call-stack-linkage (pop callstack) cl))))))





<span class="comment">;; (defun make-thread (id pc call-stack s m-ref mdepth thread-ref)
;;   (list 'thread id 
;;      (cons 'saved-pc pc)
;;      (cons 'call-stack call-stack)
;;      (cons 'status s)         ;; 
;;      (cons 'monitor  m-ref)
;;      (cons 'mdepth   mdepth)
;;      (cons 'thread-obj thread-ref)))
</span>
<span class="comment">;; (defun make-thread (id pc call-stack s m-ref mdepth thread-ref)
;;   (list 'thread id 
;;      (cons 'saved-pc pc)
;;      (cons 'call-stack call-stack)
;;      (cons 'status s)         ;; 
;;      (cons 'monitor  m-ref)
;;      (cons 'mdepth   mdepth)
;;      (cons 'thread-obj thread-ref)))
</span>
<span class="comment">;; status is a list of 
;; flags 
;; thread_just_born thread_active thread_suspended thread_dead
;; thread_monitor_wait thread_convar_wait 
</span>

<span class="comment">;; (defun wff-thread (thread) 
;;   (and (true-listp thread)
;;        (equal (len thread) 8)
;;        (consp (nth 2 thread))
;;        (consp (nth 3 thread))
;;        (consp (nth 4 thread))
;;        (consp (nth 5 thread))
;;        (consp (nth 6 thread))
;;        (consp (nth 7 thread))))
</span>

<span class="comment">;; (defun thread-id (thread)
;;   (declare (xargs :guard (wff-thread thread)))
;;   (nth 1 thread))
</span>  

<span class="comment">;; (defun thread-saved-pc    (thread) 
;;   (declare (xargs :guard (wff-thread thread)))
;;   (cdr (nth 2 thread)))
</span>
<span class="comment">;; (defun thread-call-stack  (thread) 
;;   (declare (xargs :guard (wff-thread thread)))
;;   (cdr (nth 3 thread)))
</span>
<span class="comment">;; (defun thread-state       (thread) 
;;   (declare (xargs :guard (wff-thread thread)))
;;   (cdr (nth 4 thread))) ;; thread-state is a list
</span>
<span class="comment">;; (defun thread-mref       (thread)
;;   (declare (xargs :guard (wff-thread thread)))
;;   (cdr (nth 5 thread)))
</span>
<span class="comment">;; (defun thread-mdepth     (thread) 
;;   (declare (xargs :guard (wff-thread thread)))
;;   (cdr (nth 6 thread)))
</span>
<span class="comment">;; (defun thread-ref         (thread) 
;;   (declare (xargs :guard (wff-thread thread)))
;;   (cdr (nth 7 thread)))
</span>
<span class="comment">;;; tmp implementation !! Wed Jan 14 14:23:28 2004
</span>

(<span class="keyword">defun</span> <span class="function-name">classImplementInterface</span> (rtype interface cl)
  (<span class="keyword">declare</span> (ignore rtype interface cl))
  t)  <span class="comment">;; temp implementation!! 
</span>
<span class="comment">#|
(defthm valid-refp-is-implied-by-bounded-in-wff-heap-strong
  (implies (and (wff-heap-strong hp)
                (bound? x hp))
           (valid-refp (tag-ref x) hp)))
|#</span>

(in-theory (disable wff-obj))

(defthm wff-heap-strong-bound-wff-obj
  (implies (and (wff-heap-strong hp)
                (assoc-equal x hp))
           (wff-obj-strong (cdr (assoc-equal x hp))))
  <span class="builtin">:hints</span> ((<span class="string">"Goal"</span> <span class="builtin">:in-theory</span> (disable wff-heap wff-obj-strong))))

(in-theory (disable wff-obj-strong consistent-class-hierachy wff-heap))

(defthm wff-heap-strong-implies-alistp
  (implies (wff-heap-strong hp)
           (alistp hp))
  <span class="builtin">:hints</span> ((<span class="string">"Goal"</span> <span class="builtin">:in-theory</span> (enable wff-heap))))



(<span class="keyword">defun</span> <span class="function-name">consistent-thread-entry</span> (th cl hp)
  (<span class="keyword">declare</span> (xargs <span class="builtin">:guard</span>  (and (consistent-class-hierachy cl)
                               (wff-heap-strong hp))))
  (and (wff-thread th) <span class="comment">;;  10/10/03 
</span>       (Valid-REFp (tag-REF (thread-ref th)) hp)
       <span class="comment">;; make sure that thread-ref is bounded. 
</span>       <span class="comment">;; Not recording the type.  09/14/03 
</span>       <span class="comment">;; 
</span>       (consp (thread-call-stack th)) <span class="comment">;; at list one frame
</span>       (consistent-call-stack (thread-call-stack th) cl hp)
       <span class="comment">;; we could add the next check to see that obj is really a thread or
</span>       <span class="comment">;; some class that implement the java.lang.Runnable interface We need
</span>       <span class="comment">;; this property to prove native method currentThread always return a
</span>       <span class="comment">;; thread obj. We can add this spec on the currentThread instead of
</span>       <span class="comment">;; here. 
</span>       <span class="comment">;; 
</span>       <span class="comment">;; That's add the check at native method, let the defensive
</span>       <span class="comment">;; machine detect that and set the "FATAL error".
</span>       <span class="comment">;; 
</span>       <span class="comment">;; However we can prove M6's native implementation maintain the
</span>       <span class="comment">;; consistent state. 
</span>       <span class="comment">;; 
</span>       (consistent-call-stack-linkage (thread-call-stack th) cl)
       <span class="comment">;; A bunch of invariant!! 
</span>       (<span class="keyword">let*</span> ((obj (deref2 (tag-REF (thread-ref th)) hp))
              (rtype (obj-type obj)))
         (or (assignmentCompatible rtype <span class="string">"java.lang.Thread"</span> cl)
             (classImplementInterface rtype <span class="string">"java.lang.Runnable"</span> cl)))
       (or (equal (thread-mref th) -1)
           <span class="comment">;; (NULLp (thread-mref th))
</span>           (bound? (thread-mref th) hp))))
           <span class="comment">;;(Valid-REFp (thread-mref th) hp))))
;;
;; In consistent-value, we need also to check no value is of a "interface type"
;; or an "abstract" type. (UPDATE to consistent-value needed!! NEED FIX. 
;; fix in CONSISTENT HEAP?? what could be the problem if we allow such a instance
;; exists in our consistent-state? can some bad thing happen?
;;
</span>
(<span class="keyword">defun</span> <span class="function-name">consistent-thread-entries</span> (ths cl hp)
  (<span class="keyword">declare</span> (xargs <span class="builtin">:guard</span>  (and (consistent-class-hierachy cl)
                               (wff-heap-strong hp))))
  <span class="comment">;; This does not specific the correct locking state
</span>  <span class="comment">;; if some thread locks on non-existing object? 
</span>  <span class="comment">;; what would happen? We only need the object exists
</span>  <span class="comment">;; and we don't check whether thread hold the lock at the same time 
</span>  <span class="comment">;; nor we check that monitor queues are compatibles with thread state
</span>  <span class="comment">;;
</span>  <span class="comment">;; Locking exceptions could happen, because the underlying machine has the
</span>  <span class="comment">;; problem. We want to prove that JVM would fail gracefully, by first
</span>  <span class="comment">;; checking for something. How important is modeling a particular monitor
</span>  <span class="comment">;; implementation?? If we want to study the fairness execution and some
</span>  <span class="comment">;; program's correctness depends on that, we may have to model it then.
</span>  <span class="comment">;;
</span>  <span class="comment">;; However, without a monitor implementation, we could not reason about
</span>  <span class="comment">;; locking count, notify, wait etc. 
</span>  <span class="comment">;;
</span>  <span class="comment">;; In principle we can prove that certain error won't happen because of the 
</span>  <span class="comment">;; native implementation. is THIS true?? We have no control about how user use
</span>  <span class="comment">;; monitors. 
</span>  <span class="comment">;;
</span>  <span class="comment">;; Anyway, we don't restrict this aspect (monitor init state) in a "valid" state.
</span>  <span class="comment">;; Because those inconsistency can be handled correct in JVM with exception
</span>  <span class="comment">;; etc. AGREED  08/15/03 
</span>  <span class="comment">;;
</span>  <span class="comment">;; Defensive machine will check every dereference in fact bounded. 
</span>  <span class="comment">;; We can show this property as corrollory of it preserve the consistency. 
</span>  <span class="comment">;; every pointer in the system is valid. 
</span>  <span class="comment">;;
</span>  (<span class="keyword">if</span> (not (consp ths)) t
    (and (consistent-thread-entry (car ths) cl hp)
         (consistent-thread-entries (cdr ths) cl hp))))


(<span class="keyword">defun</span> <span class="function-name">consistent-thread-table</span> (ths cl hp)
  (<span class="keyword">declare</span> (xargs <span class="builtin">:guard</span>  (and (consistent-class-hierachy cl)
                               (wff-heap-strong hp))))
  (consistent-thread-entries ths cl hp))

<span class="comment">;----------------------------------------------------------------------
</span>
<span class="comment">;; (defun wff-aux (aux)
;;   (and (true-listp aux)
;;        (&gt; (len aux) 1)))
</span>

<span class="comment">;; (defun wff-aux (aux)
;;   (declare (ignore aux))
;;   t)
</span>

<span class="comment">;; (defun heap-init-map (aux)
;;   (declare (xargs :guard (wff-aux aux)))
;;   (acl2::g 'heap-init-map aux))
</span>

<span class="comment">;;; moved to jvm-loader.lisp ;; Fri Oct 29 17:54:15 2004
</span>

(<span class="keyword">defun</span> <span class="function-name">wff-heap-init-map</span> (heap-init-map)
  (alistp heap-init-map))


<span class="comment">;; the format of tag is 
;;
;;  nil
;; or 
;;
;; (offset . a-method-ptr)
;;
;; we do not assert that method-exists our deref-method is checking for it
;; explicitly (however in real jvm, certain checking is avoided by caching and
;; shortening the pointers) 
;; 
</span>
(<span class="keyword">defun</span> <span class="function-name">wff-obj-init-tag</span> (tag)
  (or (equal tag nil)
      (and (consp tag)
           (equal (integerp (car tag))
                  (wff-method-ptr (cdr tag))))))



(<span class="keyword">defun</span> <span class="function-name">wff-heap-init-map-strong</span> (heap-init-map)
  (<span class="keyword">if</span> (not (consp heap-init-map))
      (equal heap-init-map nil)
    (and (consp (car heap-init-map))
         (wff-obj-init-tag (cdar heap-init-map))
         (wff-heap-init-map-strong (cdr heap-init-map)))))



(<span class="keyword">defun</span> <span class="function-name">consistent-heap-init-obj-with-heap-obj</span> (obj obj-init)
  (<span class="keyword">declare</span> (ignore obj obj-init))
  <span class="comment">;; temp implementation 
</span> t)



(<span class="keyword">defun</span> <span class="function-name">consistent-heap-with-heap-init-map</span> (hp hp-init)
  (<span class="keyword">declare</span> (xargs <span class="builtin">:guard</span> (and (wff-heap-strong hp)
                              (wff-heap-init-map-strong hp-init))))
  (<span class="keyword">if</span> (not (consp hp)) (not (consp  hp-init))
    (<span class="keyword">if</span> (not (consp  hp-init)) nil
      (and (consistent-heap-init-obj-with-heap-obj (car hp) (car hp-init))
           <span class="comment">;; when we assert heap consistent with obj tagging that records
</span>           <span class="comment">;; initialization status 
</span>           (consp (car hp))
           (consp (car hp-init))
           (equal (caar hp) (caar hp-init))
           (consistent-heap-with-heap-init-map (cdr hp) (cdr hp-init))))))

<span class="comment">;; these two is not used?? Thu Dec  4 16:15:57 2003
;; No. this is used in the opstack-sig's guard. 
;; 
;; The problem is I probably don't want to verify the guards for those
;; frame-sig functions!!
</span>





<span class="comment">;; (defun instance-class-table (S)
;;   (declare (xargs :guard (and (wff-state s)
;;                               (wff-class-table (class-table s)))))
;;   (cdr (nth 1 (class-table s))))
</span>

<span class="comment">;; (defun array-class-table (s)
;;   (declare (xargs :guard (and (wff-state s)
;;                               (wff-class-table (class-table s)))))
;;   (cdr (nth 2 (class-table s))))
</span>


<span class="comment">; (defun make-env (scl) ;; temp version
;    (list 'env 
;         (cons 'external-class-table
;               scl)))
</span>

<span class="comment">;; (defun env (s)   
;;   (declare (xargs :guard (wff-state s)))
;;   (nth 6 s)) ;; only loader read from env
</span>

<span class="comment">; (defun make-env (scl) ;; temp version
;    (list 'env 
;         (cons 'external-class-table
;               scl)))
</span>
<span class="comment">;; (defun wff-env (env)
;;   (and (true-listp env)
;;        (equal (len env) 2)
;;        (consp (nth 1 env))))
</span>

<span class="comment">;; (defun env-class-table (env)
;;   (declare (xargs :guard (wff-env env)))
;;   (cdr (nth 1 env)))
</span>
<span class="comment">;; (defun external-class-table (s)
;;    (declare (xargs :guard (and (wff-state s)
;;                                (wff-env (env s)))))
;;    (env-class-table (env s)))
</span>

<span class="comment">; (defthm consistent-thread-table-implies-alistp
;   (implies (consistent-thread-table ths cl hp)
;            (alistp ths))
;   :rule-classes :forward-chaining)
</span>

<span class="comment">;; ; ** from jvm-thread.lisp **
;; (defun wff-thread-table (thread-table)
;;   (if (not (consp thread-table)) t
;;     (and (wff-thread (car thread-table))
;;          (wff-thread-table (cdr thread-table)))))
</span>

<span class="comment">;; (defun thread-by-id (id thread-table)
;;   (declare (xargs :guard (wff-thread-table thread-table)))
;;   (if (not (consp thread-table))
;;       nil
;;     (if (equal (thread-id (car thread-table)) id)
;;         (car thread-table)
;;       (thread-by-id id (cdr thread-table)))))
</span>
<span class="comment">;; (defun thread-exists (id tt)
;;   (declare (xargs :guard (wff-thread-table tt)))
;;   (thread-by-id id tt))
</span>
(in-theory (enable wff-thread-table))
(defthm consistent-thread-table-implies-wff-thread-table
  (implies (consistent-thread-entries ths cl hp)
           (wff-thread-table ths))
  <span class="builtin">:rule-classes</span> <span class="builtin">:forward-chaining</span>)


<span class="comment">;; (defun valid-array-type (arraytype cl acl)
;;   (declare (ignore arraytype cl acl))
;;   t) ;; TEMP implementation Thu Dec  4 16:12:54 2003
</span>

<span class="comment">;; (defun valid-array-type (arraytype cl acl)
;;   ;; Sat Oct 30 00:25:04 2004
;;   (declare (xargs :guard (and (wff-instance-class-table cl)
;;                               (wff-array-class-table acl))))
;;   (and (array-type-s arraytype cl)
;;        (let ((basetype (array-component-type arraytype)))
;;          (and (ArrayClassLoaded1? basetype acl)
;;               (if (isArrayType basetype)
;;                   (valid-array-type basetype cl acl)
;;                 (isClassTerm (class-by-name basetype cl)))))))
</span>
       


(in-theory (disable valid-array-type))
<span class="comment">;;; Wed Jan 14 14:39:22 2004
;;; Lots of things to do. 
</span>
<span class="comment">;; We need to assert array object is always initialized!!
;; Sun Oct 31 14:45:33 2004
</span>

(<span class="keyword">defun</span> <span class="function-name">consistent-heap-array-init-state1</span> (hp cl acl hp-init)
  (<span class="keyword">declare</span> (xargs <span class="builtin">:guard</span> (and (wff-heap-strong hp)
                              (wff-array-class-table acl)
                              (wff-instance-class-table cl)
                              (alistp hp-init))))
  (<span class="keyword">if</span> (not (consp hp)) t
    (and (or (not (isArrayType (obj-type (cdar hp)))) 
             <span class="comment">;; either it is not array type object
</span>             (and (valid-array-type (obj-type (cdar hp)) cl acl)
                  <span class="comment">;; we need this to assert if array-type, the component type are
</span>                  <span class="comment">;; valid. 
</span>                  (not (assoc-equal (caar hp) hp-init))))
                  <span class="comment">;; Mon Feb 23 18:14:19 2004. This and is added later!!
</span>                  <span class="comment">;; During proof!!
</span>         <span class="comment">;; we need to remember to update hp-init when we create a new array
</span>         <span class="comment">;; object 
</span>         (consistent-heap-array-init-state1 (cdr hp) cl acl hp-init))))

(<span class="keyword">defun</span> <span class="function-name">consistent-heap-array-init-state2</span> (hp hp-init)
  (<span class="keyword">declare</span> (xargs <span class="builtin">:guard</span> (and (alistp hp)
                              (alistp hp-init))))
  (<span class="keyword">if</span> (not (consp hp-init)) t
      (and (assoc-equal (caar hp-init) hp)
           (consistent-heap-array-init-state2 hp (cdr hp-init)))))



<span class="comment">;; &gt;V            (DEFUN
;;                ARRAY-OBJ-CONSISTENT1
;;                (DATA-ARRAY COMPONENT-TYPE HP CL)
;;                (DECLARE (XARGS :GUARD
;;                                (AND (TRUE-LISTP DATA-ARRAY)
;;                                     (WFF-HEAP-STRONG HP)
;;                                     (CONSISTENT-CLASS-HIERACHY CL))))
;;                (IF
;;                  (ENDP DATA-ARRAY)
;;                  T
;;                  (AND (CONSISTENT-VALUE (TAG (CAR DATA-ARRAY) COMPONENT-TYPE)
;;                                         COMPONENT-TYPE CL HP)
;;                       (ARRAY-OBJ-CONSISTENT1 (CDR DATA-ARRAY)
;;                                              COMPONENT-TYPE HP CL))))
;;(i-am-here)
</span>
(<span class="keyword">defun</span> <span class="function-name">array-content-initialized</span> (data-array hp-init)
  (<span class="keyword">declare</span> (xargs <span class="builtin">:guard</span> (and (true-listp data-array)
                              (alistp hp-init))))
  (<span class="keyword">if</span> (endp data-array) t
    (and (or (equal (car data-array) -1)
             (or  (not (bound? (car data-array) hp-init)) 
                  <span class="comment">;; Mon Jun  6 17:35:23 2005
</span>                  <span class="comment">;; either not bound, if it were bound,
</span>                  <span class="comment">;; then it is not consp ..
</span>                  (not (consp (binding (car data-array) hp-init)))))
         (array-content-initialized (cdr data-array) hp-init))))


<span class="comment">;; Mon May  2 12:35:41 2005 new addition to assert that 
;; all object refered by some element in the array correctly 
;; initialized. 
</span>
(<span class="keyword">defun</span> <span class="function-name">consistent-heap-array-init-state3</span> (hp hp-init)
  (<span class="keyword">declare</span> (xargs <span class="builtin">:guard</span> (and (wff-heap-strong hp)
                              (alistp hp-init))))
  (<span class="keyword">if</span> (not (consp hp)) t
    (and (or (not (isArrayType (obj-type (cdar hp))))
             (and (WFF-INTERNAL-ARRAY (cdar hp)) <span class="comment">;; get pass the guard!! 
</span>                  (or (primitive-type? (array-component-type (obj-type (cdar hp))))
                      (array-content-initialized (array-data (cdar hp)) hp-init))))
         (consistent-heap-array-init-state3 (cdr hp) hp-init))))



(<span class="keyword">defun</span> <span class="function-name">consistent-heap-array-init-state</span> (hp cl acl hp-init)
  (<span class="keyword">declare</span> (xargs <span class="builtin">:guard</span> (and (wff-heap-strong hp)
                              (wff-array-class-table acl)
                              (wff-instance-class-table cl)
                              (alistp hp-init))))
  (and (wff-heap-init-map-strong hp-init)
       (consistent-heap-array-init-state2 hp hp-init)
       (consistent-heap-array-init-state1 hp cl acl hp-init)
       (consistent-heap-array-init-state3 hp hp-init)))



<span class="comment">;;----------------------------------------------------------------------
;;
;; Mon Jul 18 17:49:12 2005
;;
;; Need to assert that consistent-object all the reference-type fields 
;; are properly initialized (or NULL pointer!)
;;
;; Before an object is propertly initialized, reference to it can be stored in
;; an array nor an object!! 
;;
;; BCV make sure that verified code maintains this property.
;;
;;
;; similiar to consistent-heap-array-init-state3 !!
;;
</span>
<span class="comment">;; (i-am-here) ;; Mon Jul 18 18:01:20 2005
</span>
<span class="comment">;;   (and (wff-immediate-instance immediate-instance)
;;        (equal obj-type (car immediate-instance))  
;;        ;; this is not right
;;        (class-exists? obj-type cl)
;;        ;; does not handle array object well. 
;;        (let ((fields (cdr immediate-instance))
;;              (field-decls (fields (class-by-name obj-type cl))))
;;          (and (alistp fields) ;; Thu Jun  9 13:30:08 2005.
;;               ;; added because GETFIELD. 
;;               (consistent-fields fields field-decls cl hp)))))
</span>

(<span class="keyword">defun</span> <span class="function-name">consistent-field-init-state</span> (field field-decl hp-init)
  (<span class="keyword">declare</span> (xargs <span class="builtin">:guard</span> (alistp hp-init)))
  (and (wff-data-field field)
       (wff-field-decl field-decl)
       (equal (fieldname field)
              (field-fieldname field-decl))
       (or (primitive-type? (field-fieldtype field-decl))
           <span class="comment">;; reference type!! 
</span>           (or (equal (fieldvalue field) -1) <span class="comment">;; NULLp
</span>               (not (bound? (fieldvalue field) hp-init))))))


(<span class="keyword">defun</span> <span class="function-name">consistent-fields-init-state</span> (fields field-decls hp-init)
  (<span class="keyword">declare</span> (xargs <span class="builtin">:guard</span> (alistp hp-init)))
  (<span class="keyword">if</span> (not (consp fields)) (not (consp field-decls))
    (<span class="keyword">if</span> (not (consp field-decls)) nil
      (and (consistent-field-init-state (car fields) (car field-decls)
                                        hp-init)
           (consistent-fields-init-state (cdr fields) (cdr field-decls)
                                         hp-init)))))



(<span class="keyword">defun</span> <span class="function-name">consistent-immedidate-instance-init-state</span> (instance cl hp-init)
  (<span class="keyword">declare</span> (xargs <span class="builtin">:guard</span> (and (alistp hp-init)
                              (wff-instance-class-table cl))))
  (and (wff-immediate-instance instance)
       (class-exists? (car instance) cl)
       (<span class="keyword">let</span> ((fields (cdr instance))
             (field-decls (fields (class-by-name (car instance) cl))))
         (consistent-fields-init-state fields field-decls hp-init))))
                     


(<span class="keyword">defun</span> <span class="function-name">consistent-jvp-init-state</span> (jvp cl hp-init)
  (<span class="keyword">declare</span> (xargs <span class="builtin">:guard</span> (and (alistp hp-init)
                              (wff-instance-class-table cl))))
  (<span class="keyword">if</span> (not (consp jvp)) t
    (and (consistent-immedidate-instance-init-state
          (car jvp) cl hp-init)
         (consistent-jvp-init-state (cdr jvp) cl hp-init))))
                                    

(<span class="keyword">defun</span> <span class="function-name">consistent-object-init-state</span> (obj cl hp-init)
  (<span class="keyword">declare</span> (xargs <span class="builtin">:guard</span> (and (alistp hp-init)
                              (wff-instance-class-table cl)
                              (wff-obj-strong obj))))
  (<span class="keyword">if</span> (isArrayType (obj-type obj))
      t <span class="comment">;; if array, it will be checked in 
</span>        <span class="comment">;; consistent-heap-array-init-state3 !!! 
</span>    (consistent-jvp-init-state (java-visible-portion obj) cl hp-init)))

(defthm wff-obj-strong-implies-wff-obj
  (implies (wff-obj-strong obj)
           (wff-obj obj))
  <span class="builtin">:rule-classes</span> <span class="builtin">:forward-chaining</span>)

(<span class="keyword">defun</span> <span class="function-name">consistent-heap-init-state</span> (hp cl hp-init)
  (<span class="keyword">declare</span> (xargs <span class="builtin">:guard</span> (and (alistp hp-init)
                              (wff-instance-class-table cl)
                              (wff-heap-strong hp))))
  (<span class="keyword">if</span> (not (consp hp)) t
    (and (consistent-object-init-state (cdar hp) cl hp-init)
         (consistent-heap-init-state (cdr hp) cl hp-init))))

      













































<span class="comment">;;
;;
;;
;;
;;----------------------------------------------------------------------
</span>



















<span class="comment">;; (defun consistent-heap-array-init-state (hp cl acl hp-init)
;;   (declare (xargs :guard (wff-heap-strong hp)))
;;   (if (not (consp hp)) t
;;     (and (or (not (isArrayType (obj-type (cdar hp)))) 
;;              ;; either it is not array type object
;;              (valid-array-type (obj-type (cdar hp)) cl acl)
;;                   ;; we need this to assert if array-type, the component type are
;;                   ;; valid. 
;;              (not (binding (caar hp) hp-init)))
;;                   ;; Mon Feb 23 18:14:19 2004. This and is added later!!
;;                   ;; During proof!!
;;          ;; we need to remember to update hp-init when we create a new array
;;          ;; object 
;;          (consistent-heap-array-init-state (cdr hp) cl acl hp-init))))
</span>
<span class="comment">;;; Sun May 16 20:57:43 2004. In order to prove 
</span>

<span class="comment">;; (skip-proofs 
;;  (defthm consistent-state-implies-max-stack-guard-true
;;    (implies (<a href="consistent-state.lisp.html">consistent-state</a> s)
;;             (max-stack-guard s))
;;    :rule-classes :forward-chaining))
</span>

<span class="comment">;; (skip-proofs 
;;  (defthm consistent-state-implies-max-stack-integerp
;;    (implies (<a href="consistent-state.lisp.html">consistent-state</a> s)
;;             (integerp (max-stack s)))
;;    :rule-classes :forward-chaining))
</span>
<span class="comment">;; in consistent-state-properties.lisp
</span>
<span class="comment">;; ;;
;; ;; We need to add a new assertion to say that all method code are well formed!! 
;; ;;
</span>
(<span class="keyword">defun</span> <span class="function-name">wff-method-codes</span> (methods)
  (<span class="keyword">if</span> (not (consp methods)) t
    (and (wff-method-decl (car methods))
         (wff-code (method-code (car methods)))
         (integerp (method-maxlocals (car methods)))
         (integerp (method-maxstack  (car methods)))
         (wff-method-codes (cdr methods)))))


(<span class="keyword">defun</span> <span class="function-name">wff-methods-instance-class-rep</span> (class-decl)
  (and (wff-class-rep class-decl)
       (wff-method-codes (methods class-decl))))


(<span class="keyword">defun</span> <span class="function-name">wff-methods-instance-class-table-strong</span> (classes)
  (<span class="keyword">if</span> (not (consp classes)) t
    (and (wff-methods-instance-class-rep (car classes))
         (wff-methods-instance-class-table-strong (cdr classes)))))


<span class="comment">;;; Sun May 16 21:07:10 2004. Note. class constructed by static class table may
;;; not be <a href="consistent-state.lisp.html">consistent-state</a> using above definition. For example: Native
;;; methods!!. Need to fix class loader to normalize the method
;;; representation!! or fix jvm2acl2!! Fix jvm2acl2, to always generated
;;; correctly formed methods. so that class loader just copying will be good
;;; enough! 
</span>
(<span class="keyword">defun</span> <span class="function-name">array-class-table-inv</span> (s)
  (jvm::load_array_class_guard s))

<span class="comment">;; Sun Aug  8 15:33:38 2004. At any point, we can load an array class
;; Basically it assert that all array-base types are loaded. 
;;
</span>
(<span class="keyword">defun</span> <span class="function-name">instance-class-table-inv</span> (s)
  (jvm::load_class-guard s))


<span class="comment">;(i-am-here) ;; Sun Oct 17 15:43:51 2004
</span>
<span class="comment">;;; Tue Oct 19 17:38:45 2004. need to assert some basic properties of
;;; loaded classes
</span>
<span class="comment">;;(i-am-here) ;; Thu Jun 16 19:57:02 2005
</span>(<span class="keyword">defun</span> <span class="function-name">boot-strap-class-okp</span> (s)
  (<span class="keyword">declare</span> (xargs <span class="builtin">:guard</span> (and (wff-state s)
                              (wff-class-table (class-table s))
                              (wff-heap-strong (heap s))
                              (wff-env (env s))
                              (wff-static-class-table-strong
                               (external-class-table s))
                              (wff-instance-class-table-strong
                               (instance-class-table s))
                              (CONSISTENT-CLASS-HIERACHY (INSTANCE-CLASS-TABLE S))
                              (wff-array-class-table (array-class-table s)))))
  (and (class-loaded? <span class="string">"java.lang.Object"</span> s)
       (class-loaded? <span class="string">"java.lang.Class"</span> s)
       (class-loaded? <span class="string">"java.lang.String"</span> s)
<span class="comment">;;        (null (super 
;;               (class-by-name "java.lang.Object" 
;;                              (instance-class-table s))))
</span>       (equal (super 
               (class-by-name <span class="string">"java.lang.Object"</span> 
                              (instance-class-table s))) <span class="string">""</span>)
       (equal (fields (class-by-name <span class="string">"java.lang.Object"</span>  (instance-class-table s))) nil)
       (JVM::correctly-loaded? <span class="string">"java.lang.Object"</span> (instance-class-table s)
                               (external-class-table s))
       (JVM::correctly-loaded? <span class="string">"java.lang.Class"</span> (instance-class-table s)
                               (external-class-table s))
       (JVM::correctly-loaded? <span class="string">"java.lang.String"</span> (instance-class-table s)
                               (external-class-table s))
       (build-a-java-visible-instance-guard <span class="string">"java.lang.Object"</span> s)
       (build-a-java-visible-instance-guard <span class="string">"java.lang.Class"</span> s)
       (build-a-java-visible-instance-guard <span class="string">"java.lang.String"</span> s)
       (CONSISTENT-JVP <span class="string">"java.lang.Object"</span>
                       '((<span class="string">"java.lang.Object"</span>))
                       (INSTANCE-CLASS-TABLE S)
                       (HEAP S)) <span class="comment">;; 
</span>       <span class="comment">;; Thu Jun 16 19:53:48 2005 new addition!! 
</span>
       <span class="comment">;; Sun Oct 31 19:44:54 2004. in order to prove load_cp_entry preserves
</span>       <span class="comment">;; the <a href="consistent-state.lisp.html">consistent-state</a> we need to add assertions to say that (array
</span>       <span class="comment">;; char) is already defined!
</span>       <span class="comment">;; 
</span>       <span class="comment">;; (not (class-by-name "" (instance-class-table s))) 
</span>       <span class="comment">;; Wed Jun 22 22:04:49 2005 
</span>       <span class="comment">;; no need to assert this just yet!! 
</span>       <span class="comment">;; this may break a few proofs!! 
</span>       (array-class-exists? '(array char) (array-class-table s))
       (mv-let (found rep)
               (class-by-name-s <span class="string">""</span> (external-class-table s))
               (<span class="keyword">declare</span> (ignore rep))
               (not found))))

<span class="comment">;;; Tue Oct 19 17:46:23 2004
;;;
;;; overly strong/explicit. build-a-java-visible-instance-guard is probably
;;; provable from loader-inv + boot-strap-class-okp
;;;
</span>       

(defthm consistent-heap-implies-wff-heap-strong
  (implies (consistent-heap hp cl acl)
           (wff-heap-strong hp))
  <span class="builtin">:hints</span> ((<span class="string">"Goal"</span> <span class="builtin">:in-theory</span> (enable consistent-heap)))
  <span class="builtin">:rule-classes</span> <span class="builtin">:forward-chaining</span>)


<span class="comment">;----------------------------------------------------------------------
</span>
<span class="comment">;; Wed May  4 22:14:38 2005
;; 
;; Redefined here to 
</span>
(include-book <span class="string"><a href="../BCV/bcv-functions-basic.lisp.html">"../BCV/bcv-functions-basic"</a></span>)
(include-book <span class="string"><a href="../BCV/bcv-functions-basic-verify-guard.lisp.html">"../BCV/bcv-functions-basic-verify-guard"</a></span>)

<span class="comment">;; (defun collect-thread-id (tt)
;;   (declare (xargs :guard (wff-thread-table tt)))
;;   (if (consp tt)
;;       (cons (thread-id (car tt)) 
;;             (collect-thread-id (cdr tt)))
;;     nil))
</span>
<span class="comment">;; (defun unique-thread-id (tt)
;;   (unique (collect-thread-id tt)))
</span>
<span class="comment">;;Tue Dec 23 14:45:43 2003
</span>(<span class="keyword">defun</span> <span class="function-name"><a href="consistent-state.lisp.html">consistent-state</a></span> (s) 
  <span class="comment">;; this s is a tagged state 
</span>  <span class="comment">;; the purpose is that <a href="consistent-state.lisp.html">consistent-state</a> is strong enough
</span>  <span class="comment">;; safe machine will guarantee to from a <a href="consistent-state.lisp.html">consistent-state</a> to a next
</span>  <span class="comment">;; <a href="consistent-state.lisp.html">consistent-state</a>
</span>  <span class="comment">;;
</span>  <span class="comment">;; We will prove that bytecode verified program also provide such guarantee. 
</span>  <span class="comment">;; so the definition of this state is essential
</span>  (and (wff-state s) <span class="comment">;; syntatically correct
</span>       (wff-env (env s))
       (wff-aux (aux s)) <span class="comment">;; Tue Dec 23 14:47:51 2003 aux structurally correct.
</span>       (alistp (heap-init-map (aux s))) <span class="comment">;; Mon Feb 23 18:40:46 2004. 
</span>       (WFF-HEAP-INIT-MAP-STRONG (HEAP-INIT-MAP (AUX S)))
       <span class="comment">;; (wff-heap-init-map-strong (heap-init-map (aux s))) ;; Wed Mar 17 00:23:17 2004
</span>       (wff-class-table (class-table s))
       (wff-instance-class-table-strong (instance-class-table s))
       (wff-array-class-table (array-class-table s))
       (wff-static-class-table-strong (external-class-table s))
       (wff-methods-instance-class-table-strong (instance-class-table s))
       <span class="comment">;; Mon May 17 11:57:08 2004. Added to show max-stack-guard is true. 
</span>       <span class="comment">;;
</span>       <span class="comment">;; Sun Apr 30 19:34:17 2006. these above assertion is problematic
</span>       <span class="comment">;; because it incorrectly assume none of the methods are native,
</span>       <span class="comment">;; abstract!
</span>       <span class="comment">;; 
</span>       <span class="comment">;; (wff-thread-table (thread-table s))
</span>       (consistent-class-hierachy (instance-class-table s))
       <span class="comment">;; Have to assert this
</span>       <span class="comment">;; So that consistent-value's guard could be met
</span>       (consistent-heap (heap s) 
                        (instance-class-table s) 
                        (array-class-table s))

       <span class="comment">;; Tue Jul 19 11:17:21 2005 ;; Tue Jul 19 11:17:28 2005
</span>       (consistent-heap-init-state (heap s)
                                   (instance-class-table s)
                                   (heap-init-map (aux s))) 
       <span class="comment">;; Tue Jul 19 11:17:49 2005 
</span>       <span class="comment">;;
</span>       <span class="comment">;; ADDED for <a href="INST/GETFIELD.lisp.html">GETFIELD</a> TO ASSUME GETTING FROM 
</span>       <span class="comment">;; 
</span>       
       <span class="comment">;; the following is new addition Thu Dec  4 16:19:49 2003
</span>       (consistent-heap-array-init-state (heap s)
                                         (instance-class-table s)
                                         (array-class-table s)
                                         (heap-init-map (aux s)))
       <span class="comment">;; Haven't Need to rerun <a href="consistent-state.lisp.html">consistent-state</a> preserving proof
</span>       <span class="comment">;; check in for now. Thu Dec  4 16:25:28 2003
</span>       <span class="comment">;;
</span>       <span class="comment">;; We need to add assertions to say methods are well formed!!
</span>       <span class="comment">;; Mon Mar 29 21:38:05 2004. 
</span>       <span class="comment">;; 
</span>       (consistent-class-table (instance-class-table s) 
                                (external-class-table s) (heap s))
        <span class="comment">;;
</span>        <span class="comment">;; ASSERT consistent-class-hierachy
</span>        <span class="comment">;;        the relation between CL and SCL
</span>        <span class="comment">;;        the values contained in CL are of right type.
</span>        <span class="comment">;;
</span>        <span class="comment">;; Mon Mar 29 21:14:10 2004. 
</span>        <span class="comment">;; 
</span>        <span class="comment">;; To deal max stack. We need to assert that each call frame contains
</span>        <span class="comment">;; valid method-pointer method-pointer points to valid
</span>        <span class="comment">;; methods.. (valid-method-ptr . added a while ago) 
</span>        <span class="comment">;;
</span>       (consistent-thread-table (thread-table s) 
                                 (instance-class-table s)
                                 (heap s))
        <span class="comment">;; ASSERT call-stack contains propertly typed value.
</span>        <span class="comment">;;(consp (thread-table s))
</span>        <span class="comment">;; (bound? (current-thread s) (thread-table s))
</span>       <span class="comment">;;(wff-thread-table (thread-table s))
</span>       (unique-id-thread-table (thread-table s))
       (thread-exists? (current-thread s) (thread-table s))
       <span class="comment">;; something about pc, status flag?? 
</span>       (instance-class-table-inv s)
       (array-class-table-inv s)
       (boot-strap-class-okp s)

       <span class="comment">;;; Sun Oct 17 15:43:57 2004 added. after 
</span>       <span class="comment">;;; a proof that <a href="consistent-state.lisp.html">consistent-state</a> implies max-stack-guard!! 
</span>       <span class="comment">;;;
</span>       
       <span class="comment">;;  (not (MEM '*ABSTRACT* (METHOD-ACCESSFLAGS 
</span>       <span class="comment">;;                        (deref-method (method-ptr (current-frame s))
</span>       <span class="comment">;;                                      (instance-class-table s)))))
</span>
       <span class="comment">;;; We need to assert that this is true on every call stack
</span>       <span class="comment">;;;
</span>       <span class="comment">;;; actual method in execution!! 
</span>       <span class="comment">;;; 
</span>       <span class="comment">;;;
</span>
       <span class="comment">;;(class-loaded? "java.lang.Object" s)
</span>       <span class="comment">;;(class-loaded? "java.lang.Class" s)
</span>       <span class="comment">;;(jvm::loader-inv s) ;; Sun Aug  8 14:57:37 2004
</span>       <span class="comment">;;(jvm::load_array_class_guard s)
</span>       <span class="comment">;; we need now to reason about changing something else does not modify
</span>       <span class="comment">;; loader-inv!! 
</span>
       
       (equal (bcv::scl-bcv2jvm (bcv::scl-jvm2bcv (external-class-table s)))
              (external-class-table s))
       <span class="comment">;;; Wed May  4 22:18:47 2005
</span>       (bcv::good-scl (bcv::scl-jvm2bcv (external-class-table s)))
       <span class="comment">;; Fri Jul 15 18:16:20 2005
</span>       <span class="comment">;; in order to do proofs in base-consistent-state-good-icl-etc.lisp
</span>       <span class="comment">;;
</span>       <span class="comment">;;; The problematic!! Guard verification!! I didn't verify guards
</span>       <span class="comment">;;; of <a href="../common/primitives.lisp.html">primitives</a> of BCV!!. 
</span>       <span class="comment">;;; chain of requirements!! 
</span>       ))

<span class="comment">;----------------------------------------------------------------------
;
;
; used for base-object-field-always-initialized.lisp
;
; Wed Jul 20 23:24:27 2005
;
</span>
(acl2::set-verify-guards-eagerness 0)

(<span class="keyword">defun</span> <span class="function-name">get-field-type1</span> (fieldname fields) 
  (<span class="keyword">if</span> (not (consp fields)) nil
    (<span class="keyword">if</span> (equal (field-fieldname (car fields))
               fieldname)
        (field-fieldtype (car fields))
      (get-field-type1 fieldname (cdr fields)))))


(<span class="keyword">defun</span> <span class="function-name">get-field-type</span> (classname fieldname cl)
  (mylet* ((class-rep (class-by-name classname cl))
           (fields    (fields class-rep)))
          (get-field-type1 fieldname fields)))

<span class="comment">;----------------------------------------------------------------------
</span></pre>
  </body>
</html>
