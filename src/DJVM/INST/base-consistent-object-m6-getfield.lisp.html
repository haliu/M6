<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01//EN">
<!-- Created by htmlize-1.16 in css mode. -->
<html>
  <head>
    <title>base-consistent-object-m6-getfield.lisp</title>
    <style type="text/css">
    <!--
      body {
        color: #f5deb3;
        background-color: #000000;
      }
      .builtin {
        /* font-lock-builtin-face */
        color: #b0c4de;
      }
      .comment {
        /* font-lock-comment-face */
        color: #ff7f24;
      }
      .function-name {
        /* font-lock-function-name-face */
        color: #87cefa;
      }
      .keyword {
        /* font-lock-keyword-face */
        color: #00ffff;
      }
      .string {
        /* font-lock-string-face */
        color: #ffa07a;
      }
      a {
        color: inherit;
        background-color: inherit;
        font: inherit;
        text-decoration: inherit;
      }
      a:hover {
        text-decoration: underline;
      }
    -->
    </style>
  </head>
  <body>
    <pre>
(<span class="keyword">in-package</span> <span class="string">"DJVM"</span>)
(include-book <span class="string"><a href="../consistent-state.lisp.html">"../../DJVM/consistent-state"</a></span>)
(include-book <span class="string"><a href="../consistent-state-properties.lisp.html">"../../DJVM/consistent-state-properties"</a></span>)
(include-book <span class="string"><a href="../../M6-DJVM-shared/jvm-object-type-hierachy.lisp.html">"../../M6-DJVM-shared/jvm-object-type-hierachy"</a></span>)

(local (in-theory (disable consistent-value)))

(defthm consistent-jvp-if-bound-then-consistent-fields
  (implies (and (consistent-jvp type jvp cl hp)
                (bound? classname jvp))
           (consistent-fields (binding classname jvp)
                              (fields (class-by-name classname cl))
                              cl hp))
  <span class="builtin">:hints</span> ((<span class="string">"Goal"</span> <span class="builtin">:in-theory</span> (e/d (binding bound?)
                                  (fields))
           <span class="builtin">:do-not</span> '(generalize))))

<span class="comment">;;; skip one step so ACL2 will do more work proving the above theorem. two
;;; inductions.
</span>

(acl2::set-verify-guards-eagerness 0)
(<span class="keyword">defun</span> <span class="function-name">field-decl-with-name</span> (name fields-decls)
  (<span class="keyword">if</span> (not (consp fields-decls))
      nil
    (<span class="keyword">if</span> (equal (field-fieldname (car fields-decls)) name)
        (car fields-decls)
      (field-decl-with-name name (cdr fields-decls)))))
(acl2::set-verify-guards-eagerness 2)


(defthm consistent-fields-if-bound-then-binding-consistent-value
  (implies (and (consistent-fields fields fields-decls cl hp)
                (bound? fieldname fields))
           (consistent-value (tag (binding fieldname fields)
                                  (field-fieldtype 
                                   (field-decl-with-name fieldname fields-decls)))
                             (field-fieldtype 
                              (field-decl-with-name fieldname fields-decls))
                             cl hp))
  <span class="builtin">:hints</span> ((<span class="string">"Goal"</span> <span class="builtin">:in-theory</span> (e/d (binding bound? field-fieldname 
                                           fieldname
                                           fieldvalue)
                                  (fields))
           <span class="builtin">:do-not</span> '(generalize))))


<span class="comment">;; (i-am-here) ;;
</span>
<span class="comment">;; now we just prove that bound? 
</span>
<span class="comment">;;(i-am-here) ;; Thu Jun 16 16:59:34 2005
</span>

(encapsulate () 
  (local (include-book <span class="string"><a href="base-consistent-state-lookupfield.lisp.html">"base-consistent-state-lookupfield"</a></span>))
  <span class="comment">;; if field found,  we know fieldname, fieldclass bound in the object!!!
</span>  (local 
   (defthm
     consistent-object-and-field-found-in-lookup-implies-jvm-field-access-guard
     (implies (and (<a href="../consistent-state.lisp.html">consistent-state</a> s)
                   (consistent-object obj (heap s) (instance-class-table s))
                   (car (isAssignableTo (obj-type obj) (fieldCP-classname fieldcp) s))
                   (lookupField (fieldcp-to-field-ptr fieldCP) s))
              (jvm::jvp-access-field-guard (field-classname 
                                            (lookupField (fieldcp-to-field-ptr
                                                          fieldCP) s))
                                           (FIELDCP-FIELDNAME fieldcp)
                                           (java-visible-portion obj)))))

  (local (in-theory (enable jvm::jvp-access-field-guard)))

  (defthm consistent-object-and-field-found-implies-class-name-bound-in-jvp
     (implies (and (<a href="../consistent-state.lisp.html">consistent-state</a> s)
                   (consistent-object obj (heap s) (instance-class-table s))
                   (car (isAssignableTo (obj-type obj) (fieldCP-classname fieldcp) s))
                   (lookupField (fieldcp-to-field-ptr fieldCP) s))
              (bound? (field-classname 
                       (lookupField (fieldcp-to-field-ptr
                                     fieldCP) s))
                      (java-visible-portion obj)))
     <span class="builtin">:hints</span> ((<span class="string">"Goal"</span> <span class="builtin">:in-theory</span> (disable bound? field-classname isAssignableTo
                                         fieldcp-to-field-ptr obj-type
                                         java-visible-portion
                                         consistent-object)
              <span class="builtin">:use</span>  consistent-object-and-field-found-in-lookup-implies-jvm-field-access-guard)))
                                           
    
  (defthm consistent-object-and-field-found-implies-field-name-bound-in-immediate-instance
     (implies (and (<a href="../consistent-state.lisp.html">consistent-state</a> s)
                   (consistent-object obj (heap s) (instance-class-table s))
                   (car (isAssignableTo (obj-type obj) (fieldCP-classname fieldcp) s))
                   (lookupField (fieldcp-to-field-ptr fieldCP) s))
              (bound? (fieldcp-fieldname fieldcp)
                      (binding (field-classname
                                (lookupField (fieldcp-to-field-ptr
                                              fieldCP) s))
                               (java-visible-portion obj))))
     <span class="builtin">:hints</span> ((<span class="string">"Goal"</span> <span class="builtin">:in-theory</span> (disable bound? field-classname isAssignableTo
                                         fieldcp-to-field-ptr
                                         binding
                                         CONSISTENT-OBJECT-AND-FIELD-FOUND-IN-LOOKUP-IMPLIES-JVM-FIELD-ACCESS-GUARD
                                         fieldcp-fieldname
                                         java-visible-portion
                                         consistent-object)
              <span class="builtin">:use</span>  consistent-object-and-field-found-in-lookup-implies-jvm-field-access-guard))))


(defthm consistent-value-implies-consistent-value-x-b-specific
  (implies (consistent-value (tag v type) type cl hp)
           (consistent-value-x (tag v type) cl hp))
  <span class="builtin">:hints</span> ((<span class="string">"Goal"</span> <span class="builtin">:use</span> ((<span class="builtin">:instance</span> CONSISTENT-VALUE-IMPLIES-CONSISTENT-VALUE-X
                                   (v (tag v type)))))))



(defthm consistent-fields-if-bound-then-binding-consistent-value-general
  (implies (and (consistent-fields fields fields-decls cl hp)
                (equal (field-decl-with-name fieldname fields-decls)
                       field-decl)
                (bound? fieldname fields))
           (consistent-value (tag (binding fieldname fields)
                                  (field-fieldtype field-decl))
                             (field-fieldtype field-decl)
                             cl hp))
  <span class="builtin">:hints</span> ((<span class="string">"Goal"</span> <span class="builtin">:in-theory</span> (e/d ()
                                  (fields
                                   field-decl-with-name
                                   primitive-type?
                                   tag
                                   consistent-value
                                   field-fieldtype
                                   consistent-fields
                                   binding bound? field-fieldname 
                                   fieldname
                                   fieldvalue)))))




(defthm consistent-fields-if-bound-then-binding-consistent-value-general-specific
  (implies (and (consistent-fields (binding name jvp)
                                   (fields (class-by-name name cl)) cl hp)
                (equal (field-decl-with-name 
                        fieldname 
                        (fields (class-by-name name cl)))
                       field-decl)
                (bound? fieldname (binding name jvp)))
           (consistent-value (tag (binding fieldname (binding name jvp))
                                  (field-fieldtype field-decl))
                             (field-fieldtype field-decl)
                             cl hp))
  <span class="builtin">:hints</span> ((<span class="string">"Goal"</span> <span class="builtin">:in-theory</span> (e/d ()
                                  (fields
                                   field-decl-with-name
                                   primitive-type?
                                   consistent-value
                                   field-fieldtype
                                   consistent-fields
                                   binding bound? field-fieldname 
                                   fieldname
                                   tag
                                   class-by-name
                                   fieldvalue)))))


(defthm consistent-jvp-if-bound-then-consistent-fields-specific
  (implies (and (consistent-jvp (obj-type obj) (java-visible-portion obj) cl hp)
                (bound? classname (java-visible-portion obj)))
           (consistent-fields (binding classname (java-visible-portion obj))
                              (fields (class-by-name classname cl))
                              cl hp))
  <span class="builtin">:hints</span> ((<span class="string">"Goal"</span> <span class="builtin">:in-theory</span> (e/d ()  (consistent-fields 
                                       binding java-visible-portion
                                       fields)))))



(defthm consistent-object-implies-consistent-jvp
  (implies (and (consistent-object obj hp cl)
                (not (isArrayType (obj-type obj))))
           (CONSISTENT-JVP (OBJ-TYPE obj)
                           (JAVA-VISIBLE-PORTION obj)
                           cl hp)))



<span class="comment">;; (include-book <a href="base-consistent-state.lisp.html">"base-consistent-state"</a>)
;;
;;
;; Don't really want to depend on 
;;                   base-consistent-state.lisp
;;
;; but maybe we should 
;; 
;; <a href="base-consistent-state.lisp.html">base-consistent-state</a> is no longer clean. 
;; 
;;
</span>
(local 
 (defthm binding-rREF-normalize
   (equal (binding (rREF v) hp)
          (deref2 v hp))
   <span class="builtin">:hints</span> ((<span class="string">"Goal"</span> <span class="builtin">:in-theory</span> (enable deref2)))))


(defthm consistent-heap1-implies-if-bound-then-consistent-object
  (implies (and (consistent-heap1 hp1 hp cl id)
                (bound? v hp1))
           (consistent-object (binding v hp1) hp cl))
  <span class="builtin">:hints</span> ((<span class="string">"Goal"</span> <span class="builtin">:in-theory</span> (e/d () (consistent-object)))))
  

(defthm consistent-state-consistent-heap1
  (implies (<a href="../consistent-state.lisp.html">consistent-state</a> s)
           (consistent-heap1 (heap s) 
                             (heap s)
                             (instance-class-table s)
                             0))
  <span class="builtin">:hints</span> ((<span class="string">"Goal"</span> <span class="builtin">:in-theory</span> (enable <a href="../consistent-state.lisp.html">consistent-state</a> 
                                     consistent-heap)))
  <span class="builtin">:rule-classes</span> <span class="builtin">:forward-chaining</span>)


(defthm consistent-state-REFp-not-NULLp-implies-consistent-object
  (implies (and (<a href="../consistent-state.lisp.html">consistent-state</a> s)
                (REFp v (heap s))
                (not (NULLp v)))
           (consistent-object (deref2 v (heap s))
                              (heap s)
                              (instance-class-table s)))
  <span class="builtin">:hints</span> ((<span class="string">"Goal"</span> <span class="builtin">:in-theory</span> (e/d (deref2)
                                  (binding-rREF-normalize
                                   binding bound?
                                   consistent-object)))))

<span class="comment">;;; Mon Jun 13 14:56:51 2005
</span>


(defthm searchFields-implies-equal-field-classname-equal
  (implies (searchFields field-ptr fields)
           (equal (field-classname (searchFields field-ptr fields))
                  (field-ptr-classname field-ptr))))



(local 
  (defthm field-fieldname-search-fields
    (implies (searchfields field-ptr fields)
             (equal (field-fieldname (searchfields field-ptr fields))
                    (field-ptr-fieldname field-ptr)))))



(defthm field-fieldname-reduce
  (implies (LOOKUPFIELD field-ptr s)
           (equal (FIELD-FIELDNAME (LOOKUPFIELD field-ptr s))
                  (field-ptr-fieldname field-ptr)))
  <span class="builtin">:hints</span> ((<span class="string">"Goal"</span> <span class="builtin">:in-theory</span> (e/d (lookupfield) (LOOKUPFIELD-INV
                                                 searchfields 
                                                 fields
                                                 <a href="../consistent-state.lisp.html">consistent-state</a>
                                                 field-fieldname 
                                                 isClassTerm
                                                 superclass-no-loop))
           <span class="builtin">:do-not</span> '(generalize))))

<span class="comment">;;;
;;; we know fields from a consistent-class-decl is all from a same class So
;;; searchfields will return the same results as just looking for fieldnames!!
;;;
</span>

<span class="comment">;; (acl2::set-verify-guards-eagerness 0)
</span>
<span class="comment">;; (defun fields-all-from-class (field-decls classname)
;;   (if (endp field-decls) t
;;     (and (equal (field-fieldname (car field-decls)) classname)
;;          (fields-all-from-class (cdr field-decls)
;;                                 classname))))
;; (acl2::set-verify-guards-eagerness 2)
</span>
<span class="comment">;; (i-am-here) 
</span>(local (in-theory (disable JVM::WFF-FIELDS-X-EQUAL-WFF-CLASS-FIELDS)))

(defthm not-mem-not-searchfields
  (implies (not (mem (field-ptr-fieldname field-ptr)
                     (COLLECT-FIELD-NAMES FIELD-DECLS)))
           (not (searchfields field-ptr field-decls))))


(defthm field-decl-with-name-is-searchfield-if-fields-from-the-same-class
  (implies  (and (SEARCHFIELDS FIELD-PTR  FIELD-decls)
                 (nodup-set (collect-field-names field-decls)))
            (EQUAL (FIELD-DECL-WITH-NAME  (FIELD-PTR-FIELDNAME FIELD-PTR)
                                          field-decls)
                   (SEARCHFIELDS FIELD-PTR  field-decls)))
  <span class="builtin">:hints</span> ((<span class="string">"Goal"</span> 
           <span class="builtin">:in-theory</span> (disable field-fieldname)
           <span class="builtin">:do-not</span> '(generalize))))


<span class="comment">;;; need to assert that when name is equal, type is equal!!! 
;;; otherwise searchfields will not return the same result as
;;; field-decl-with-name returns!! 
;;;
;;; However our object representation depends on this!!  need to add the
;;; assertion into the wff-static-class-rep!!
;;;
;;; good way is to assert that there is no duplicate in name. 
;;;
;;; Mon Jun 13 15:39:16 2005
</span>



(defthm field-decl-with-name-equal-lookupfield-lemma
  (implies (and (lookupfield field-ptr s)
                (nodup-set (collect-field-names 
                            (fields (class-by-name 
                                     (field-classname (lookupfield field-ptr s))
                                     (instance-class-table s))))))
           (EQUAL
            (FIELD-DECL-WITH-NAME
             (field-ptr-fieldname field-ptr)
             (FIELDS (CLASS-BY-NAME
                      (FIELD-CLASSNAME (LOOKUPFIELD field-ptr s))
                      (INSTANCE-CLASS-TABLE S))))
            (LOOKUPFIELD field-ptr s)))
  <span class="builtin">:hints</span> ((<span class="string">"Goal"</span> <span class="builtin">:in-theory</span> (e/d ()(LOOKUPFIELD-INV
                                     searchfields 
                                     fields
                                     field-classname
                                     <a href="../consistent-state.lisp.html">consistent-state</a>
                                     field-fieldname 
                                     isClassTerm
                                     superclass-no-loop))
           <span class="builtin">:do-not</span> '(generalize))))
                                  


(defthm class-loaded-from-wff-static-class-rep
  (implies (and (class-is-loaded-from-helper class-rep
                                             class-rep-static)
                (WFF-CLASS-REP-STATIC-STRONG  class-rep-static))
           (nodup-set (collect-field-names (fields class-rep))))
  <span class="builtin">:hints</span> ((<span class="string">"Goal"</span> <span class="builtin">:in-theory</span> (e/d ()  (nodup-set fields fields-s
                                                 NODUP-SET-FIELDS-S-NODUP-SET-FIELDS
                                                 RUNTIME-INSTANCE-FIELDS-REP))
           <span class="builtin">:use</span> ((<span class="builtin">:instance</span> nodup-set-fields-s-nodup-set-fields
                            (fields-s (fields-s class-rep-static))
                            (classname (classname class-rep)))))))




(local 
 (defthm if-exists-then-loaded-from-some-class-file
   (implies (and (class-by-name name cl) 
                 (class-table-is-loaded-from cl scl))
            (class-is-loaded-from-helper 
             (class-by-name name cl)
             (mv-nth 1 (class-by-name-s name scl))))))

<span class="comment">;;; used force!! 
</span>
(local 
 (defthm consistent-state-implies-wff-static-class-table-strong
   (implies (<a href="../consistent-state.lisp.html">consistent-state</a> s)
            (wff-static-class-table-strong (env-class-table (env s))))
   <span class="builtin">:hints</span> ((<span class="string">"Goal"</span> <span class="builtin">:in-theory</span> (enable <a href="../consistent-state.lisp.html">consistent-state</a>)))))




(local 
 (defthm consistent-state-implies-class-table-is-loaded-from
   (implies (<a href="../consistent-state.lisp.html">consistent-state</a> s)
            (class-table-is-loaded-from (instance-class-table s)
                                        (env-class-table (env s))))
   <span class="builtin">:hints</span> ((<span class="string">"Goal"</span> <span class="builtin">:in-theory</span> (enable <a href="../consistent-state.lisp.html">consistent-state</a>)))))


           
(defthm searchfields-implies-class-by-name-classname-found
  (implies (not (class-by-name name cl))
           (not (searchfields field-ptr (fields (class-by-name name cl))))))


(defthm lookupfield-implies-class-by-name-classname-found
  (implies (lookupfield field-ptr s)
           (class-by-name (field-classname (lookupfield field-ptr s))
                          (instance-class-table s)))
  <span class="builtin">:hints</span> ((<span class="string">"Goal"</span> <span class="builtin">:in-theory</span> (disable field-classname)
           <span class="builtin">:do-not</span> '(generalize))))



<span class="comment">;; (local 
;;  (defthm if-exists-then-loaded-from-some-class-file
;;    (implies (and (class-by-name name cl) 
;;                  (class-table-is-loaded-from cl scl))
;;             (class-is-loaded-from-helper 
;;              (class-by-name name cl)
;;              (mv-nth 1 (class-by-name-s name scl))))))
</span>

<span class="comment">;;; put it together!! 
</span>

(local 
 (defthm
   wff-static-class-table-strong-implies-exists-implies-wff-static-class-rep-strong
   (implies (and (wff-static-class-table-strong scl)
                 (car (class-by-name-s name scl)))
            (wff-class-rep-static-strong (mv-nth 1 (class-by-name-s name
                                                                    scl))))
   <span class="builtin">:hints</span> ((<span class="string">"Goal"</span> <span class="builtin">:in-theory</span> (e/d () (wff-class-rep-static-strong))))))

(local 
 (defthm if-class-loaded-from-implies-car-class-by-name-s
   (implies (and (class-is-loaded-from-helper class-rep
                                              (mv-nth 1 (class-by-name-s name
                                                                         scl)))
                 (stringp (classname class-rep)))
            (car (class-by-name-s name scl)))
   <span class="builtin">:hints</span> ((<span class="string">"Goal"</span> <span class="builtin">:in-theory</span> (enable isInterface)))))




(local 
 (defthm if-class-loaded-from-implies-car-class-by-name-s-specific
   (implies (and (class-is-loaded-from-helper (class-by-name name
                                                             (instance-class-table s))
                                              (mv-nth 1 (class-by-name-s name
                                                                         (env-class-table (env s)))))
                 (stringp (classname (class-by-name name (instance-class-table s)))))
            (car (class-by-name-s name (env-class-table (env s)))))
   <span class="builtin">:hints</span> ((<span class="string">"Goal"</span> <span class="builtin">:in-theory</span> (e/d () (class-by-name-s class-is-loaded-from-helper))))))



(encapsulate () 
  (local (include-book <span class="string"><a href="base-consistent-state-class-names-are-string.lisp.html">"base-consistent-state-class-names-are-string"</a></span>))
  (defthm consistent-state-class-name-is-stringp
    (implies (and (class-by-name name (instance-class-table s))
                  (<a href="../consistent-state.lisp.html">consistent-state</a> s))
             (stringp name))
    <span class="builtin">:rule-classes</span> <span class="builtin">:forward-chaining</span>))


(defthm classname-class-by-name-is-name
  (implies (isClassTerm (class-by-name name cl))
           (equal (classname (class-by-name name cl))
                  name)))

(local 
 (defthm wff-instance-class-table-implies-isClassTerm-equiv
   (implies (wff-instance-class-table cl)
            (iff (isClassTerm (class-by-name name cl))
                 (class-by-name name cl)))
   <span class="builtin">:hints</span> ((<span class="string">"Goal"</span> <span class="builtin">:in-theory</span> (e/d (wff-class-rep isClassTerm) ())))))


(defthm field-decl-with-name-equal-lookupfield
  (implies (and (lookupfield field-ptr s)
                (<a href="../consistent-state.lisp.html">consistent-state</a> s))
           (EQUAL
            (FIELD-DECL-WITH-NAME
             (field-ptr-fieldname field-ptr)
             (FIELDS (CLASS-BY-NAME
                      (FIELD-CLASSNAME (LOOKUPFIELD field-ptr s))
                      (INSTANCE-CLASS-TABLE S))))
            (LOOKUPFIELD field-ptr s)))
  <span class="builtin">:hints</span> ((<span class="string">"Goal"</span> <span class="builtin">:in-theory</span> (e/d ()(LOOKUPFIELD-INV
                                     searchfields 
                                     fields
                                     field-classname
                                     <a href="../consistent-state.lisp.html">consistent-state</a>
                                     WFF-CLASS-REP-STATIC-STRONG
                                     field-fieldname 
                                     lookupfield
                                     class-is-loaded-from-helper
                                     isClassTerm
                                     superclass-no-loop))
           <span class="builtin">:do-not</span> '(generalize)
           <span class="builtin">:use</span> ((<span class="builtin">:instance</span> class-loaded-from-wff-static-class-rep
                            (class-rep (class-by-name 
                                        (field-classname 
                                         (lookupfield field-ptr s))
                                        (instance-class-table s)))
                            (class-rep-static 
                             (mv-nth 1 (class-by-name-s 
                                        (field-classname 
                                         (lookupfield field-ptr s))
                                        (env-class-table (env s))))))
                 (<span class="builtin">:instance</span> consistent-state-class-name-is-stringp
                            (name (field-classname (lookupfield field-ptr s))))))))


(defthm field-ptr-fieldname-fieldcp-to-field-ptr
  (equal (field-ptr-fieldname (fieldcp-to-field-ptr fieldcp))
         (fieldcp-fieldname fieldcp))
  <span class="builtin">:hints</span> ((<span class="string">"Goal"</span> <span class="builtin">:in-theory</span> (enable field-ptr-fieldname
                                     make-field-ptr
                                     fieldcp-to-field-ptr))))

                                        

(defthm field-decl-with-name-equal-lookupfield-specific
  (implies (and (lookupfield (fieldcp-to-field-ptr fieldcp) s)
                (<a href="../consistent-state.lisp.html">consistent-state</a> s))
           (EQUAL
            (FIELD-DECL-WITH-NAME
             (fieldcp-fieldname fieldcp)
             (FIELDS (CLASS-BY-NAME
                      (FIELD-CLASSNAME (LOOKUPFIELD (fieldcp-to-field-ptr fieldcp) s))
                      (INSTANCE-CLASS-TABLE S))))
            (LOOKUPFIELD (fieldcp-to-field-ptr fieldcp) s)))
  <span class="builtin">:hints</span> ((<span class="string">"Goal"</span> <span class="builtin">:in-theory</span> (e/d ()(LOOKUPFIELD-INV
                                     searchfields 
                                     fields
                                     field-classname
                                     <a href="../consistent-state.lisp.html">consistent-state</a>
                                     fieldcp-fieldname
                                     WFF-CLASS-REP-STATIC-STRONG
                                     field-fieldname 
                                     fieldcp-to-field-ptr
                                     lookupfield
                                     class-is-loaded-from-helper
                                     isClassTerm
                                     superclass-no-loop))
           <span class="builtin">:do-not</span> '(generalize)
           <span class="builtin">:use</span> ((<span class="builtin">:instance</span> field-decl-with-name-equal-lookupfield
                            (field-ptr (fieldcp-to-field-ptr fieldcp)))))))





(defthm consistent-object-consistent-state-m6-getfield-consistent-value-x-lemma
  (implies (and (<a href="../consistent-state.lisp.html">consistent-state</a> s)
                (car (isAssignableTo (obj-type (deref2 v (heap s)))
                                     (fieldcp-classname fieldCP)
                                     s))
                (not (isArrayType (obj-type (deref2 v (heap s)))))
                (REFp v (heap s))
                (lookupField (fieldcp-to-field-ptr fieldCP) s)
                (not (NULLp v)))
           (CONSISTENT-VALUE-X
            (TAG (M6-GETFIELD
                  (FIELD-CLASSNAME (LOOKUPFIELD (FIELDCP-TO-FIELD-PTR fieldcp)
                                                S))
                  (fieldcp-fieldname fieldcp)
                  (RREF v)
                  S)
                 (FIELD-FIELDTYPE (LOOKUPFIELD (FIELDCP-TO-FIELD-PTR fieldcp)
                                                S)))
            (INSTANCE-CLASS-TABLE S)
            (HEAP S)))
  <span class="builtin">:hints</span> ((<span class="string">"Goal"</span> <span class="builtin">:in-theory</span> (disable consistent-value-x
                                      consistent-value
                                      isAssignableTo
                                      REFp NULLp
                                      deref2
                                      rREF
                                      fields
                                      fieldcp-fieldname
                                      java-visible-portion
                                      fieldcp-to-field-ptr
                                      fieldcp-classname
                                      field-classname
                                      field-fieldname
                                      field-fieldtype
                                      tag binding bound?
                                      isArrayType obj-type
                                      lookupfield))))


<span class="comment">;;
;;
;; (defthm consistent-jvp-if-bound-then-consistent-fields
;;   (implies (and (consistent-jvp type jvp cl hp)
;;                 (bound? classname jvp))
;;            (consistent-fields (binding classname jvp)
;;                               (fields (class-by-name classname cl))
;;                               cl hp))
;;   :hints (("Goal" :in-theory (e/d (binding bound?)
;;                                   (fields))
</span>
<span class="comment">;;            :do-not '(generalize))))
</span>

(defthm consistent-jvp-if-bound-then-consistent-fields-more-specific
  (implies (and (consistent-jvp classname jvp cl hp)
                (bound? classname jvp))
           (consistent-fields (binding classname jvp)
                              (fields (class-by-name classname cl))
                              cl hp))
  <span class="builtin">:hints</span> ((<span class="string">"Goal"</span> <span class="builtin">:in-theory</span> (e/d (binding bound?)
                                  (fields))
           <span class="builtin">:do-not</span> '(generalize))))




<span class="comment">;; (defthm isArrayType-implies-consistent-array-object
;;   (implies (and (<a href="../consistent-state.lisp.html">consistent-state</a> s)
;;                 (not (NULLp v))
;;                 (REFp v (heap s))
;;                 (isArrayType (obj-type (deref2 v (heap s)))))
;;            (consistent-array-object (deref2 v (heap s))
;;                                     (heap s) (instance-class-table s)
;;                                     (array-class-table s)))
;;   :hints (("Goal" :in-theory (e/d (<a href="../consistent-state.lisp.html">consistent-state</a> consistent-heap consistent-heap)
;;                                   (consistent-array-object nullp)))))
</span>

(defthm consistent-heap2-implies-isArrayType-is-consistent-array-object
  (implies (and (consistent-heap2 hp1 hp cl acl id)
                (isArrayType (obj-type (binding v hp1))))
           (consistent-array-object (binding v hp1) hp cl acl))
  <span class="builtin">:hints</span> ((<span class="string">"Goal"</span> <span class="builtin">:in-theory</span> (disable consistent-array-object))))

(defthm isArrayType-implies-consistent-array-object-strong
  (implies (and (<a href="../consistent-state.lisp.html">consistent-state</a> s)
                (isArrayType (obj-type (deref2 v (heap s)))))
           (consistent-array-object (deref2 v (heap s))
                                    (heap s) (instance-class-table s)
                                    (array-class-table s)))
  <span class="builtin">:hints</span> ((<span class="string">"Goal"</span> <span class="builtin">:in-theory</span> (e/d (<a href="../consistent-state.lisp.html">consistent-state</a> 
                                   deref2 
                                   consistent-heap consistent-heap)
                                  (consistent-array-object
                                   binding-rREF-normalize
                                   obj-type
                                   binding
                                   nullp))
           <span class="builtin">:use</span> ((<span class="builtin">:instance</span>
                  consistent-heap2-implies-isArrayType-is-consistent-array-object
                  (hp1 (heap s)) 
                  (hp (heap s))
                  (cl (instance-class-table s))
                  (acl (array-class-table s))
                  (id 0))))))


<span class="comment">;;(i-am-here) ;; Fri Jul 15 01:47:01 2005
</span>
(defthm consistent-array-object-implies-consistent-jvp-java-lang-Object
  (implies (consistent-array-object obj hp cl acl)
           (consistent-jvp <span class="string">"java.lang.Object"</span> (java-visible-portion obj) cl
                           hp))
  <span class="builtin">:hints</span> ((<span class="string">"Goal"</span> <span class="builtin">:in-theory</span> (enable consistent-array-object))))

(local (in-theory (enable consistent-array-object)))

(defthm consistent-jvp-impies-bound
  (implies (consistent-jvp type jvp cl hp)
           (bound? type jvp)))



(defthm consistent-array-object-implies-consistent-jvp-java-lang-Object-specific
  (implies (consistent-array-object obj (heap s) (instance-class-table s)
                                    (array-class-table s))
           (consistent-jvp <span class="string">"java.lang.Object"</span> (java-visible-portion obj)
                           (instance-class-table s)
                           (heap s))))


(local (include-book <span class="string"><a href="base-bind-free.lisp.html">"base-bind-free"</a></span>))

(local 
 (defthm consistent-array-object-bound-java-lang-Object-specific
   (implies (and (bind-free (acl2::default-bind-free 's 's (acl2::pkg-witness <span class="string">"DJVM"</span>)))
                 (consistent-array-object obj (heap s) (instance-class-table s) 
                                          (array-class-table s)))
            (bound? <span class="string">"java.lang.Object"</span> (java-visible-portion obj)))
   <span class="builtin">:hints</span> ((<span class="string">"Goal"</span> <span class="builtin">:in-theory</span> (disable bound? consistent-jvp)))))


<span class="comment">;; (i-am-here) ;; 
</span>
(encapsulate () 
  (local (include-book <span class="string"><a href="base-consistent-state-lookupfield-support.lisp.html">"base-consistent-state-lookupfield-support"</a></span>))
  (defthm java-lang-Object-lookup-field-if-found-then-found-in-java-lang-Object
    (implies (and (<a href="../consistent-state.lisp.html">consistent-state</a> s)
                  (EQUAL (FIELDCP-CLASSNAME FIELDCP)
                         <span class="string">"java.lang.Object"</span>)
                  (lookupField (FIELDCP-TO-FIELD-PTR FIELDCP) s))
             (EQUAL (FIELD-CLASSNAME (lookupField (FIELDCP-TO-FIELD-PTR FIELDCP) s))
                    <span class="string">"java.lang.Object"</span>))
    <span class="builtin">:hints</span> ((<span class="string">"Goal"</span> <span class="builtin">:in-theory</span> (e/d () (<a href="../consistent-state.lisp.html">consistent-state</a>))))))


(defthm field-decl-with-name-equal-lookupfield-specific-general
  (implies (and (lookupfield (fieldcp-to-field-ptr fieldcp) s)
                (equal (FIELD-CLASSNAME (LOOKUPFIELD (fieldcp-to-field-ptr
                                                      fieldcp) s))
                       classname)
                (<a href="../consistent-state.lisp.html">consistent-state</a> s))
           (EQUAL
            (FIELD-DECL-WITH-NAME
             (fieldcp-fieldname fieldcp)
             (FIELDS (CLASS-BY-NAME
                      classname
                      (INSTANCE-CLASS-TABLE S))))
            (LOOKUPFIELD (fieldcp-to-field-ptr fieldcp) s)))
  <span class="builtin">:hints</span> ((<span class="string">"Goal"</span> <span class="builtin">:in-theory</span> (e/d ()(LOOKUPFIELD-INV
                                     searchfields 
                                     fields
                                     field-classname
                                     <a href="../consistent-state.lisp.html">consistent-state</a>
                                     fieldcp-fieldname
                                     WFF-CLASS-REP-STATIC-STRONG
                                     field-fieldname 
                                     fieldcp-to-field-ptr
                                     lookupfield
                                     class-is-loaded-from-helper
                                     isClassTerm
                                     superclass-no-loop))
           <span class="builtin">:do-not</span> '(generalize)
           <span class="builtin">:use</span> ((<span class="builtin">:instance</span> field-decl-with-name-equal-lookupfield
                            (field-ptr (fieldcp-to-field-ptr fieldcp)))))))


    
(defthm consistent-object-and-field-found-implies-field-name-bound-in-immediate-instance-general
   (implies (and (<a href="../consistent-state.lisp.html">consistent-state</a> s)
                 (consistent-object obj (heap s) (instance-class-table s))
                 (or (not (isArrayType (obj-type obj)))
                     (and (equal (fieldcp-classname fieldcp)
                                 <span class="string">"java.lang.Object"</span>)
                          (consistent-array-object obj (heap s)
                                                   (instance-class-table s)
                                                   (array-class-table s))))
                 (equal (field-classname
                         (lookupField (fieldcp-to-field-ptr
                                       fieldCP) s)) classname)
                 (car (isAssignableTo (obj-type obj) (fieldCP-classname fieldcp) s))
                 (lookupField (fieldcp-to-field-ptr fieldCP) s))
            (bound? (fieldcp-fieldname fieldcp)
                    (binding classname
                             (java-visible-portion obj))))
   <span class="builtin">:hints</span> ((<span class="string">"Goal"</span> <span class="builtin">:in-theory</span> (disable bound? field-classname isAssignableTo
                                       fieldcp-to-field-ptr
                                       binding
                                       fieldcp-fieldname
                                       java-visible-portion
                                       consistent-object)
            <span class="builtin">:use</span>  consistent-object-and-field-found-implies-field-name-bound-in-immediate-instance)))





(defthm consistent-object-consistent-state-m6-getfield-consistent-value-x-lemma-2
  (implies (and (<a href="../consistent-state.lisp.html">consistent-state</a> s)
                (car (isAssignableTo (obj-type (deref2 v (heap s)))
                                     (fieldcp-classname fieldCP)
                                     s))
                (isArrayType (obj-type (deref2 v (heap s))))
                (equal (fieldcp-classname fieldcp) <span class="string">"java.lang.Object"</span>)
                (REFp v (heap s))
                (lookupField (fieldcp-to-field-ptr fieldCP) s)
                (not (NULLp v)))
           (CONSISTENT-VALUE-X
            (TAG (M6-GETFIELD 
                  <span class="string">"java.lang.Object"</span>
                  (fieldcp-fieldname fieldcp)
                  (RREF v)
                  S)
                 (FIELD-FIELDTYPE (LOOKUPFIELD (FIELDCP-TO-FIELD-PTR fieldcp)
                                                S)))
            (INSTANCE-CLASS-TABLE S)
            (HEAP S)))
  <span class="builtin">:hints</span> ((<span class="string">"Goal"</span> <span class="builtin">:in-theory</span> (disable consistent-value-x
                                      consistent-value
                                      isAssignableTo
                                      REFp NULLp
                                      deref2
                                      rREF
                                      fields
                                      fieldcp-fieldname
                                      java-visible-portion
                                      fieldcp-to-field-ptr
                                      fieldcp-classname
                                      field-classname
                                      field-fieldname
                                      field-fieldtype
                                      tag binding bound?
                                      isArrayType obj-type
                                      lookupfield))))




(encapsulate () 
  (local (include-book <span class="string"><a href="base-lookupfield-fieldname-normalize.lisp.html">"base-lookupfield-fieldname-normalize"</a></span>))
  (defthm field-fieldtype-reduce
    (implies (LOOKUPFIELD field-ptr s)
             (equal (FIELD-FIELDTYPE (LOOKUPFIELD field-ptr s))
                    (field-ptr-type field-ptr)))
    <span class="builtin">:hints</span> ((<span class="string">"Goal"</span> <span class="builtin">:in-theory</span> (e/d (lookupfield) (LOOKUPFIELD-INV
                                                   searchfields 
                                                   fields
                                                   field-fieldtype
                                                   isClassTerm
                                                   superclass-no-loop))
             <span class="builtin">:do-not</span> '(generalize)))))

(defthm field-ptr-type-fieldcp-to-ptr
  (equal (field-ptr-type (fieldcp-to-field-ptr fieldcp))
         (fieldcp-fieldtype fieldcp))
  <span class="builtin">:hints</span> ((<span class="string">"Goal"</span> <span class="builtin">:in-theory</span> (enable fieldcp-to-field-ptr fieldcp-to-field-ptr
                                     make-field-ptr
                                     field-ptr-type))))


(defthm consistent-object-consistent-state-m6-getfield-consistent-value-x-weak
   (implies (and (<a href="../consistent-state.lisp.html">consistent-state</a> s)
                (car (isAssignableTo (obj-type (deref2 v (heap s)))
                                     (fieldcp-classname fieldCP)
                                     s))
                (or (not (isArrayType (obj-type (deref2 v (heap s)))))
                    (equal (fieldcp-classname fieldcp) <span class="string">"java.lang.Object"</span>))
                (REFp v (heap s))
                (equal (FIELD-CLASSNAME (LOOKUPFIELD (FIELDCP-TO-FIELD-PTR fieldcp)
                                                     S))
                       classname)
                (lookupField (fieldcp-to-field-ptr fieldCP) s)
                (not (NULLp v)))
           (CONSISTENT-VALUE-X
            (TAG (M6-GETFIELD classname
                  (fieldcp-fieldname fieldcp)
                  (RREF v)
                  S)
                 (fieldcp-fieldtype fieldcp))
            (INSTANCE-CLASS-TABLE S)
            (HEAP S)))
  <span class="builtin">:hints</span> ((<span class="string">"Goal"</span> <span class="builtin">:in-theory</span> (disable consistent-value-x
                                      consistent-value
                                      lookupfield
                                      isAssignableTo
                                      REFp NULLp
                                      deref2
                                      rREF
                                      fields
                                      fieldcp-fieldname
                                      java-visible-portion
                                      fieldcp-to-field-ptr
                                      fieldcp-classname
                                      field-classname
                                      field-fieldname
                                      field-fieldtype
                                      tag binding bound?
                                      isArrayType obj-type
                                      lookupfield)
          <span class="builtin">:use</span> ((<span class="builtin">:instance</span>
                 consistent-object-consistent-state-m6-getfield-consistent-value-x-lemma)
                (<span class="builtin">:instance</span>
                 consistent-object-consistent-state-m6-getfield-consistent-value-x-lemma-2)))))



<span class="comment">;----------------------------------------------------------------------
</span>
(encapsulate ()
 (local (include-book <span class="string"><a href="base-consistent-state-lookupfield-support.lisp.html">"base-consistent-state-lookupfield-support"</a></span>))
 (defthm consistent-state-lookupfield-fail-if-array-type-assignable-into
          (implies (and  (<a href="../consistent-state.lisp.html">consistent-state</a> s)
                 (isArrayType typ1) 
                 (car (isAssignableTo typ1 (fieldcp-classname fieldcp) s)))
           (not (lookupField (fieldcp-to-field-ptr fieldcp) s)))
  <span class="builtin">:hints</span> ((<span class="string">"Goal"</span> <span class="builtin">:in-theory</span> (e/d () (<a href="../consistent-state.lisp.html">consistent-state</a> 
                                      isClassTerm
                                      fieldcp-classname))))))




(defthm consistent-object-consistent-state-m6-getfield-consistent-value-x
   (implies (and (<a href="../consistent-state.lisp.html">consistent-state</a> s)
                (car (isAssignableTo (obj-type (deref2 v (heap s)))
                                     (fieldcp-classname fieldCP)
                                     s))
                (REFp v (heap s))
                (equal (FIELD-CLASSNAME (LOOKUPFIELD (FIELDCP-TO-FIELD-PTR fieldcp)
                                                     S))
                       classname)
                (lookupField (fieldcp-to-field-ptr fieldCP) s)
                (not (NULLp v)))
           (CONSISTENT-VALUE-X
            (TAG (M6-GETFIELD classname
                  (fieldcp-fieldname fieldcp)
                  (RREF v)
                  S)
                 (fieldcp-fieldtype fieldcp))
            (INSTANCE-CLASS-TABLE S)
            (HEAP S)))
  <span class="builtin">:hints</span> ((<span class="string">"Goal"</span> <span class="builtin">:in-theory</span> (disable consistent-value-x
                                      consistent-value
                                      lookupfield
                                      consistent-array-object
                                      isAssignableTo
                                      REFp NULLp
                                      deref2
                                      rREF
                                      fields
                                      fieldcp-fieldname
                                      java-visible-portion
                                      fieldcp-to-field-ptr
                                      fieldcp-classname
                                      field-classname
                                      field-fieldname
                                      field-fieldtype
                                      tag binding bound?
                                      isArrayType obj-type
                                      lookupfield)
           <span class="builtin">:cases</span> ((isArrayType (obj-type (deref2 v (heap s))))))
          (<span class="string">"Subgoal 2"</span> <span class="builtin">:use</span> consistent-object-consistent-state-m6-getfield-consistent-value-x-weak)))
           


<span class="comment">;----------------------------------------------------------------------
</span>
<span class="comment">; continue to prove some results here? Thu Jul 21 19:01:19 2005
;
; We really want to conclude that consistent-value, not only the
; consistent-value-x!! 
;
; needed in base-m6-getfield-consistent-value.lisp! 
</span>


<span class="comment">;; (defthm consistent-jvp-if-bound-then-consistent-fields-specific
;;   (implies (and (consistent-jvp (obj-type obj) (java-visible-portion obj) cl hp)
;;                 (bound? classname (java-visible-portion obj)))
;;            (consistent-fields (binding classname (java-visible-portion obj))
;;                               (fields (class-by-name classname cl))
;;                               cl hp))
;;   :hints (("Goal" :in-theory (e/d ()  (consistent-fields 
;;                                        binding java-visible-portion
;;                                        fields)))))
</span>


<span class="comment">;; (defthm consistent-object-implies-consistent-jvp
;;   (implies (and (consistent-object obj hp cl)
;;                 (not (isArrayType (obj-type obj))))
;;            (CONSISTENT-JVP (OBJ-TYPE obj)
;;                            (JAVA-VISIBLE-PORTION obj)
;;                            cl hp)))
</span>



<span class="comment">;; (defthm consistent-fields-if-bound-then-binding-consistent-value-general-specific
;;   (implies (and (consistent-fields (binding name jvp)
;;                                    (fields (class-by-name name cl)) cl hp)
;;                 (equal (field-decl-with-name 
;;                         fieldname 
;;                         (fields (class-by-name name cl)))
;;                        field-decl)
;;                 (bound? fieldname (binding name jvp)))
;;            (consistent-value (tag (binding fieldname (binding name jvp))
;;                                   (field-fieldtype field-decl))
;;                              (field-fieldtype field-decl)
;;                              cl hp))
;;   :hints (("Goal" :in-theory (e/d ()
;;                                   (fields
;;                                    field-decl-with-name
;;                                    primitive-type?
;;                                    consistent-value
;;                                    field-fieldtype
;;                                    consistent-fields
;;                                    binding bound? field-fieldname 
;;                                    fieldname
;;                                    tag
;;                                    class-by-name
;;                                    fieldvalue)))))
</span>
(local 
  (defthm consistent-object-bound-field-implies-consistent-value
    (implies (and (consistent-object obj hp cl)
                (not (isArrayType (obj-type obj)))
                (bound? classname (java-visible-portion obj))
                (bound? fieldname (binding classname
                                           (java-visible-portion obj)))
                (equal (field-decl-with-name
                        fieldname  
                        (fields
                         (class-by-name classname cl))) field-decl))
           (consistent-value (tag (binding fieldname (binding classname 
                                                              (java-visible-portion obj)))
                                  (field-fieldtype field-decl))
                             (field-fieldtype field-decl)
                             cl hp))
  <span class="builtin">:hints</span> ((<span class="string">"Goal"</span> <span class="builtin">:in-theory</span> (disable consistent-value 
                                      obj-type binding bound?
                                      field-fieldtype
                                      fields tag isArrayType
                                      java-visible-portion
                                      consistent-object)))))
                                                    


<span class="comment">;; (encapsulate () 
;;   (local (include-book <a href="base-lookupfield-fieldname-normalize.lisp.html">"base-lookupfield-fieldname-normalize"</a>))
;;   (defthm field-fieldtype-reduce
;;     (implies (LOOKUPFIELD field-ptr s)
;;              (equal (FIELD-FIELDTYPE (LOOKUPFIELD field-ptr s))
;;                     (field-ptr-type field-ptr)))
;;     :hints (("Goal" :in-theory (e/d (lookupfield) (LOOKUPFIELD-INV
;;                                                    searchfields 
;;                                                    fields
;;                                                    field-fieldtype
;;                                                    isClassTerm
;;                                                    superclass-no-loop))
;;              :do-not '(generalize)))))
</span>
<span class="comment">;; (defthm field-ptr-type-fieldcp-to-ptr
;;   (equal (field-ptr-type (fieldcp-to-field-ptr fieldcp))
;;          (fieldcp-fieldtype fieldcp))
;;   :hints (("Goal" :in-theory (enable fieldcp-to-field-ptr fieldcp-to-field-ptr
;;                                      make-field-ptr
;;                                      field-ptr-type))))
</span>
<span class="comment">;; (defthm field-decl-with-name-equal-lookupfield-specific-general
;;   (implies (and (lookupfield (fieldcp-to-field-ptr fieldcp) s)
;;                 (equal (FIELD-CLASSNAME (LOOKUPFIELD (fieldcp-to-field-ptr
;;                                                       fieldcp) s))
;;                        classname)
;;                 (<a href="../consistent-state.lisp.html">consistent-state</a> s))
;;            (EQUAL
;;             (FIELD-DECL-WITH-NAME
;;              (fieldcp-fieldname fieldcp)
;;              (FIELDS (CLASS-BY-NAME
;;                       classname
;;                       (INSTANCE-CLASS-TABLE S))))
;;             (LOOKUPFIELD (fieldcp-to-field-ptr fieldcp) s)))
;;   :hints (("Goal" :in-theory (e/d ()(LOOKUPFIELD-INV
;;                                      searchfields 
;;                                      fields
;;                                      field-classname
;;                                      <a href="../consistent-state.lisp.html">consistent-state</a>
;;                                      fieldcp-fieldname
;;                                      WFF-CLASS-REP-STATIC-STRONG
;;                                      field-fieldname 
;;                                      fieldcp-to-field-ptr
;;                                      lookupfield
;;                                      class-is-loaded-from-helper
;;                                      isClassTerm
;;                                      superclass-no-loop))
;;            :do-not '(generalize)
;;            :use ((:instance field-decl-with-name-equal-lookupfield
;;                             (field-ptr (fieldcp-to-field-ptr fieldcp)))))))
</span>

(local 
 (defthm consistent-object-bound-field-implies-consistent-value-specific
  (implies (and (consistent-object obj (heap s) (instance-class-table s))
                (not (isArrayType (obj-type obj)))
                (bound? (field-classname
                         (lookupfield (fieldcp-to-field-ptr fieldcp) s))
                        (java-visible-portion obj))
                (bound? (fieldcp-fieldname fieldcp)
                        (binding (field-classname
                                            (lookupfield (fieldcp-to-field-ptr fieldcp) s))
                                           (java-visible-portion obj)))
                (lookupfield (fieldcp-to-field-ptr fieldcp) s)
                (<a href="../consistent-state.lisp.html">consistent-state</a> s))
           (consistent-value (tag (binding (fieldcp-fieldname fieldcp)
                                           (binding (field-classname 
                                                               (lookupfield
                                                                (fieldcp-to-field-ptr 
                                                                 fieldcp) s))
                                                              (java-visible-portion obj)))
                                  (fieldcp-fieldtype fieldcp))
                             (fieldcp-fieldtype fieldcp)
                             (instance-class-table s)
                             (heap s)))
  <span class="builtin">:hints</span> ((<span class="string">"Goal"</span> <span class="builtin">:in-theory</span> (disable consistent-value 
                                      obj-type binding bound?
                                      field-fieldtype
                                      fieldcp-fieldname
                                      field-classname
                                      fieldcp-to-field-ptr
                                      fieldcp-fieldtype
                                      consistent-object-bound-field-implies-consistent-value
                                      fields tag isArrayType
                                      java-visible-portion
                                      consistent-object)
           <span class="builtin">:use</span> ((<span class="builtin">:instance</span>
                  consistent-object-bound-field-implies-consistent-value
                  (classname (field-classname (lookupfield
                                               (fieldcp-to-field-ptr 
                                                fieldcp) s)))
                  (field-decl (lookupfield (fieldcp-to-field-ptr fieldcp) s))
                  (cl (instance-class-table s))
                  (hp (heap s))
                  (fieldname (fieldcp-fieldname fieldcp))))))))
                                                    


    
<span class="comment">;; (defthm consistent-object-and-field-found-implies-field-name-bound-in-immediate-instance
;;    (implies (and (<a href="../consistent-state.lisp.html">consistent-state</a> s)
;;                  (consistent-object obj (heap s) (instance-class-table s))
;;                  (car (isAssignableTo (obj-type obj) (fieldCP-classname fieldcp) s))
;;                  (lookupField (fieldcp-to-field-ptr fieldCP) s))
;;             (bound? (fieldcp-fieldname fieldcp)
;;                     (binding (field-classname
;;                               (lookupField (fieldcp-to-field-ptr
;;                                             fieldCP) s))
;;                              (java-visible-portion obj))))
;;    :hints (("Goal" :in-theory (disable bound? field-classname isAssignableTo
;;                                        fieldcp-to-field-ptr
;;                                        binding
;;                                        CONSISTENT-OBJECT-AND-FIELD-FOUND-IN-LOOKUP-IMPLIES-JVM-FIELD-ACCESS-GUARD
;;                                        fieldcp-fieldname
;;                                        java-visible-portion
;;                                        consistent-object)
;;             :use  consistent-object-and-field-found-in-lookup-implies-jvm-field-access-guard))))
</span>

(local 
 (defthm bound-in-binding-implies-bound
   (implies (not (bound? name jvp))
            (not (bound? fieldname (binding name jvp))))))
                 
(local 
 (defthm consistent-object-bound-field-implies-consistent-value-specific-simplify
  (implies (and (consistent-object obj (heap s) (instance-class-table s))
                (not (isArrayType (obj-type obj)))
                (car (isAssignableTo (obj-type obj) (fieldcp-classname fieldcp) s))
                (lookupfield (fieldcp-to-field-ptr fieldcp) s)
                (<a href="../consistent-state.lisp.html">consistent-state</a> s))
           (consistent-value (tag (binding (fieldcp-fieldname fieldcp)
                                           (binding (field-classname 
                                                               (lookupfield
                                                                (fieldcp-to-field-ptr 
                                                                 fieldcp) s))
                                                              (java-visible-portion obj)))
                                  (fieldcp-fieldtype fieldcp))
                             (fieldcp-fieldtype fieldcp)
                             (instance-class-table s)
                             (heap s)))
  <span class="builtin">:hints</span> ((<span class="string">"Goal"</span> <span class="builtin">:in-theory</span> (disable consistent-value 
                                      obj-type binding bound?
                                      field-fieldtype
                                      fieldcp-fieldname
                                      field-classname
                                      fieldcp-to-field-ptr
                                      fieldcp-fieldtype
                                      consistent-object-bound-field-implies-consistent-value
                                      fields tag isArrayType
                                      java-visible-portion
                                      consistent-object)))))


(defthm consistent-object-consistent-state-m6-getfield-consistent-value
   (implies (and (<a href="../consistent-state.lisp.html">consistent-state</a> s)
                 (car (isAssignableTo (obj-type (deref2 v (heap s)))
                                      (fieldcp-classname fieldCP)
                                      s))
                 (REFp v (heap s))
                 (equal (FIELD-CLASSNAME (LOOKUPFIELD (FIELDCP-TO-FIELD-PTR fieldcp)
                                                      S))
                        classname)
                 (lookupField (fieldcp-to-field-ptr fieldCP) s)
                 (not (NULLp v)))
            (CONSISTENT-VALUE
             (TAG (M6-GETFIELD classname
                               (fieldcp-fieldname fieldcp)
                               (RREF v)
                               S)
                  (fieldcp-fieldtype fieldcp))
             (fieldcp-fieldtype fieldcp)
             (INSTANCE-CLASS-TABLE S)
             (HEAP S)))
   <span class="builtin">:hints</span> ((<span class="string">"Goal"</span> <span class="builtin">:in-theory</span> (disable consistent-value-x
                                      consistent-value
                                      lookupfield
                                      fieldcp-fieldtype
                                      consistent-array-object
                                      isAssignableTo
                                      REFp NULLp
                                      deref2
                                      rREF
                                      obj-type
                                      fields
                                      fieldcp-fieldname
                                      java-visible-portion
                                      fieldcp-to-field-ptr
                                      fieldcp-classname
                                      field-classname
                                      field-fieldname
                                      field-fieldtype
                                      tag binding bound?
                                      isArrayType obj-type
                                      lookupfield)
            <span class="builtin">:cases</span> ((isArrayType (obj-type (deref2 v (heap s))))))))



</pre>
  </body>
</html>
