<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01//EN">
<!-- Created by htmlize-1.16 in css mode. -->
<html>
  <head>
    <title>m6-bytecode.lisp</title>
    <style type="text/css">
    <!--
      body {
        color: #f5deb3;
        background-color: #000000;
      }
      .builtin {
        /* font-lock-builtin-face */
        color: #b0c4de;
      }
      .comment {
        /* font-lock-comment-face */
        color: #ff7f24;
      }
      .function-name {
        /* font-lock-function-name-face */
        color: #87cefa;
      }
      .keyword {
        /* font-lock-keyword-face */
        color: #00ffff;
      }
      .string {
        /* font-lock-string-face */
        color: #ffa07a;
      }
      a {
        color: inherit;
        background-color: inherit;
        font: inherit;
        text-decoration: inherit;
      }
      a:hover {
        text-decoration: underline;
      }
    -->
    </style>
  </head>
  <body>
    <pre>
(<span class="keyword">in-package</span> <span class="string">"M6"</span>)

(include-book <span class="string">"ordinals/e0-ordinal"</span> <span class="builtin">:dir</span> <span class="builtin">:system</span>)
(set-well-founded-relation e0-ord-&lt;)

(include-book <span class="string"><a href="m6-state.lisp.html">"../M6/m6-state"</a></span>)
(include-book <span class="string"><a href="m6-frame-manipulation-primitives.lisp.html">"../M6/m6-frame-manipulation-primitives"</a></span>)
(include-book <span class="string"><a href="m6-exceptions.lisp.html">"../M6/m6-exceptions"</a></span>)
(include-book <span class="string"><a href="m6-object-manipulation-primitives.lisp.html">"../M6/m6-object-manipulation-primitives"</a></span>)
(include-book <span class="string"><a href="../M6-DJVM-shared/jvm-bytecode.lisp.html">"../M6-DJVM-shared/jvm-bytecode"</a></span>)
(include-book <span class="string"><a href="m6-native.lisp.html">"../M6/m6-native"</a></span>)
(include-book <span class="string"><a href="m6-type-value.lisp.html">"../M6/m6-type-value"</a></span>)
(include-book <span class="string"><a href="m6-static-initializer.lisp.html">"../M6/m6-static-initializer"</a></span>)
(include-book <span class="string"><a href="m6-loader.lisp.html">"../M6/m6-loader"</a></span>)
(include-book <span class="string"><a href="m6-linker.lisp.html">"../M6/m6-linker"</a></span>)

<span class="comment">;; ;; not ready to really write down the JVM definition...
;; ;; I need a set of macros. 
;; ;; i need to be familiar with the macros, and decide what I need.
</span>
<span class="comment">;; ;; but now I am just writing down definitions of a few typical instructions
;; ;; manually to decide what basic operations I need. 
</span>
<span class="comment">;; ;; assertions. 
;; ;; etc. etc.
</span>
<span class="comment">;; (acl2::set-verify-guards-eagerness 0)
</span>
(<span class="keyword">defmacro</span> <span class="function-name">ADVANCE-PC</span> (s)
  `(state-set-pc (+ (pc ,s)
                    (<a href="../DJVM/INST/inst.lisp.html">inst</a>-size <a href="../DJVM/INST/inst.lisp.html">inst</a>))
                 ,s))


(<span class="keyword">defmacro</span> <span class="function-name">LLP</span> (index)
  `(local-at ,index s))

<span class="comment">;---------------------------------------------------------------------
</span>
<span class="comment">;---------------------------------------------------------------------
;-------------------------        A         --------------------------
;---------------------------------------------------------------------
</span>
(<span class="keyword">defun</span> <span class="function-name">CHECK-ARRAY</span> (array-ref index s)
  (<span class="keyword">let*</span> ((array (binding array-ref (heap s)))
         (bound (array-bound array)))
    (and (&lt;= 0 index)
         (&lt; index bound))))
               
(<span class="keyword">defun</span> <span class="function-name">CHECK-NULL</span> (ref)
  (equal ref -1))

(<span class="keyword">defun</span> <span class="function-name">element-at-array</span> (index array-ref s)
  (<span class="keyword">let</span> ((array-obj (binding array-ref (heap s))))
    (element-at index array-obj)))


(<span class="keyword">defun</span> <span class="function-name">execute-AALOAD</span> (<a href="../DJVM/INST/inst.lisp.html">inst</a> s)
  (<span class="keyword">let*</span> ((index (topStack s))
         (array-ref (secondStack s)))
    (<span class="keyword">if</span> (CHECK-NULL array-ref)
        (raise-exception <span class="string">"java.lang.NullPointerException"</span> s)
      (<span class="keyword">if</span> (check-array array-ref index s)
          (ADVANCE-PC (pushStack (element-at-array index array-ref s)
                                 (popStack (popStack s))))
        (raise-exception <span class="string">"java.lang.ArrayIndexOutOfBoundsException"</span> s)))))

<span class="comment">; Note: 
;;; Only NEWARRAY instruction involves access control during resolution of
;;; symbolic links.
</span>
<span class="comment">;Defensive: 
;;; REF if not null, points to an object of valid type. (?) 
;;; Check for op stack UNDERFLOW 
</span>
<span class="comment">;;; Question: How defensive we want AALOAD??
</span>
<span class="comment">;;;
;;; Maybe it is ok to guarantee that <a href="../DJVM/INST/AALOAD.lisp.html">AALOAD</a> points to a object with the outer
;;; most type is ARRAY. (not need to follow the definition of array's element
;;; type, to verify it is still a valid type.
;;; 
;;; The other is implied by consistent-state. To demonstrate the purpose of
;;; bytecode verification, we may want to check more to show that we saved a
;;; lot of runtime checking.
</span>
<span class="comment">; Bytecode verifier:
;;; Guarantee a valid type and assignable to Array("java.lang.Object")
;;; Guarantee availability of the 
</span>
<span class="comment">; Informal proof 
;;; BCV ==&gt; No error
</span>

<span class="comment">; TOP LEVEL Formal proof
; 
; GOAL ONE: show DEFENSIVE MACHINE is MEANINGFUL
;   
;  i.e. by code inspection (1)
;       by proving DEFENSIVE MACHINE preserves an STRONG and intuitive
;       CONSISTENT-STATE  (2)
; 
; GOAL TWO: show current efficient IMPLEMENTATION is legitimate. 
;  i.e. by proving with bytecode verification, the efficient implementation IS
;  the "defensive" version (producing the same state)   
;       
;     1. BCV succeed could guarantee the defensive check on the first
;     instruction succeed. (under <a href="../DJVM/consistent-state.lisp.html">consistent-state</a> hyp) 
;
;     2. BCV will succeed on all states  after sig-step  
;        Step defensive machine, the resulting state is more specific than 
;        One of the sig state after the sig-step
;        We proved BCV succeed on general will succeed on specific
;        Thus next Defensive will still succeed. 
;
;     3. IF all defensive check succeed, non-defensive behaves the same as the
;        defensive machine.
;        
; NOTE: <a href="../DJVM/consistent-state.lisp.html">consistent-state</a> is needed (probably need to be strenghtened along the
; way for proving BCV succeeds implies defensive succeed.
;
;     
;
; The question: Distinguish runtime EXCEPTIONS with unexpected error! 
;
;     The current JVM some fatalError in fact is unvoidable by BCV (both
;     defensive and non defensive machine will behave the same)
;     
;     Maybe defensive preserves the <a href="../DJVM/consistent-state.lisp.html">consistent-state</a> and non-defensive behave
;     the same is good enough to say BCV is useful (because defensive machine
;     is useful, and after using BCV we know, non-defensive machine behave the
;     same, thus also useful.)
;
;     So the goal two is transformed into 
;     BCV ==&gt; defensive == nondefensive 
;     
;  Mon Dec 19 21:02:40 2005: 
;     DJVM checks for extra conditions. Those conditions should never be
;     violated while exeucting a verified program. 
</span>


<span class="comment">;  <a href="../DJVM/INST/AASTORE.lisp.html">AASTORE</a> 
;; 
;; ;---------------------------------------------------------
;; (defun execute-AASTORE1 (obj-ref index array-ref s)
;;   (let* ((value-obj  (binding obj-ref (heap s)))
;;          (array-obj  (binding array-ref (heap s)))
;;          (array-type (array-type array-obj))
;;          (base-type  (array-base-type array-type)))
;;     (mv-let (status new-s)
;;             (isAssignableTo (obj-type value-obj) base-type s)
;;             (if status
;;                 (set-element-at-array index obj-ref array-ref (popStack
;;                                                                (popStack
;;                                                                 (popStack new-s))))
;;               (raise-exception "java.lang.ArrayStoreException" new-s)))))
</span>



<span class="comment">; IF a value of particular exists, we can be sure that isAssignableTo won't
; cause class loading!!
; 
; isAssignableTo may only causes class loading in CHECKCAST, INSTANCEOF
; AssignmentCompatible in defensive machine is more like bytecode verifier's
; isAssignableTo.  I don't want it to cause class loading. 
;
; changed "arrayStoreException" to "ArrayStoreException"
;;
;; Note: <a href="../DJVM/INST/AASTORE.lisp.html">AASTORE</a> check store respect to the isAssignable relation at runtime
;; That is this is not guaranteed by Bytecode verifier however in principle
;; this can be enforced by the bytecode verifer To compile Java, compiler will
;; need to insert more CHECKCAST so that bytecode could pass.
;; 
</span>
<span class="comment">; JVMS 2.6.7
; value of type S is assignable to variable/slot of type T.
;
;     * If S is a class type, then:
;           o If T is a class type, then S must be the same class (?2.8.1) as T, or S must be a subclass of T;
;           o If T is an interface type, S must implement (?2.13) interface T.
;     * If S is an interface type, then:
;           o If T is a class type, then T must be Object (?2.4.7).
;           o If T is an interface type, then T must be the same interface as S or a superinterface of S (?2.13.2).
;     * If S is an array type, namely, the type SC[], that is, an array of components of type SC, then:
;           o If T is a class type, then T must be Object (?2.4.7).
;           o If T is an array type TC[], that is, an array of components of type TC, then one of the following must be true:
;                 + TC and SC are the same primitive type (?2.4.1).
;                 + TC and SC are reference types (?2.4.6), and type SC is assignable to TC by these runtime rules.
; o If T is an interface type, T must be one of the interfaces implemented by arrays (?2.15). 
; Here 
</span>
<span class="comment">; Here at isAssignable is checked at runtime, so (obj-type value-obj) must be a
; class type. It is not possible for obj-type to be an interface type. 
; However in the bytecode verifier, it could be an interface type though.
;
; isAssignableTo is rather complicated. It is different from the isAssignableTo
; in the BCV. BCV's isAssignable is more generaous in return t.
; 
</span>


<span class="comment">;; ;---------------------------------------------------------
;; (defun execute-AASTORE1 (obj-ref index array-ref s)
;;   (let* ((value-obj  (binding obj-ref (heap s)))
;;          (array-obj  (binding array-ref (heap s)))
;;          (array-type (array-type array-obj))
;;          (base-type  (array-base-type array-type)))
;;     (mv-let (status new-s)
;;             (isAssignableTo (obj-type value-obj) base-type s)
;;             (if status
;;                 (set-element-at-array index obj-ref array-ref (popStack
;;                                                                (popStack
;;                                                                 (popStack new-s))))
;;               (raise-exception "java.lang.ArrayStoreException" new-s)))))
</span>
(<span class="keyword">defun</span> <span class="function-name">execute-AASTORE</span> (<a href="../DJVM/INST/inst.lisp.html">inst</a> s)
  (<span class="keyword">let*</span> ((obj-ref (topStack s))
         (index   (secondStack s))
         (array-ref (thirdStack s)))
    (<span class="keyword">if</span> (CHECK-NULL array-ref)
        (raise-exception <span class="string">"java.lang.NullPointerException"</span> s)
      (<span class="keyword">if</span> (check-array array-ref index s)
          (<span class="keyword">if</span> (not (CHECK-NULL obj-ref))
              (<span class="keyword">let*</span> ((value-obj  (binding obj-ref (heap s)))
                     (array-obj  (binding array-ref (heap s)))
                     (array-type (array-type array-obj))
                     (base-type  (array-base-type array-type)))
                (mv-let (status new-s)
                        (isAssignableTo (obj-type value-obj) base-type s)
                        (<span class="keyword">if</span> status
                            (ADVANCE-PC (set-element-at-array index obj-ref array-ref 
                                                              (popStack (popStack (popStack new-s)))))
                          (raise-exception <span class="string">"java.lang.ArrayStoreException"</span> new-s))))
            (ADVANCE-PC (set-element-at-array index obj-ref array-ref 
                                              (popStack (popStack (popStack s))))))
        (raise-exception <span class="string">"java.lang.ArrayIndexOutOfBoundsException"</span> s)))))

<span class="comment">; Defensive:
;; REF is null or REF refers to an object with a valid type. 
;; Check UNDERFLOW. Do I also need to check the max stack of the input state?? 
;; May be that is also a part of the global invariant. 
;
;  (Object  to store is isAssignable to ArrayType) not checked, this is checked
;  at runtime!!
;
;  May need some well form state predicated saying if safe check succeeds,
;  wellformedness are preserved before we can reason about getfield and putfield.
</span>
<span class="comment">; Bytecode verifier
;; REF is null or REF refers to a valid type 
</span>
<span class="comment">; Informal proof: 
; quite similiar, invariant is that REF seen by BCV is more general than the
; concrete type seem by Safe JVM
; stack is in range. 
</span>
<span class="comment">; Note: the difference between proofs for <a href="../DJVM/INST/AASTORE.lisp.html">AASTORE</a> and <a href="../DJVM/INST/AALOAD.lisp.html">AALOAD</a> are none. 
; <a href="../DJVM/INST/AASTORE.lisp.html">AASTORE</a> is different from <a href="../DJVM/INST/AALOAD.lisp.html">AALOAD</a> is that it checks more information at
; runtime, in both defensive and non-defensive JVM. Exceptions are thrown.
; 
; Justification for it is because it may not be possible to do bytecode
; verification statically when both Array REF 
; 
</span>
<span class="comment">;---------------------------------------------------------------------
</span>
(<span class="keyword">defun</span> <span class="function-name">execute-ACONST_NULL</span> (<a href="../DJVM/INST/inst.lisp.html">inst</a> s)
  (ADVANCE-PC (pushStack -1 s)))

<span class="comment">; Defensive: check for Stack overflow
;
;
; Bytecode verifier: check for with in range.  
;
;
; Informal proof: 
;; Same 
;
</span>
<span class="comment">;---------------------------------------------------------------------
</span>
(<span class="keyword">defun</span> <span class="function-name">execute-ALOAD</span> (<a href="../DJVM/INST/inst.lisp.html">inst</a> s)
  (ADVANCE-PC (pushStack (LLP (arg <a href="../DJVM/INST/inst.lisp.html">inst</a>)) s)))

<span class="comment">; Defensive: 
;    OP STACK OVERFLOW 
;    LOCAL BOUND in RANGE 
;    VALID REF or null 
;   
; BCV:
;    IN RANGE, op, locals
;    valid type
; 
; Informal Proof:
;
;   Invariant guarantee: VALID REF 
;   not relate to valid type result from BCV   
;
;---------------------------------------------------------------------
</span>
(<span class="keyword">defun</span> <span class="function-name">execute-ALOAD_0</span> (<a href="../DJVM/INST/inst.lisp.html">inst</a> s)
  (ADVANCE-PC (pushStack (LLP 0) s)))

(<span class="keyword">defun</span> <span class="function-name">execute-ALOAD_1</span> (<a href="../DJVM/INST/inst.lisp.html">inst</a> s)
  (ADVANCE-PC (pushStack (LLP 1) s)))


(<span class="keyword">defun</span> <span class="function-name">execute-ALOAD_2</span> (<a href="../DJVM/INST/inst.lisp.html">inst</a> s)
  (ADVANCE-PC (pushStack (LLP 2) s)))

(<span class="keyword">defun</span> <span class="function-name">execute-ALOAD_3</span> (<a href="../DJVM/INST/inst.lisp.html">inst</a> s)
  (ADVANCE-PC (pushStack (LLP 3) s)))


<span class="comment">;--------------------------------------------------------------------
; SAME AS <a href="../DJVM/INST/ALOAD.lisp.html">ALOAD</a> 
;---------------------------------------------------------------------
</span>
(<span class="keyword">defun</span> <span class="function-name">execute-anewarray</span> (<a href="../DJVM/INST/inst.lisp.html">inst</a> s)
  (<span class="keyword">let*</span> ((basetype (normalize-type-rep (arg <a href="../DJVM/INST/inst.lisp.html">inst</a>)))
         (new-s    (resolveClassReference basetype s))
         (new-s2   (getArrayClass basetype new-s)))
    (<span class="keyword">if</span> (not (no-fatal-error? new-s))
        new-s
      (<span class="keyword">if</span> (pending-exception new-s) 
          (raise-exception (pending-exception new-s) new-s)
        (<span class="keyword">if</span> (not (no-fatal-error? new-s2))
            new-s2
          (<span class="keyword">if</span> (&lt; (topStack s) 0)
              (raise-exception <span class="string">"java.lang.NegativeArraySizeException"</span> new-s2)
            (ADVANCE-PC (new-array basetype (topStack s) (popStack new-s2)))))))))


<span class="comment">;; Tue May 31 17:25:23 2005 Modified to match with DJVM's ANEWARRAY. note this
;; is not an effciency loss.  Tue May 31 17:27:17 2005.
</span>
<span class="comment">;; (defun execute-anewarray (<a href="../DJVM/INST/inst.lisp.html">inst</a> s)
;;   (let* ((basetype (normalize-type-rep (arg <a href="../DJVM/INST/inst.lisp.html">inst</a>)))
;;          (new-s    (resolveClassReference basetype s))
;;          (new-s2   (getArrayClass basetype new-s)))
;;     (if (pending-exception new-s) 
;;         (raise-exception (pending-exception new-s) new-s)
;;       ;; check possible exception. 
;;       ;; access permission is checked at resolution time. 
;;       (if (&lt; (topStack s) 0)
;;           (raise-exception "java.lang.NegativeArraySizeException" new-s2)
;;       (ADVANCE-PC (new-array basetype (topStack s) (popStack new-s2)))))))
</span>

<span class="comment">;; ;;; Fri Apr  2 13:04:54 2004
</span>


<span class="comment">;
; Defensive: 
;   Resolution succeed/fail link time (shared with BCV?) 
;   no. BCV does not cause resolution. just trust the constant pool entry
;   
;   count &lt; 0 is runtime error.
;   OVERFLOW ??  
;
;   ACCESS PERMISION TO THE RESOLVED FIELD ?? No need to check that 
;   because same resolution step will be doing the checking.
;   Resolution is shared with non-defensive machine 
;   
;   the <a href="../DJVM/INST/base.lisp.html">base</a> type can't be interface type?? It can. 
;   
; BCV:
;
;   BCV does not need to do the resolution.  
;  
;   HOW ABOUT ACCESS PERMISSION? No need. BCV trust the constant pool entry
;   discription.
;
;   Resolution + loader will check that constant pool is telling the truth and
;   catch the inconsistency
;     
;
; Informal Proof:
;   
;   Only real constraints are OP stack etc.  Need invariant that if resolution
;   succeed, the resolved one matches up with constant pool entry description.
;   The invariant is ensured by a careful class loader. (class definition)
;
; Actual Experience:
;  
;   Class loading introduces quite some complexity that we need to say the type
;   hierachy are maintained. Judgement for assignment compatibilty between
;   classes are maintained. And class loading preserve the global invariant. 
; 
;   A lot work. 9000+ lines of proof script. 
;
;
; NOTE: 
;   However the problem of global invariant. 
;
;
;  
;   Thrown exception resulting in a welformed state.  (skip proof?)
;   BCV's next state covers all possible next state.
;  
;---------------------------------------------------------------------
</span>


<span class="comment">;---------------------------------------------------------------------
;
; ARETURN and RETURNs 
;
; These are complicated, because this need to handle thread, synchronization
; flags correctly.
; (execute-return <a href="../DJVM/INST/inst.lisp.html">inst</a> s '1) is ARETURN, IRETURN, FRETURN ... 
;
; In a non-defensive, areturn is similiar to other return
; copy the top entry on the current op stack to ...
; 
</span>

(<span class="keyword">defun</span> <span class="function-name">isThreadAlive</span> (thread)
  (or (mem 'JVM::thread_suspended (thread-state thread))
      (mem 'JVM::thread_active    (thread-state thread))))

(<span class="keyword">defun</span> <span class="function-name">areAliveThreads1</span> (threads)
  (<span class="keyword">if</span> (endp threads)
      nil
    (or (isThreadAlive (car threads))
        (areAliveThreads1 (cdr threads)))))

<span class="comment">;; it is possible to have suspended thread, but no active thread.
</span>
(<span class="keyword">defun</span> <span class="function-name">areAliveThreads</span> (s)
  (<span class="keyword">let</span> ((tt (thread-table s)))
    (areAliveThreads1 tt)))


<span class="comment">;; tmp implementation: reschedule 
</span>(<span class="keyword">defun</span> <span class="function-name">reschedule</span> (s) 
  s)

<span class="comment">;; tmp implementation: terminate 
</span>(<span class="keyword">defun</span> <span class="function-name">terminate</span> (s) 
  s)


(<span class="keyword">defun</span> <span class="function-name">execute-return1</span> (return-pc s c)
  (<span class="keyword">if</span> (equal return-pc 'KILL_THREAD)
      (<span class="keyword">let</span> ((new-s (stopThread s)))
        (<span class="keyword">if</span> (areAliveThreads new-s)
            (reschedule new-s) 
          <span class="comment">;; may add a flag to indicate forced the reschedule or do nothing.
</span>          <span class="comment">;; let the top level scheduler decide when to schedule
</span>          (prog2$ (acl2::debug-print <span class="string">"No Thread alive Program Terminated!~%"</span>)
                  (terminate new-s)))) 
    (<span class="keyword">if</span> (equal c 0)
        (popFrame s)
      (<span class="keyword">if</span> (equal c 1)
          (pushStack (topStack s) (popFrame s))
        (<span class="keyword">if</span> (equal c 2)
            (pushStack (topStack s)
                       (pushStack (secondStack s) (popFrame s)))
        <span class="comment">;; the last case should be impossible
</span>          s)))))

<span class="comment">;; NOTE: is it possible for a JVM to reach a deadlock state? (No active
;; thread?) YES. 
;;
;; Is it possible to have a thread that tries to return from the last call
;; frame? if thread table is well formed, we know every frame has a KILL_THREAD
;; return address.
;; 
</span>


<span class="comment">;; all returns are the same after bytecode verification, as long as they are
;; returning the same number of entries from the op stack
</span>(<span class="keyword">defun</span> <span class="function-name">execute-return</span> (<a href="../DJVM/INST/inst.lisp.html">inst</a> s c)
  (<span class="keyword">declare</span> (ignore <a href="../DJVM/INST/inst.lisp.html">inst</a>))
  (<span class="keyword">let*</span> ((curframe   (current-frame s))
         (return-pc  (return-pc curframe))
         (sync-obj-ref (sync-obj-ref curframe)))
    (<span class="keyword">if</span> (not (equal sync-obj-ref -1))
        (mv-let (mstatus exceptionname s1)
                (monitorExit sync-obj-ref s)
                (<span class="keyword">if</span> (equal mstatus 'MonitorStatusError)
                    (raise-exception exceptionname s)
                  (execute-return1 return-pc s1 c)))
      (execute-return1 return-pc s c))))

<span class="comment">;--------------------
; Defensive: 
;
;    Check ref refers to valid objects. 
;    return type matches. (isAssignable relation) 
;    
;    Monitor always exists in M6. Non defensive also checks that correct
;    synchronization state. Exceptions are thrown. 
;    
; 
; BCV:
;    Check ref of valid type, isAssignable to return type.    
;
; Informal Proof:
;
;    Invariant is that ref seen by BCV is more general than the one seen by
;    defensive ones.  
;
;---------------------------------------------------------------------
</span>
<span class="comment">;---------------------------------------------------------------------
; 
; Only requirement is ref refering to an array or is null. 
</span>    
(<span class="keyword">defun</span> <span class="function-name">execute-ARRAYLENGTH</span> (<a href="../DJVM/INST/inst.lisp.html">inst</a> s)
  (<span class="keyword">let</span> ((array-ref (topStack s)))
    (<span class="keyword">if</span> (CHECK-NULL array-ref)
        (raise-exception <span class="string">"java.lang.NullPointerException"</span> s)
      (ADVANCE-PC (pushStack (array-bound (deref array-ref (heap s)))
                             (popStack s))))))


<span class="comment">; Defensive: 
;   Valid Array Objects.  check for ? negative length. 
;   or null.
;
; BCV:
;   
;   Valid Type, can be null though.  
;  
; Informal Proof:
;
;   Well formed invariant guarantees every value has the valid type 
;   BCV guarantees the array type. 
;   
;   The difficulty is to prove Defensive machine is somewhat in sync with BCV
;   We can easily prove the first instructions from both model in sync
;   We have to somehow talk about relation between (BCV s) and (BCV  (step s))
;---------------------------------------------------------------------
</span>
<span class="comment">;---------------------------------------------------------------------
;
; <a href="../DJVM/INST/ASTORE.lisp.html">ASTORE</a> 
</span>
<span class="comment">;; (defun set-local-at-of-thread (index value old-thread)
;;   (let* ((old-call-stack (thread-call-stack old-thread))
;;          (old-top-frame  (top old-call-stack))
;;          (old-locals     (locals old-top-frame))
;;          (new-locals     (update-nth index value old-locals))
;;          (new-top-frame  (frame-set-locals new-locals old-top-frame))
;;          (new-call-stack (push new-top-frame (pop old-call-stack)))
;;          (new-thread     (thread-set-call-stack new-call-stack old-thread)))
;;     new-thread))
</span>

<span class="comment">;; (defun state-set-local-at (index value s)
;;   (let* ((old-thread-table (thread-table s))
;;          (old-thread (thread-by-id (current-thread s) old-thread-table))
;;          (new-thread (set-local-at-of-thread index value old-thread))
;;          (new-thread-table (replace-thread-table-entry old-thread new-thread
;;                                                        old-thread-table)))
;;     (state-set-thread-table new-thread-table s)))
</span>

<span class="comment">;;; move to jvm-frame-manipulation-primitives.lisp Tue Mar  9 18:48:08 2004
</span>
<span class="comment">;; (defun state-set-local-at (index value s)
;;   (let* ((old-thread-table (thread-table s))
;;          (old-thread (thread-by-id (current-thread s) old-thread-table))
;;          (new-thread (set-local-at-of-thread index value old-thread))
;;          (new-thread-table (replace-thread-table-entry old-thread new-thread
;;                                                        old-thread-table)))
;;     (if (current-thread-exists? s)
;;         (state-set-thread-table new-thread-table s)
;;       s)))
</span>
(<span class="keyword">defmacro</span> <span class="function-name">SET-LP</span> (index value)
  `(state-set-local-at ,index ,value s))

(<span class="keyword">defun</span> <span class="function-name">execute-ASTORE</span> (<a href="../DJVM/INST/inst.lisp.html">inst</a> s)
  (<span class="keyword">let*</span> ((index (arg <a href="../DJVM/INST/inst.lisp.html">inst</a>))
         (v1 (topStack s)))
    (<span class="keyword">let</span> ((s (popStack s)))
      (ADVANCE-PC (SET-LP index v1)))))
<span class="comment">;
; HANDLING OF WIDE is ignored. 
</span>

(<span class="keyword">defun</span> <span class="function-name">execute-ASTORE_0</span> (<a href="../DJVM/INST/inst.lisp.html">inst</a> s)
  (ADVANCE-PC (popStack (SET-LP 0 (topStack s)))))

(<span class="keyword">defun</span> <span class="function-name">execute-ASTORE_1</span> (<a href="../DJVM/INST/inst.lisp.html">inst</a> s)
  (ADVANCE-PC (popStack (SET-LP 1 (topStack s)))))

(<span class="keyword">defun</span> <span class="function-name">execute-ASTORE_2</span> (<a href="../DJVM/INST/inst.lisp.html">inst</a> s)
  (ADVANCE-PC (popStack (SET-LP 2 (topStack s)))))

(<span class="keyword">defun</span> <span class="function-name">execute-ASTORE_3</span> (<a href="../DJVM/INST/inst.lisp.html">inst</a> s)
  (ADVANCE-PC (popStack (SET-LP 3 (topStack s)))))

<span class="comment">; Defensive: 
;   Valid REF (ensured by invariant) 
;   Within BOUND 
;   or 
;   RETURN ADDRESS (different from <a href="../DJVM/INST/ALOAD.lisp.html">ALOAD</a> )
;    
;  
; BCV:
;
;   Within BOUND, REF pointer, null, or RETURN ADDRESS
;   
; 
; Informal Proof:
;
;   Within BOUND BCV
;   Code array remain the same. 
;   (instruction do not change)
;   
;---------------------------------------------------------------------
</span>
<span class="comment">;---------------------------------------------------------------------
</span>
(<span class="keyword">defun</span> <span class="function-name">execute-ATHROW</span> (<a href="../DJVM/INST/inst.lisp.html">inst</a> s)
  (<span class="keyword">declare</span> (ignore <a href="../DJVM/INST/inst.lisp.html">inst</a>))
  (throw-exception (topStack s) s))


<span class="comment">; NOTE: type reference 
;
; Defensive: 
;    must be assignable to Throwable 
; BCV:
;    reference type assignable to Throwable 
;    BCV's assignable is between classes.
;
;    Defensive machine's assignable also talks about Interfaces. 
;    However here Throwable is a CLASS and the actual thing is a CLASS
;    so fine. They should behave the same. 
;
; Informal Proof:
;
;   Invariant, the type that BCV sees always more general
;   The problem is that we need to show BCV in sync with the JVM
;   In sync, BCV will succeed on the more specific state. 
;---------------------------------------------------------------------
</span>
<span class="comment">; CONVINCE MYSELF 
</span>
<span class="comment">;---------------------------------------------------------------------
;-------------------------        B         --------------------------
;---------------------------------------------------------------------
</span>


<span class="comment">;---------------------------------------------------------------------
</span>
(<span class="keyword">defun</span> <span class="function-name">array-ref-type</span> (array-ref s)
  (array-type (deref array-ref (heap s))))


<span class="comment">; (defun execute-BALOAD (<a href="../DJVM/INST/inst.lisp.html">inst</a> s)
;   (let* ((index (topStack s))
;          (array-ref (secondStack s)))
;     (if (CHECK-NULL array-ref)
;         (raise-exception "java.lang.NullPointerException" s)
;       (if (check-array array-ref index s)
;           (ADVANCE-PC (pushStack (element-at-array index array-ref s)
;                                  (popStack (popStack ))))
;       (raise-exception "java.lang.ArrayIndexOutOfBoundsException" s)))))
</span>
<span class="comment">;;
;; this version relies on the fact that in a consistent state, the
;; representation of any array-boolean and array-byte have values of correct
;; range. checking for the type and do the fixing is not necessary.
;; 
;; Bytecode verifier does not distinguish between boolean array and
;; bytearray. However it is not possible to mistreat a boolean array and a int-array,
;; if BASTORE is implemented correctly.
;;
</span>


(<span class="keyword">defun</span> <span class="function-name">execute-BALOAD</span> (<a href="../DJVM/INST/inst.lisp.html">inst</a> s)
 (<span class="keyword">let*</span> ((index (topStack s))
        (array-ref (secondStack s)))
   (<span class="keyword">if</span> (CHECK-NULL array-ref)
       (raise-exception <span class="string">"java.lang.NullPointerException"</span> s)
     (<span class="keyword">if</span> (check-array array-ref index s)
         (<span class="keyword">let</span> ((array-type (array-ref-type array-ref s)))
           (<span class="keyword">if</span> (equal array-type '(array boolean))
               (ADVANCE-PC (pushStack (uint-fix (element-at-array index array-ref s))
                                      (popStack (popStack s))))
             (ADVANCE-PC (pushStack (int-fix (element-at-array index array-ref s))
                                    (popStack (popStack s))))))
       (raise-exception <span class="string">"java.lang.ArrayIndexOutOfBoundsException"</span> s)))))

<span class="comment">;
; here we assume if not array boolean, not null,  it must be array byte.
;
</span>
<span class="comment">;
; NOTE: Similar to AALOAD. However type BCV check is the same with defensive check
;
; It is not clear whether loading from a array of boolean we get 1 or 0.
; however the definition of bastore and <a href="../DJVM/consistent-state.lisp.html">consistent-state</a> invariant can ensure that.
;
; Defensive: 
;
;    Object of array type, byte array, or boolean array or null.  in principle,
;    we don't have to do uint-fix or int-fix during loading because
;    <a href="../DJVM/consistent-state.lisp.html">consistent-state</a> checking will guarantee it. However in a hardware
;    implementation, doing int-fix or uint-fix may not have efficency problem.
; 
; BCV:
;   array type, 
;
;   in fact, small array test.
;   guarantee it is boolean or byte array or null
;
; Informal Proof:
;   Invariant about more general 
;   and more general here is same 
;
;---------------------------------------------------------------------
</span>

<span class="comment">;---------------------------------------------------------------------
; BASTORE 
;
;; call i-fix etc.
</span>(<span class="keyword">defun</span> <span class="function-name">execute-BASTORE</span> (<a href="../DJVM/INST/inst.lisp.html">inst</a> s) 
  (<span class="keyword">let*</span> ((value (topStack s))
         (index (secondStack s))
         (array-ref (thirdStack s)))
    (<span class="keyword">if</span> (CHECK-NULL array-ref)
        (raise-exception <span class="string">"java.lang.NullPointerException"</span> s)
      (<span class="keyword">if</span> (check-array array-ref index s)
          (<span class="keyword">let</span> ((array-type (array-ref-type array-ref s)))
            (<span class="keyword">if</span> (equal array-type '(array boolean))
                (ADVANCE-PC (popStack 
                             (popStack 
                              (popStack (set-element-at-array index (u-fix value 1) array-ref s)))))
               (ADVANCE-PC (popStack 
                             (popStack 
                              (popStack (set-element-at-array index (byte-fix value) array-ref s)))))))
        (raise-exception <span class="string">"java.lang.ArrayIndexOutOfBoundsException"</span> s)))))

<span class="comment">;
; NOTE: 
;   
;   no byte value on stack or in the local. They are treated as normal
;   integers. When store happens, chop the low bits into bytes and packged in
;   the array. 
; 
;   Special handling of boolean type and actual byte type. 
;
; Defensive: 
;
;   check either array of boolean or array of byte or null
;   link AASTORE, check ARRAY TYPE, index type. number of arguments
;   no defensive will assume if not boolean, then it is byte array. 
;
; BCV:
;
; Informal Proof:
;    
;    BCV test and Defensive test are the same. (assuming BCV type is more
;    general).
;
;---------------------------------------------------------------------
</span>
<span class="comment">;---------------------------------------------------------------------
; BIPUSH 
</span>
(<span class="keyword">defun</span> <span class="function-name">execute-BIPUSH</span> (<a href="../DJVM/INST/inst.lisp.html">inst</a> s)
  (ADVANCE-PC (pushStack (byte-fix (arg <a href="../DJVM/INST/inst.lisp.html">inst</a>)) s)))


<span class="comment">; NOTE: byte-fix may not be necessary, guaranteed by correctness of jvm2acl2
;       which should never generate a larger int.
;
; Defensive: 
;      stack limit. 
;
; BCV:
;      stack limit checked. 
;
; Informal Proof:
;      
;     same stack limit check. invariant guarantee the stack of the same size.
;   
;---------------------------------------------------------------------
</span>
<span class="comment">;---------------------------------------------------------------------
;-------------------------        C         --------------------------
;---------------------------------------------------------------------
</span>
<span class="comment">;---------------------------------------------------------------------
; CALOAD 
;
</span>

(<span class="keyword">defun</span> <span class="function-name">execute-CALOAD</span> (<a href="../DJVM/INST/inst.lisp.html">inst</a> s)
  (<span class="keyword">let*</span> ((index (topStack s))
         (array-ref (secondStack s)))
    (<span class="keyword">if</span> (CHECK-NULL array-ref)
        (raise-exception <span class="string">"java.lang.NullPointerException"</span> s)
      (<span class="keyword">if</span> (check-array array-ref index s)
          (ADVANCE-PC (pushStack (uint-fix (element-at-array index array-ref s))
                                 (popStack (popStack s))))
      (raise-exception <span class="string">"java.lang.ArrayIndexOutOfBoundsException"</span> s)))))

<span class="comment">;
; NOTE:
;
;   check-array only check array access bound? 
;   assuming the array-ref point to a valid array object
;   in a valid array of char, zero-extend does not matter.
;  
; Defensive: 
;
;   check array type is null or (array char) check invariant?  (should we check
;   invariant all the time, should we prove that adequate check perserves the
;   invariant)
;
; BCV:
;   check array type (null or array of char)
; Informal Proof:
;
;;---------------------------------------------------------------------
</span>
<span class="comment">;---------------------------------------------------------------------
; CASTORE
</span>
(<span class="keyword">defun</span> <span class="function-name">execute-CASTORE</span> (<a href="../DJVM/INST/inst.lisp.html">inst</a> s)
  (<span class="keyword">let*</span> ((value (topStack s))
         (index (secondStack s))
         (array-ref (thirdStack s)))
    (<span class="keyword">if</span> (CHECK-NULL array-ref)
        (raise-exception <span class="string">"java.lang.NullPointerException"</span> s)
      (<span class="keyword">if</span> (check-array array-ref index s)
          (prog2$ (acl2::debug-print <span class="string">"here"</span>)
          (ADVANCE-PC (popStack 
                       (popStack 
                         (popStack (set-element-at-array index (char-fix value) array-ref s))))))
      (raise-exception <span class="string">"java.lang.ArrayIndexOutOfBoundsException"</span> s)))))

<span class="comment">; NOTE: 
;
;  basically we want the same structure in defensive machine check and <a href="../BCV/typechecker.lisp.html">typechecker</a> check 
;  
;  and prove canPop in typechecker.lisp implies canPop in defensive machine on
;  a more specific input.
;  
; Defensive: 
;
;   Check the index is of type integer, array-ref is a array ref or null, value is int type.
;
;
; BCV:
;
; Informal Proof:
;
;
;---------------------------------------------------------------------
</span>

<span class="comment">;---------------------------------------------------------------------
; CHECKCAST
;
</span>(<span class="keyword">defun</span> <span class="function-name">execute-checkcast</span> (<a href="../DJVM/INST/inst.lisp.html">inst</a> s)
  (<span class="keyword">let*</span> ((toClass (normalize-type-rep (arg <a href="../DJVM/INST/inst.lisp.html">inst</a>)))
         (new-s   (resolveClassReference toClass s))
         <span class="comment">;; our resolveClassReference is a bit strange in that it doesn't
</span>         <span class="comment">;; actually returns the reference to the class, instead it returns a
</span>         <span class="comment">;; new state. in which class-by-name will give you the representation.
</span>         (obj-ref (topStack s)))
    (<span class="keyword">if</span> (pending-exception new-s)
        (raise-exception (pending-exception new-s) s)
      <span class="comment">;; possible class not found, access permission etc. 
</span>      (<span class="keyword">if</span> (no-fatal-error? new-s)
          (<span class="keyword">if</span> (CHECK-NULL obj-ref)
              (ADVANCE-PC new-s)
            (mv-let (ret new-s2)
                    (isAssignableTo (obj-type (binding obj-ref (heap new-s)))
                                    toClass
                                    new-s)
                    (<span class="keyword">if</span> ret 
                        (ADVANCE-PC new-s2)
                      (raise-exception <span class="string">"java.lang.ClassCastException"</span> new-s2))))
        new-s))))

<span class="comment">; resolveClassReference does not throw any exception, it set fatal error flags.
; This implementation does not throw any exception during resolution. Maybe
; people are not interested in it. (concerning the correctness of the bytecode verifier)
; 
; FIXED. August 13th. 2003
; 
; NOTE:
;
;    CHECKCAST will cause class resoltuion at the runtime. 
;    instruction should check whether exception is thrown during resolution  
;  
; Defensive: 
; 
;  Even defensive machine does not need to guarantee the symbolic references
;  Refers to some class. the exception is treated as an exception.
;  
;  check the value on top of the stack is a reference   
;
; BCV:
;
;  check the value on stack is a reference 
;  
; Informal Proof:
;  
;  same check at BCV time and defensive time. 
;
;---------------------------------------------------------------------
</span>

<span class="comment">;---------------------------------------------------------------------
;-------------------------        D         --------------------------
;---------------------------------------------------------------------
</span>
<span class="comment">;---------------------------------------------------------------------
; D2F 
; D2I 
; D2L 
; DADD
; DALOAD
; DASTORE
; DCMP
; DCONST_0
; DCONST_1
; DDIV
; DLOAD
; DLOAD_0
; DLOAD_1
; DLOAD_2
; DLOAD_3
; DMUL
; DNEG
; DREM
; DRETURN -- is return with 2 things current method must have a double
; DSTORE
; DSTORE_0
; DSTORE_1
; DSTORE_2
; DSTORE_3
; DSUB
;
; Above Not Implemented -----------------------------------------------
</span>
<span class="comment">;---------------------------------------------------------------------
;  DUP  
</span>
(<span class="keyword">defun</span> <span class="function-name">execute-DUP</span> (<a href="../DJVM/INST/inst.lisp.html">inst</a> s)
  (ADVANCE-PC (pushStack (topStack s) s)))

<span class="comment">; NOTE: 
;
; Defensive: 
;
;    Category 1 type on top
;    enough stack space 
;
; BCV:
;    Category 1 type on top    
;    enough op stack 
;    
; Informal Proof:
;    Same 
;---------------------------------------------------------------------
</span>
<span class="comment">;---------------------------------------------------------------------
;
</span>
(<span class="keyword">defun</span> <span class="function-name">execute-DUP_X1</span> (<a href="../DJVM/INST/inst.lisp.html">inst</a> s)
  (ADVANCE-PC (pushStack (topStack s)
                         (pushStack (secondStack s)
                                    (pushStack (topStack s)
                                               (popStack (popStack s)))))))

<span class="comment">;
; NOTE:  
;        
; Defensive: 
;   check category 1 type. (category 1 type occupies one slot)
;
; BCV:
;
; Informal Proof:
;
;
;---------------------------------------------------------------------
</span>

<span class="comment">;---------------------------------------------------------------------
</span>
(<span class="keyword">defun</span> <span class="function-name">execute-DUP_X2</span> (<a href="../DJVM/INST/inst.lisp.html">inst</a> s)
  (ADVANCE-PC (pushStack (topStack s)
                (pushStack (secondStack s)
                   (pushStack (thirdStack s)
                       (pushStack (topStack s)
                             (popStack (popStack (popStack s)))))))))

<span class="comment">; NOTE:
;
; Defensive: 
;
; BCV:
;
; Informal Proof:
;---------------------------------------------------------------------
</span>
<span class="comment">;---------------------------------------------------------------------
;
</span>
(<span class="keyword">defun</span> <span class="function-name">execute-DUP2</span> (<a href="../DJVM/INST/inst.lisp.html">inst</a> s)
  (ADVANCE-PC (pushStack (topStack s)
                         (pushStack (secondStack s) s))))

<span class="comment">; NOTE:
;
; Defensive: 
;          form1 2 category 1
;          form2 1 category 2
; BCV:
;
; Informal Proof:
;
;---------------------------------------------------------------------
</span>

<span class="comment">;---------------------------------------------------------------------
</span>(<span class="keyword">defun</span> <span class="function-name">execute-DUP2_X1</span> (<a href="../DJVM/INST/inst.lisp.html">inst</a> s)
  (ADVANCE-PC (pushStack (topStack s)
                (pushStack (secondStack s)
                   (pushStack (thirdStack s)
                       (pushStack (topStack s)
                           (pushStack (secondStack s)
                                (popStack (popStack (popStack s))))))))))

<span class="comment">; NOTE:
;
; Defensive: 
;
;
; BCV:
;
; Informal Proof:
;
;---------------------------------------------------------------------
</span>

<span class="comment">;---------------------------------------------------------------------
;
</span>(<span class="keyword">defun</span> <span class="function-name">execute-DUP2_X2</span> (<a href="../DJVM/INST/inst.lisp.html">inst</a> s)
  (ADVANCE-PC (pushStack (topStack s)
                 (pushStack (secondStack s)
                      (pushStack (thirdStack s)
                          (pushStack (fourthStack s)
                              (pushStack (topStack s)
                                  (pushStack (secondStack s) 
                                        (popStack (popStack (popStack (popStack s))))))))))))
       

<span class="comment">; NOTE:
;
; Defensive: 
;   form1 form2 form3 form4
;
; BCV:
;
; Informal Proof:
;
;---------------------------------------------------------------------
</span>
<span class="comment">;---------------------------------------------------------------------
;-------------------------        F         --------------------------
;---------------------------------------------------------------------
</span>
<span class="comment">;---------------------------------------------------------------------
; F2D 
; F2I 
; F2L 
; FADD
; FALOAD
; FASTORE
; FCMPG
; FCMPL
; FCONST_0
; FCONST_1
; FCONST_2
; FDIV
; FLOAD
; FLOAD_0
; FLOAD_1
; FLOAD_2
; FLOAD_3
; FMUL
; FNEG
; FREM
; FRETURN -- is return with 2 things current method must have a double
; FSTORE
; FSTORE_0
; FSTORE_1
; FSTORE_2
; FSTORE_3
; FSUB
;
; Above Not Implemented -----------------------------------------------
</span>

<span class="comment">;---------------------------------------------------------------------
;-------------------------        G         --------------------------
;---------------------------------------------------------------------
</span>
<span class="comment">;---------------------------------------------------------------------
; <a href="../DJVM/INST/GETFIELD.lisp.html">GETFIELD</a> 
; 
</span>
<span class="comment">;; (defun field-size (field-rep) 
;;   (type-size (field-fieldtype field-rep)))
</span>
<span class="comment">;; Sun May 16 17:17:15 2004. moved to jvm-bytecode.lisp
;; guard verification is skipped in jvm-bytecode-guard-verification.lisp
</span>
(<span class="keyword">defun</span> <span class="function-name">execute-getfield1</span> (field-rep s)
  (<span class="keyword">let*</span> ((obj-ref   (topStack s))
         (classname (field-classname field-rep))
         (fieldname (field-fieldname field-rep))
         (value     (m6-getfield classname fieldname obj-ref s)))
         (<span class="keyword">if</span> (CHECK-NULL obj-ref)
             <span class="comment">;;(raise-exception "java.lang.NullPointerException" s)
</span>             (state-set-pending-exception-safe <span class="string">"java.lang.NullPointerException"</span> s)
           (<span class="keyword">if</span> (equal (field-size field-rep) 2)
               (pushLong value (popStack s))
             (pushStack value (popStack s))))))
           


<span class="comment">;; (defun fatalSlotError (fieldCP s)
;;   (declare (ignore fieldCP))
;;   (fatalError "field not found" s))
</span>
<span class="comment">;; moved to jvm-bytecode.lisp
;; Sun May 16 17:17:52 2004
</span>

(<span class="keyword">defun</span> <span class="function-name">execute-getfield</span> (<a href="../DJVM/INST/inst.lisp.html">inst</a> s)
    (<span class="keyword">let*</span> ((fieldCP (arg <a href="../DJVM/INST/inst.lisp.html">inst</a>)))
    (mv-let (field-rep new-s)
            (resolveFieldReference fieldCP s)
            (<span class="keyword">if</span> (not (no-fatal-error? new-s))
                new-s
              (<span class="keyword">if</span> (pending-exception s)
                  (raise-exception (pending-exception s) s)
                (<span class="keyword">if</span> field-rep  <span class="comment">;; if resolve failed, field-rep is nil
</span>                    (<span class="keyword">let</span> ((new-s2 (execute-getfield1 field-rep new-s)))
                      (<span class="keyword">if</span> (pending-exception new-s2)
                          (raise-exception (pending-exception new-s2) new-s2)
                        (ADVANCE-PC new-s2)))
                  (fatalSlotError fieldCP new-s)))))))



<span class="comment">;;; We know that resolveClassReference will not thrown exception..
;;; .... resolveFieldReference may be. (in fact, it will only thrown 
;;; an exception 
</span>

<span class="comment">; NOTE:
;    
; This implementation does not throw exception properly. 
; FIXED: August 13, 2003.        
;
; Defensive: 
;   check access permission. 
;
;     1) from the current class to the resolved class
;
;     2) from the current object to the resolved class 
;          if resolved class is a superclass of the current class
;          the resolved field is protected
;          current class is not in the same package
;
;             ensure current object is an instance of the current class or an
;             instance of a subclass of the current class.
; 
;   check the object used to get the field, is an instance assignable to the
;   class. (whether it is accessible is not checked)
;   
;   IN FACT, WE ARE ALLOWED TO ACCESS THE PRIVATED MEMBER OF A SUPERCLASS  
;   AS LONG AS THE ACCESS HAPPENS IN a METHOD of A SUPERCLASS.
;
;   One can pass a reference/pointer to a object of type A to a method of B'
;   where B happens to be A's superclass. In that method, we could use the
;   reference to access the private field of that object. 
; 
;   This is getfield, in case of invokevirtual, defensive machine needs check
;   the object has access to the method to be invoked (?) NO. THIS IS NOT
;   Necessary.  We can use an object of subclass and invoke a private method of
;   a superclass. (quite unexpected?) (This is prevented by the JVM spec but
;   not enforced by JVM implementation. The problem is that JVM may not want to
;   enforce this, because getting rid of this is a performance improvement, and
;   can still provide the guarantee.) ACCESS CONTROL is only checked from
;   CURRENT CLASS to the RESOLVED CLASS. (the look up procedure in invokevirtual
;   find the first accessible method with the right sig to the class of the
;   object. MAYBE not necessary, however the JVM implementation does not
;   enforce it. How about Java Language Spec?)
;   
;   Assuming resolution succeed, the current class has to
;    
;   check whether it is not an array type. (this can be the part that are
;   checked at runtime, but the bytecode verifier can check for it.)
;
; BCV: 
;
;   Enforce the protected check. semms to need to rely on the resolution to be
;   correct. If protected and not same package, then enforcing the type of
;   objref is a subclass of current class.
;
;   check not array type, null or a class type.
;     
; Informal Proof:
;
;   BCV, DJVM checks are same?? YES. same, resolution is the from the same
;   class.  No. BCV + M6 + properties of resolveXXX implies DJVM DJVM may
;   detect need to make sure resolveXXX cause an fatal error that are checked
;   by both the DJVM and the M6. If error at resolution time, error at both M6
;   and Defensive machine. (Mmm. I have forgot my plan for how to deal with
;   resolution issue. I seemed to assumed that one will not thrown exception
;   during resolution, but set the fatal error flag. However with the access
;   control stuff (in Summer, 2003) I decided to add the exception facility at
;   this stage (which CLDC may not be supporting). Anyway, the actual run of a
;   JVM need an arbitary scheduler and allow arbitary exception being thrown at
;   any point ..... BCV will still guarantee that non defensive machine will
;   behave similarly.)
;  
;---------------------------------------------------------------------
</span>

<span class="comment">;---------------------------------------------------------------------
</span>
<span class="comment">;; (defun static-field-size (static-field-rep)
;;   (type-size (static-field-fieldtype static-field-rep)))
</span>

(<span class="keyword">defun</span> <span class="function-name">execute-getstatic1</span> (field-rep s)
  (<span class="keyword">if</span> (equal (static-field-size field-rep) 2)
      (pushLong (static-field-fieldvalue field-rep) s)
    (pushStack (static-field-fieldvalue field-rep) s)))
               

<span class="comment">;; (defun static-field-class-rep (static-field-rep s)
;;   (class-by-name (static-field-classname static-field-rep)
;;                  (instance-class-table s)))
;;
;; in jvm-linker.lisp
</span>
<span class="comment">;;
;; no need to check access. because our access is checked in the
;; resovleStaticFieldReferences.
;; should defensive check for access explicitly? And we show that check is not
;; necessary because the exact same check is done at the runtime by the resol 
;;
</span>
(<span class="keyword">defun</span> <span class="function-name">execute-getstatic</span> (<a href="../DJVM/INST/inst.lisp.html">inst</a> s)
  (<span class="keyword">let*</span> ((fieldCP   (arg <a href="../DJVM/INST/inst.lisp.html">inst</a>)))
         (mv-let (field-rep new-s)
                 (resolveStaticFieldReference fieldCP s) <span class="comment">;; atomic operation. 
</span>                 (<span class="keyword">if</span> (pending-exception s)
                     (raise-exception (pending-exception s) s)
                   (<span class="keyword">if</span> field-rep
                       (<span class="keyword">let*</span> ((field-class-rep (static-field-class-rep field-rep new-s))
                              (fclassname      (classname field-class-rep)))
                         (<span class="keyword">if</span> (not (class-initialized? fclassname  new-s))
                             (reschedule (initializeClass fclassname new-s))
                           <span class="comment">;; re-execute the same instruction. 
</span>                           (<span class="keyword">if</span> (class-rep-in-error-state? field-class-rep) 
                               (fatalError <span class="string">"initialized class expected"</span> new-s)
                             (ADVANCE-PC (execute-getstatic1 field-rep new-s))))) <span class="comment">;; only here advance pc
</span>                     (fatalSlotError fieldCP new-s))))))

<span class="comment">; NOTE:
;  
;    Current resolveXXX does not check for access permissions now.  Because of
;    this, a defensive machine can not be guaranteed to never access a protected
;    member. (same with getfield). Check access control
;    
;    FIXED.  08/14/03 
;  
; Defensive: 
;    
;    check well formedness of a class rep? (this is implied by other parts)
;    bytecode verifier can't guarantee this. the combination of bcv + correct
;    jvm implementation guarantee well-formedness of a class rep.  do we want
;    to check for it?  Do we check for consistent-state, before doing any
;    defensive machine step?  this is part of the big <a href="../DJVM/consistent-state.lisp.html">consistent-state</a>
;    invariant, providing step safe machine preserve the invariant.
; 
;    If we don't check <a href="../DJVM/consistent-state.lisp.html">consistent-state</a> every step, we proved <a href="../DJVM/consistent-state.lisp.html">consistent-state</a>
;    is preserved. Then this will be good. Goal One
;    
;    If we check <a href="../DJVM/consistent-state.lisp.html">consistent-state</a> every step, stop proceeding if next step
;    causes an error, Goal One is trivial. However to prove defensive == non
;    defensive + BCV still give us the obligation to prove step preserve
;    consistency.
;
;    That's probably what we want to do. NO. I want the first approach.
;    08/14/03 the decision is NOT (08/14/03) to put <a href="../DJVM/consistent-state.lisp.html">consistent-state</a> predicate
;    in every defensive.  check every assumption. for example, successful
;    resolution returns a field has matching sig and accessible permission from
;    the current class.
;    
; BCV:
;
;    check getstatic is very simple. 
;    check getfield is more elaborated.  
;  
; Informal Proof:
;
;---------------------------------------------------------------------
</span>
<span class="comment">;---------------------------------------------------------------------
</span>
(<span class="keyword">defun</span> <span class="function-name">execute-GOTO</span> (<a href="../DJVM/INST/inst.lisp.html">inst</a> s)
  (state-set-pc (arg <a href="../DJVM/INST/inst.lisp.html">inst</a>) s))

<span class="comment">; NOTE: 
;
;    Goto to an offset in bytecode 
;
; Defensive: 
;     
;    target is a place where an instruction starts.  
;  
;
; BCV:
;    check the same thing. 
;    
; Informal Proof:
;
;   (invariant: program code does not change) ==&gt; both checks are exactly the same
;   
;---------------------------------------------------------------------
</span>
<span class="comment">;---------------------------------------------------------------------
;
; GOTO_W   This is eliminated by jvm2acl2, guarantee to not appear.
;  
</span>

<span class="comment">;---------------------------------------------------------------------
;I2B ;   should be implemented
; 
</span>(<span class="keyword">defun</span> <span class="function-name">execute-I2B</span> (<a href="../DJVM/INST/inst.lisp.html">inst</a> s)
  (ADVANCE-PC (pushStack (byte-fix (topStack s))
                         (popStack s))))

<span class="comment">; NOTE:
;   
;   check type and value is intp (however in M5 this can never be false? ("what
;   this mean?  08/14/03) 
</span>
<span class="comment">;   anything on opstack is int or a long (not particular byte, boolean or char
;   type)
;   
;   need to distinguish between Long and ReturnAddress and Int (byte, char, boolean)
;   
; Defensive: 
;
;   check the flag, when push a byte, push an int instead.
;
; BCV:
;
; Informal Proof:
;
;---------------------------------------------------------------------
</span>


<span class="comment">;---------------------------------------------------------------------
;I2C ;   should implement these...
</span>(<span class="keyword">defun</span> <span class="function-name">execute-I2C</span> (<a href="../DJVM/INST/inst.lisp.html">inst</a> s)
  (ADVANCE-PC (pushStack (char-fix (topStack s))
                         (popStack s))))

<span class="comment">; NOTE:
;
; Defensive: 
;
;
; BCV:
;
; Informal Proof:
;
;---------------------------------------------------------------------
</span>
<span class="comment">;I2D
;I2F
;I2L ;  should be implemented   
</span>
<span class="comment">;---------------------------------------------------------------------
;
</span>
(<span class="keyword">defun</span> <span class="function-name">execute-I2L</span> (<a href="../DJVM/INST/inst.lisp.html">inst</a> s)
  (ADVANCE-PC (pushLong (long-fix (topStack s))
                        (popStack s))))

<span class="comment">; NOTE:
;
;   PUSH a long, need to check the limited on max stack
;
; Defensive: 
;
;
; BCV:
;
; Informal Proof:
;
;
;---------------------------------------------------------------------
</span>
<span class="comment">;---------------------------------------------------------------------
</span>(<span class="keyword">defun</span> <span class="function-name">execute-I2S</span> (<a href="../DJVM/INST/inst.lisp.html">inst</a> s)
  (ADVANCE-PC (pushStack  (short-fix (topStack s))
                          (popStack s))))
<span class="comment">; NOTE:
;
; Defensive: 
;
;
; BCV:
;
; Informal Proof:
;
;
;---------------------------------------------------------------------
</span>

<span class="comment">;---------------------------------------------------------------------
;  IADD
</span>
(<span class="keyword">defun</span> <span class="function-name">execute-IADD</span> (<a href="../DJVM/INST/inst.lisp.html">inst</a> s)
  (<span class="keyword">let</span> ((v1 (topStack s))
        (v2 (secondStack s)))
    (ADVANCE-PC (pushStack  (int-fix (+ v1 v2)) 
                            (popStack (popStack s))))))

<span class="comment">; NOTE:
;     Not much interesting
;
; Defensive: 
;
;    check type, number of argument, resulting stack 
;    check next PC 
;
; BCV:
;    same thing.
;    
; Informal Proof:
;    invariant, DJVM frame, matches the BCV frame
;    BCV frame is just more general type
;
;---------------------------------------------------------------------
</span>


<span class="comment">;---------------------------------------------------------------------
;
</span>(<span class="keyword">defun</span> <span class="function-name">execute-IALOAD</span> (<a href="../DJVM/INST/inst.lisp.html">inst</a> s)
  (<span class="keyword">let*</span> ((index (topStack s))
         (array-ref (secondStack s)))
    (<span class="keyword">if</span> (CHECK-NULL array-ref)
        (raise-exception <span class="string">"java.lang.NullPointerException"</span> s)
      (<span class="keyword">if</span> (check-array array-ref index s)
          (ADVANCE-PC (pushStack (element-at-array index array-ref s)
                                (popStack (popStack s))))
        (raise-exception <span class="string">"java.lang.ArrayIndexOutOfBoundsException"</span> s)))))

<span class="comment">; NOTE:
;    See discussion in <a href="../DJVM/INST/AALOAD.lisp.html">AALOAD</a>
;  
; Defensive: How explict we want defensive machine be?  In consistent state, if
;
;    we know a type has an outer '(ARRAY' we know its component type is valid.
;    So if we put consistent state in each instruction, we know checking array
;    has an outer "array" array is adequate to know its component type is
;    valid.
;    Similarly is (REF values). In a consistent state, we know if a REF is
;    bounded, the object that it points to are consistent.
;    
;    Consistent heap object make sure an object refers to an object that is
;    consistent with its field declaration. 
;
; BCV:
;
; Informal Proof:
;
;
;---------------------------------------------------------------------
</span>
<span class="comment">;---------------------------------------------------------------------
; 
;  IAND 
</span>
(<span class="keyword">defun</span> <span class="function-name">execute-IAND</span> (<a href="../DJVM/INST/inst.lisp.html">inst</a> s)
  (<span class="keyword">let</span> ((v1 (topStack s))
        (v2 (secondStack s)))
    (ADVANCE-PC (pushStack  (int-fix (logand v1 v2))
                            (popStack (popStack s))))))

<span class="comment">; NOTE:
;
;     Assuming v1, v2 are integers, logand returns bitwise AND logand always
;     return a value in range so there is no need to give a int-fix
;
; Defensive: 
;
;     check intp, intp. implication is the returning value is a 32 bit int.
;     
;
; BCV:
;
; Informal Proof:
;
;
;---------------------------------------------------------------------
</span>

<span class="comment">;---------------------------------------------------------------------
;
;  IASTORE 
</span>
(<span class="keyword">defun</span> <span class="function-name">execute-IASTORE</span> (<a href="../DJVM/INST/inst.lisp.html">inst</a> s)
  (<span class="keyword">let*</span> ((value (topStack s))
         (index (secondStack s))
         (array-ref (thirdStack s)))
    (<span class="keyword">if</span> (CHECK-NULL array-ref)
        (raise-exception <span class="string">"java.lang.NullPointerException"</span> s)
      (<span class="keyword">if</span> (check-array array-ref index s)
          (ADVANCE-PC (popStack 
                       (popStack 
                         (popStack (set-element-at-array index value array-ref s)))))
      (raise-exception <span class="string">"java.lang.ArrayIndexOutOfBoundsException"</span> s)))))

<span class="comment">; NOTE:
;
;   This instruction is like AASTORE, need to check whether the array is an ARRAY of INT, value
;   on stack is an INT. It also need to ocheck whether bounds are ok
;
; Defensive: 
;     
;    
;
; BCV:
;  
;  Notice: valid state transition is from (int int (Array int) ... ) to (...)
;  In fact, (int int null) is allowed. (one path can reach an array instruction
;  does not mean we should reject this bytecode, maybe it is possible at run
;  time this path is never taken. So null is needed. 
;  
; Informal Proof:
;
;  Same check. 
;  
;---------------------------------------------------------------------
</span>

<span class="comment">;---------------------------------------------------------------------
</span>
(<span class="keyword">defun</span> <span class="function-name">execute-ICONST_M1</span> (<a href="../DJVM/INST/inst.lisp.html">inst</a> s)
  (ADVANCE-PC (pushStack -1 s)))

(<span class="keyword">defun</span> <span class="function-name">execute-ICONST_0</span> (<a href="../DJVM/INST/inst.lisp.html">inst</a> s)
  (ADVANCE-PC (pushStack 0 s)))

(<span class="keyword">defun</span> <span class="function-name">execute-ICONST_1</span> (<a href="../DJVM/INST/inst.lisp.html">inst</a> s)
  (ADVANCE-PC (pushStack 1 s)))

(<span class="keyword">defun</span> <span class="function-name">execute-ICONST_2</span> (<a href="../DJVM/INST/inst.lisp.html">inst</a> s)
  (ADVANCE-PC (pushStack 2 s)))

(<span class="keyword">defun</span> <span class="function-name">execute-ICONST_3</span> (<a href="../DJVM/INST/inst.lisp.html">inst</a> s)
  (ADVANCE-PC (pushStack 3 s)))

(<span class="keyword">defun</span> <span class="function-name">execute-ICONST_4</span> (<a href="../DJVM/INST/inst.lisp.html">inst</a> s)
  (ADVANCE-PC (pushStack 4 s)))

(<span class="keyword">defun</span> <span class="function-name">execute-ICONST_5</span> (<a href="../DJVM/INST/inst.lisp.html">inst</a> s)
  (ADVANCE-PC (pushStack 5 s)))

<span class="comment">; NOTE:
;
;   only check minimum: Stack limit, PC in range.
;
; Defensive: 
;
;
; BCV:
;
; Informal Proof:
;        
;   Checks are same, if defensive state are in sync with BCV state. (same
;   number of values on op stack. (in sync invariant, maybe part of more
;   general state predicate. 
; 
;---------------------------------------------------------------------
</span>
<span class="comment">;---------------------------------------------------------------------
;
;
</span>
(<span class="keyword">defun</span> <span class="function-name">execute-IDIV</span> (<a href="../DJVM/INST/inst.lisp.html">inst</a> s)
  (<span class="keyword">let</span> ((v2 (topStack s))
        (v1 (secondStack s)))
    (<span class="keyword">if</span> (equal v2 0)
        (raise-exception <span class="string">"java.lang.ArithmeticException"</span> s)
      (ADVANCE-PC (pushStack  (int-fix (truncate v1 v2))
                              (popStack (popStack s)))))))

<span class="comment">; NOTE:
;
; Defensive: 
;
;
; BCV:
;
; Informal Proof:
;
;
;---------------------------------------------------------------------
</span>
(<span class="keyword">defmacro</span> <span class="function-name">BRANCHIF</span> (<span class="keyword">cond</span>) 
  `(<span class="keyword">if</span> ,cond 
       (state-set-pc (arg <a href="../DJVM/INST/inst.lisp.html">inst</a>) 
                     (popStack s))
     (ADVANCE-PC (popStack s))))


(<span class="keyword">defmacro</span> <span class="function-name">BRANCHIF2</span> (<span class="keyword">cond</span>) 
  `(<span class="keyword">if</span> ,cond 
       (state-set-pc (arg <a href="../DJVM/INST/inst.lisp.html">inst</a>) 
                     (popStack (popStack s)))
     (ADVANCE-PC (popStack (popStack s)))))



<span class="comment">;---------------------------------------------------------------------
</span>
<span class="comment">; IF_ACMPEQ
</span>
(<span class="keyword">defun</span> <span class="function-name">execute-IF_ACMPEQ</span> (<a href="../DJVM/INST/inst.lisp.html">inst</a> s)
  (BRANCHIF2 (equal (topStack s) (secondStack s))))


<span class="comment">; NOTE:
;
; Defensive: 
;    CHECK reference type.
;
; BCV:
;
; Informal Proof:
;
;
;---------------------------------------------------------------------
</span>
<span class="comment">;---------------------------------------------------------------------
;
</span>
(<span class="keyword">defun</span> <span class="function-name">execute-IF_ACMPNE</span> (<a href="../DJVM/INST/inst.lisp.html">inst</a> s)
  (BRANCHIF2 (not (equal (topStack s) (secondStack s)))))

<span class="comment">; NOTE:
;
; Defensive: 
;
;
; BCV:
;
; Informal Proof:
;
;
;---------------------------------------------------------------------
</span>
<span class="comment">;---------------------------------------------------------------------
</span>
(<span class="keyword">defun</span> <span class="function-name">execute-IF_ICMPEQ</span> (<a href="../DJVM/INST/inst.lisp.html">inst</a> s)
  (BRANCHIF2 (= (topStack s) (secondStack s))))

(<span class="keyword">defun</span> <span class="function-name">execute-IF_ICMPNE</span> (<a href="../DJVM/INST/inst.lisp.html">inst</a> s)
  (BRANCHIF2 (not (= (topStack s) (secondStack s)))))

(<span class="keyword">defun</span> <span class="function-name">execute-IF_ICMPLT</span> (<a href="../DJVM/INST/inst.lisp.html">inst</a> s)
  (BRANCHIF2 (&lt; (secondStack s) (topStack s))))

(<span class="keyword">defun</span> <span class="function-name">execute-IF_ICMPGE</span> (<a href="../DJVM/INST/inst.lisp.html">inst</a> s)
  (BRANCHIF2 (&gt;= (secondStack s) (topStack s))))

(<span class="keyword">defun</span> <span class="function-name">execute-IF_ICMPGT</span> (<a href="../DJVM/INST/inst.lisp.html">inst</a> s)
  (BRANCHIF2 (&gt; (secondStack s) (topStack s))))

(<span class="keyword">defun</span> <span class="function-name">execute-IF_ICMPLE</span> (<a href="../DJVM/INST/inst.lisp.html">inst</a> s)
  (BRANCHIF2 (&lt;= (secondStack s)  (topStack s))))

<span class="comment">; NOTE:
;
; Defensive: 
;
;
; BCV:
;
; Informal Proof:
;
;
;---------------------------------------------------------------------
</span>


<span class="comment">;---------------------------------------------------------------------
;; because the branch address is already resovlved
</span>
(<span class="keyword">defun</span> <span class="function-name">execute-IFEQ</span> (<a href="../DJVM/INST/inst.lisp.html">inst</a> s)
  (BRANCHIF (= (topStack s) 0)))

(<span class="keyword">defun</span> <span class="function-name">execute-IFNE</span> (<a href="../DJVM/INST/inst.lisp.html">inst</a> s)
  (BRANCHIF (not (= (topStack s) 0))))

(<span class="keyword">defun</span> <span class="function-name">execute-IFLT</span> (<a href="../DJVM/INST/inst.lisp.html">inst</a> s)
  (BRANCHIF  (&lt; (topStack s) 0)))

(<span class="keyword">defun</span> <span class="function-name">execute-IFGE</span> (<a href="../DJVM/INST/inst.lisp.html">inst</a> s)
  (BRANCHIF  (&gt;= (topStack s) 0)))

(<span class="keyword">defun</span> <span class="function-name">execute-IFGT</span> (<a href="../DJVM/INST/inst.lisp.html">inst</a> s)
  (BRANCHIF  (&gt; (topStack s) 0)))

(<span class="keyword">defun</span> <span class="function-name">execute-IFLE</span> (<a href="../DJVM/INST/inst.lisp.html">inst</a> s)
  (BRANCHIF  (&lt;= (topStack s) 0)))


<span class="comment">;
; NOTE:
;
;  Branch is already resolved. In our branch instruction
;  offset is already added. 
;
; Defensive: 
;
;
; BCV:
;
; Informal Proof:
;
; 
;
;---------------------------------------------------------------------
</span>
<span class="comment">;---------------------------------------------------------------------
</span>
(<span class="keyword">defun</span> <span class="function-name">execute-ifnonnull</span> (<a href="../DJVM/INST/inst.lisp.html">inst</a> s)
  (BRANCHIF (not (equal (topStack s) -1)))) <span class="comment">;; -1 is null
</span>
<span class="comment">; NOTE:  
;       Branch offset is already computed by JVM2ACL2
;
; Defensive: 
;       Check the reference type (including null type)
;
; BCV:
;
;       Same. 
;
; Informal Proof:
;      
;      need the invariant, BCV step produce more general type state than
;      Defensive machine
;
;---------------------------------------------------------------------
</span>    

<span class="comment">;---------------------------------------------------------------------
</span>
(<span class="keyword">defun</span> <span class="function-name">execute-ifnull</span> (<a href="../DJVM/INST/inst.lisp.html">inst</a> s)
  (BRANCHIF (equal (topStack s) -1))) <span class="comment">;; -1 is null
</span>
<span class="comment">; NOTE:
;
;    Same with ifnotnull
;
; Defensive: 
;
;
; BCV:
;
; Informal Proof:
;
;---------------------------------------------------------------------
</span>

<span class="comment">;---------------------------------------------------------------------
</span>
(<span class="keyword">defun</span> <span class="function-name">arg2</span> (<a href="../DJVM/INST/inst.lisp.html">inst</a>)
  (nth 2 (nth 1 <a href="../DJVM/INST/inst.lisp.html">inst</a>)))

(<span class="keyword">defun</span> <span class="function-name">execute-IINC</span> (<a href="../DJVM/INST/inst.lisp.html">inst</a> s)
  (<span class="keyword">let*</span> ((index (arg <a href="../DJVM/INST/inst.lisp.html">inst</a>))
         (value (arg2 <a href="../DJVM/INST/inst.lisp.html">inst</a>)))
   (ADVANCE-PC (SET-LP index (int-fix (+ (LLP index) value))))))

<span class="comment">; NOTE:
;
;   Increase local i by a const. do not change stack
;
; Defensive: 
;   
;   expect the local be of correct type. In op stack and local, boolean, short,
;   char are all treated as int.
;
; BCV:
;
; Informal Proof:
;
;
;---------------------------------------------------------------------
</span>

<span class="comment">;---------------------------------------------------------------------
</span>


(<span class="keyword">defun</span> <span class="function-name">execute-ILOAD</span> (<a href="../DJVM/INST/inst.lisp.html">inst</a> s)
  (ADVANCE-PC (pushStack (LLP (arg <a href="../DJVM/INST/inst.lisp.html">inst</a>)) s)))

(<span class="keyword">defun</span> <span class="function-name">execute-ILOAD_0</span> (<a href="../DJVM/INST/inst.lisp.html">inst</a> s)
  (ADVANCE-PC (pushStack (LLP 0) s)))

(<span class="keyword">defun</span> <span class="function-name">execute-ILOAD_1</span> (<a href="../DJVM/INST/inst.lisp.html">inst</a> s)
  (ADVANCE-PC (pushStack (LLP 1) s)))

(<span class="keyword">defun</span> <span class="function-name">execute-ILOAD_2</span> (<a href="../DJVM/INST/inst.lisp.html">inst</a> s)
  (ADVANCE-PC (pushStack (LLP 2) s)))

(<span class="keyword">defun</span> <span class="function-name">execute-ILOAD_3</span> (<a href="../DJVM/INST/inst.lisp.html">inst</a> s)
  (ADVANCE-PC (pushStack (LLP 3) s)))



<span class="comment">; NOTE:
;
; Defensive: 
;
;
; BCV:
;
; Informal Proof:
;
;
;---------------------------------------------------------------------
</span>

<span class="comment">;---------------------------------------------------------------------
;
</span>(<span class="keyword">defun</span> <span class="function-name">execute-IMUL</span> (<a href="../DJVM/INST/inst.lisp.html">inst</a> s)
  (<span class="keyword">let</span> ((v1 (topStack s))
        (v2 (secondStack s)))
    (ADVANCE-PC (pushStack  (int-fix (* v1 v2)) 
                            (popStack (popStack s))))))

<span class="comment">; NOTE:
;
; Defensive: 
;
;
; BCV:
;
; Informal Proof:
;
;
;---------------------------------------------------------------------
</span>
<span class="comment">;---------------------------------------------------------------------
</span>
(<span class="keyword">defun</span> <span class="function-name">execute-IMUL</span> (<a href="../DJVM/INST/inst.lisp.html">inst</a> s)
  (<span class="keyword">let</span> ((v1 (topStack s))
        (v2 (secondStack s)))
    (ADVANCE-PC (pushStack  (int-fix (* v1 v2)) 
                            (popStack (popStack s))))))

<span class="comment">; NOTE:
;
;    like  IADD 
;
; Defensive: 
;
;
; BCV:
;
; Informal Proof:
;
;
;---------------------------------------------------------------------
</span>


<span class="comment">;---------------------------------------------------------------------
</span>(<span class="keyword">defun</span> <span class="function-name">execute-INEG</span> (<a href="../DJVM/INST/inst.lisp.html">inst</a> s)
  (ADVANCE-PC (pushStack (- 0 (topStack s))
                         (popStack s))))

<span class="comment">; NOTE:
;
; Defensive: 
;
;
; BCV:
;
; Informal Proof:
;
;
;---------------------------------------------------------------------
</span>

<span class="comment">;---------------------------------------------------------------------
;
</span>(<span class="keyword">defun</span> <span class="function-name">execute-<a href="../DJVM/INST/inst.lisp.html">inst</a>anceof</span> (<a href="../DJVM/INST/inst.lisp.html">inst</a> s)
  (<span class="keyword">let*</span> ((toClass (arg <a href="../DJVM/INST/inst.lisp.html">inst</a>))
         (new-s   (resolveClassReference toClass s)) 
         (obj-ref (topStack s)))
    (<span class="keyword">if</span> (not (equal obj-ref -1))
        (mv-let (ret new-s2)
                (isAssignableTo (obj-type (binding obj-ref (heap new-s)))
                                toClass
                                new-s)
                (<span class="keyword">if</span> ret 
                    (ADVANCE-PC (popStack new-s2))
                  (raise-exception <span class="string">"java.lang.ClassCastException"</span> new-s2)))
      (ADVANCE-PC (popStack new-s)))))

<span class="comment">; NOTE:
;
;    This one will cause resolution and may cause class loading.  If format of
;    symbolic link must be right, but if the link points to something that does
;    not exists, not accessible, exception is thrown.
;
; Defensive: 
;   
;   Verify after resolution, if no exception, the field is in fact exists. 
;   And have accessible permission
;
; BCV:
; 
;   only check it is a reference type (has the format (class ...)) or null or
;   array... AssignableTo java.lang.Object. The real checking has to be done
;   using the runtime data. 
; 
; Informal Proof:
;
;   Defensive and non Defensive is the same.
;   In some sense, bytecode verifier does not need to check at all.
;   What does it saved? only catch some error early.
;
;---------------------------------------------------------------------
</span>
<span class="comment">;---------------------------------------------------------------------
</span>

(<span class="keyword">defun</span> <span class="function-name">method-rep-to-method-ptr</span> (method-rep)
  (make-method-ptr (method-classname method-rep)
                   (method-methodname method-rep)
                   (method-args       method-rep)
                   (method-returntype method-rep)))



(<span class="keyword">defun</span> <span class="function-name">call_method_general</span> (this-ref method s0 invokerSize)
  (<span class="keyword">let</span> ((accessflags (method-accessflags method))
        (s1 (state-set-pc (+ (pc s0) invokerSize) s0)))
    (<span class="keyword">cond</span> ((mem '*native* accessflags)
           (invokeNativeFunction method s1))
          ((mem '*abstract* accessflags)
           (fatalError <span class="string">"abstract_method invoked"</span> s0))
          (t (<span class="keyword">let</span> ((s2 (pushFrameWithPop this-ref method s1)))
               <span class="comment">;; assuming pushFrame always succeed, we can increase our PC
</span>               <span class="comment">;; now. 
</span>               (<span class="keyword">if</span> (mem '*synchronized* accessflags)
                   (mv-let (mstatus s3)
                           (monitorEnter this-ref s2)
                           (<span class="keyword">declare</span> (ignore mstatus))
                           (set-curframe-sync-obj this-ref s3))
                 s2))))))



(<span class="keyword">defun</span> <span class="function-name">call_interface_method</span> (this-ref method-rep s)
  (call_method_general this-ref method-rep s 5))


(<span class="keyword">defun</span> <span class="function-name">isImplementationOf</span> (c1 c2 s)
  (<span class="keyword">declare</span> (ignore c1 c2 s))
  <span class="comment">;;
</span>  <span class="comment">;; tmp implementation
</span>  <span class="comment">;; depends one whether class loader want to collapse the implements pointers.  
</span>  <span class="comment">;; if so, then isImplementationOf is easier.
</span>  <span class="comment">;; 
</span>  <span class="comment">;; However this is no essential on whether the JVM will crash, 
</span>  <span class="comment">;; defensive machine and none defensive machine will behave the same. 
</span>  <span class="comment">;; It is a point how accurately we model the JVM...
</span>  <span class="comment">;;
</span>  t)


(<span class="keyword">defun</span> <span class="function-name">execute-invokeinterface</span> (<a href="../DJVM/INST/inst.lisp.html">inst</a> s)
  (<span class="keyword">let*</span> ((methodCP (arg <a href="../DJVM/INST/inst.lisp.html">inst</a>))
         (argCount (arg2 <a href="../DJVM/INST/inst.lisp.html">inst</a>))
         (method-ptr (methodCP-to-method-ptr methodCP)))
    (mv-let (method-rep new-s)
            (resolveMethodReference method-ptr nil s)
            (<span class="keyword">if</span> (pending-exception s)
                (raise-exception (pending-exception s) s)
              (<span class="keyword">let</span> ((this-ref (top (popStackN argCount new-s))))
                (<span class="keyword">if</span> (CHECK-NULL this-ref)
                    (raise-exception <span class="string">"java.lang.NullPointerException"</span> s)
                  <span class="comment">;; don't check access
</span>                  (<span class="keyword">if</span> method-rep                        
                      <span class="comment">;; * need to check if there is execeptions pending... ****
</span>                      <span class="comment">;; RESOLVE is defined in such a way no exceptions are thrown
</span>                      <span class="comment">;; the return value encoded the type of exceptions.
</span>                      (<span class="keyword">let*</span> ((dynamicClass   
                              (obj-type (binding this-ref (heap s))))
                           <span class="comment">;; actually type of object used to invoke the
</span>                           <span class="comment">;; interface method.  
</span>                           <span class="comment">;; all superclasses are loaded
</span>                             (new-method-ptr (make-method-ptr dynamicClass
                                                              (method-ptr-methodname method-ptr)
                                                              (method-ptr-args-type  method-ptr)
                                                              (method-ptr-returntype  method-ptr)))
                             (closest-method (lookupMethod new-method-ptr new-s))
                             (accessflags    (method-accessflags closest-method)))
                        <span class="comment">;; this doesn't change s
</span>                        <span class="comment">;;
</span>                        <span class="comment">;; The CLDC Bytecode verifier does not guarantee that
</span>                        <span class="comment">;; this lookup procedure will find a method (this is
</span>                        <span class="comment">;; different from the case of invokevirtual, where
</span>                        <span class="comment">;; bytecode verifier guarantee that the type of actual
</span>                        <span class="comment">;; object will be a subclass of the type of the method
</span>                        <span class="comment">;; as refered in the Constant Pool entry. 
</span>                        <span class="comment">;;
</span>                        <span class="comment">;; invokeinterface does not guarantee a object will
</span>                        <span class="comment">;; implement the interfaces. Runtime check must be done
</span>                        <span class="comment">;; to ensure the object really implement the
</span>                        <span class="comment">;; interface! 
</span>                        <span class="comment">;; 
</span>                        <span class="comment">;; Should JVM check for interface is really implemented
</span>                        <span class="comment">;; (which can be quite hard to check)? or Should it
</span>                        <span class="comment">;; check that a method of the right name happen to exists?
</span>                        <span class="comment">;; 
</span>                        <span class="comment">;; invokeinterface here should check that current obj
</span>                        <span class="comment">;; implement the interface, 
</span>                        <span class="comment">;;
</span>                        <span class="comment">;; The class loader should ensure when an class claim
</span>                        <span class="comment">;; to implement a class, corresponding method must
</span>                        <span class="comment">;; exist!!!
</span>                        <span class="comment">;; 
</span>                        <span class="comment">;; Otherwise on every interface method dispatch, such
</span>                        <span class="comment">;; an expensive would be checked. 
</span>                        <span class="comment">;;
</span>                        <span class="comment">;; SO we need to FIX class_loader!!! August 10th, 2003
</span>                        <span class="comment">;;
</span>                        <span class="comment">;; Class loader must maintain such an invariant on the
</span>                        <span class="comment">;; loaded class table
</span>                        <span class="comment">;;
</span>                        <span class="comment">;; in the lookup step, access permission is not
</span>                        <span class="comment">;; checked. private method could be invoked, even some
</span>                        <span class="comment">;; superclass has an public implementation. 
</span>                        <span class="comment">;; 
</span>                        <span class="comment">;; programming convention is that we never strengthen
</span>                        <span class="comment">;; the accesss permissions in subclasses. that could
</span>                        <span class="comment">;; cause unexpected behavior (compiler enforces this
</span>                        <span class="comment">;; but not JVM. JVM allow invoke private method)
</span>                        <span class="comment">;; 
</span>                        <span class="comment">;; depend on how we write class loader, testing a class
</span>                        <span class="comment">;; implementing interface could be quiet difficult.
</span>                        <span class="comment">;;
</span>                        (<span class="keyword">if</span> (not (isImplementationOf 
                                  dynamicClass (method-ptr-classname method-ptr) new-s))
                            (fatalError <span class="string">"IncompatilbeClassChangeError"</span> new-s)
                          <span class="comment">;;
</span>                          <span class="comment">;; it seems that CLDC does not has this
</span>                          <span class="comment">;; IncompatibleClassChangeError
</span>                          <span class="comment">;;
</span>                          (<span class="keyword">if</span> (and closest-method
                                   (mem '*public* accessflags)
                                   (not (mem '*static* accessflags)))
                              (call_interface_method this-ref closest-method new-s)
                            (fatalSlotError methodCP new-s))))
                        (fatalSlotError methodCP new-s))))))))

<span class="comment">; NOTE:
;
;    Currently, the method for resolve interface method and a normal method is
;    the same. Although it is different in JVMS. However, under the condition
;    that java.lang.Object does not 
; 
;    Question!!: How to guarantee the native function does the right thing?
;    we have to trust it, but how to express this trust?? an axiom says, ...
;
;    This VERSION has a problem. IT DOES NOT CHECK that dynamic class
;    implemented the Interface JUST RESOLVED! NEED TO ADD THAT JUNE 19th 2003
;
; Defensive: 
;     
;    check *method-to-invoke* matches the description of method, types, args. 
;
; BCV:
;
;    check enough argument, check proper types (in fact only object-ref) no 
;    resolution in BCV. check count consistent? 
; 
; Informal Proof:
;  
;    why check count consistent in BCV? catch some error early?  So that native
;    method don't have to understand java type? native will use it to pop n
;    element off?  native method does not has a new frame on the java
;    call-stack.  In fact, in the efficent implementation, parameters are not
;    push into the locals of the native function, native function directly
;    change the state.  without first popping all the parameters on the current
;    op stack and put them into the locals of the native function.
;
;    two lookup procedures are different, however since they look for the same
;    method, if found, we know the found one matches. (because looking-up uses
;    the) in BCV, no resolution is done. 
;   
;    This above paragraph is wrong. In the BCV there is no look up procedure, 
;    performed. it is performed in both defensive and non defensive look.
;    if lookup succeed, it is should match the check at the BCV stage. 
;
;
;    Since in current model, anyone can assign a reference value to a variable
;    of type interface. The safty guarantee is provided by the special
;    interface method resolution procedure and 
;---------------------------------------------------------------------
</span>

<span class="comment">;---------------------------------------------------------------------
;
</span>
(<span class="keyword">defun</span> <span class="function-name">method-args-count1</span> (types)
  (<span class="keyword">if</span> (endp types)
      0
    (+ (type-size (car types))
       (method-args-count1 (cdr types)))))


(<span class="keyword">defun</span> <span class="function-name">method-args-count</span> (method-rep)
  (<span class="keyword">let</span> ((args (method-args method-rep)))
    (method-args-count1 args)))


(<span class="keyword">defun</span> <span class="function-name">call_special_method</span> (this-ref method s)
  (call_method_general this-ref method s 3 ))


(<span class="keyword">defun</span> <span class="function-name">execute-invokespecial</span> (<a href="../DJVM/INST/inst.lisp.html">inst</a> s)
    (mylet* ((methodCP (arg <a href="../DJVM/INST/inst.lisp.html">inst</a>))
             (method-ptr (methodCP-to-method-ptr methodCP)))
    (mv-let (method-rep new-s)
            (resolveMethodReference method-ptr nil s) 
            (<span class="keyword">if</span> (pending-exception s)
                (raise-exception (pending-exception s) s)
              (<span class="keyword">let</span> ((this-ref (topStack (popStackN 
                                         (method-args-count method-rep) new-s))))
                (<span class="keyword">if</span> (CHECK-NULL this-ref)
                    (raise-exception <span class="string">"java.lang.NullPointerException"</span> s)
                  <span class="comment">;; don't check access
</span>                  (<span class="keyword">if</span> method-rep                        
                      <span class="comment">;; for those special method no dynamic binding. &lt;init&gt; 
</span>                      (call_special_method this-ref method-rep new-s)
                    (fatalSlotError methodCP new-s))))))))

<span class="comment">; NOTE:
;
;    invokespecial has complicated behavior to deal with class's with *super*
;    flags on. Resolution changes. What should I do here??
;     
;    Assume that condition: ACC_SUPER set, resolved class is superclass of the
;    current class, resolved class is not &lt;init&gt;, is never satisfied.
;  
;     
;    For example ensure, invokespecial is always used to invoke &lt;init&gt; methods.
; 
;    New JVM spec will also check the access from current class to the resolved class.
;    In particular BCV, need to check the object used to access a protected
;    method     
;
; Defensive: 
;     
;    If we make such assumption, we need to check the resolve method is &lt;init&gt; 
;    ...
;
; BCV:
;
;    BCV need to do something about protected access, besides that it is
;    regular checking check OP stack matches the types indicated in the CP
;    entry.
; 
; Informal Proof:
;
;    If resolve fail, fail both in non defensive and defensive,     
;    if succeed, find the right method with right signature, so BCV sig match
;    will guarantee the defensive match? because BCV's op stack is always more
;    general than defensive machine's op stack.
;  
;    The key it to write out the "more general" and prove that stepping
;    defensive machine is still more specific than stepping the BCV. (if BCV
;    succeeded in the first place
;
;    Although this is the hard part, it may not be the most problematic part.
;        
;
;---------------------------------------------------------------------
</span>
<span class="comment">;---------------------------------------------------------------------
;  FIXME!!
</span>
(<span class="keyword">defun</span> <span class="function-name">static-method-class-rep</span> (method-rep s)
  (class-by-name (method-classname method-rep) (instance-class-table s)))


(<span class="keyword">defun</span> <span class="function-name">call_static_method</span> (class-ref method-rep s)
  (call_method_general class-ref method-rep s 3))


(<span class="keyword">defun</span> <span class="function-name">execute-invokestatic</span> (<a href="../DJVM/INST/inst.lisp.html">inst</a> s)
    (<span class="keyword">let*</span> ((methodCP (arg <a href="../DJVM/INST/inst.lisp.html">inst</a>))
           (method-ptr (methodCP-to-method-ptr methodCP)))
    (mv-let (method-rep new-s)
            (resolveMethodReference method-ptr t s) <span class="comment">;; we know class is loaded
</span>            (<span class="keyword">if</span> (pending-exception s)
                (raise-exception (pending-exception s) s)
              (<span class="keyword">if</span> method-rep
                  (<span class="keyword">let*</span> ((class-rep  (static-method-class-rep method-rep new-s))
                         (mclassname (classname class-rep))
                         (class-ref  (class-ref class-rep)))
                    (<span class="keyword">if</span> (class-rep-in-error-state? class-rep)
                        (fatalError <span class="string">"expected initialized class"</span> new-s)
                      (<span class="keyword">if</span> (not (class-initialized? mclassname  new-s))
                          (prog2$ (acl2::debug-print <span class="string">"hereXXX"</span>)
                                  (reschedule (initializeClass mclassname new-s))) 
                        <span class="comment">;; re-execute the same instruction. 
</span>                        (call_static_method class-ref method-rep new-s))))
                (fatalSlotError methodCP new-s))))))

<span class="comment">; NOTE:
;      Why not using resolveStaticMethodReference? check the resolved method is
;      really static?? 
;   
;      Need to update it to check the found one is really "static" and none abstract
;      Also need to check the resolve the method is not &lt;init&gt; or &lt;clinit&gt;
;      
; Defensive: 
;    do resolution succeed check, <a href="../DJVM/consistent-state.lisp.html">consistent-state</a> etc.  
;      
;
; BCV:  
;      BCV is really doing the same check for method invocation, op stack
;      matches the function sig.
;
; Informal Proof:
;
;      need the invariant that resolution preserves the <a href="../DJVM/consistent-state.lisp.html">consistent-state</a> 
;      
;
;---------------------------------------------------------------------
</span>

<span class="comment">;---------------------------------------------------------------------
;
;
</span>
(<span class="keyword">defun</span> <span class="function-name">call_virtual_method</span> (this-ref method s)
  (call_method_general this-ref method s 3 ))


(<span class="keyword">defun</span> <span class="function-name">execute-INVOKEVIRTUAL</span> (<a href="../DJVM/INST/inst.lisp.html">inst</a> s)
  (<span class="keyword">let*</span> ((methodCP (arg <a href="../DJVM/INST/inst.lisp.html">inst</a>))
         (method-ptr (methodCP-to-method-ptr methodCP)))
    (mv-let (method-rep new-s)
            (resolveMethodReference method-ptr nil s)
            (<span class="keyword">if</span> (pending-exception s)
                (raise-exception (pending-exception s) s)
              (<span class="keyword">let</span> ((this-ref (topStack (popStackN 
                                         (method-args-count method-rep) new-s))))
                (<span class="keyword">if</span> (CHECK-NULL this-ref)
                    (raise-exception <span class="string">"java.lang.NullPointerException"</span> s)
                  <span class="comment">;; don't check access
</span>                  (<span class="keyword">if</span> method-rep                        
                      <span class="comment">;; * need to check if there is execeptions pending... ****
</span>                      <span class="comment">;; RESOLVE is defined in such a way no exceptions are thrown
</span>                      <span class="comment">;; the return value encoded the type of exceptions.
</span>                      (<span class="keyword">let*</span> ((dynamicClass   (obj-type (binding this-ref (heap s))))
                             <span class="comment">;; all superclasses are loaded
</span>                             <span class="comment">;; original implementation is wrong, we should
</span>                             <span class="comment">;; start the method lookup from the actual type of
</span>                             <span class="comment">;; the object.
</span>                             <span class="comment">;;
</span>                             <span class="comment">;; Here we have an issue about object having array-type 
</span>                             <span class="comment">;; We need to handle it correctly in
</span>                             <span class="comment">;; lookupMethod!! August 10th. 2003
</span>                             <span class="comment">;;
</span>
                             (new-method-ptr (make-method-ptr dynamicClass
                                                              (method-ptr-methodname method-ptr)
                                                              (method-ptr-args-type  method-ptr)
                                                              (method-ptr-returntype  method-ptr)))
                             (closest-method (lookupMethod new-method-ptr new-s)))
                        <span class="comment">;; this doesn't change s
</span>                        (<span class="keyword">if</span> closest-method
                            (call_virtual_method this-ref closest-method new-s)
                          (fatalSlotError methodCP new-s)))
                    (fatalSlotError methodCP new-s))))))))

<span class="comment">; NOTE:
;        access control is only checked at resolution time from current class
;        to the class that the resolved method comes from.
;
; Defensive: 
;
;        Defensive check the protected access (if the resolved method is from a
;        superclass of the current class the object should be subclass of the
;        current class. (However in other cases, access control is not checked
;        at runtime. The lookup process does not guarantee the method found are
;        accessible. 
;
;        Most of access control is done at the resolution time. A little bit at
;        bytecode verification time, a little bit at runtime (check
;        objref implement interfaces -- invokeinterface etc??)
;  
;        The security model is quite subtle here. Only guarantees the source
;        code level access control + special case for protected access. One can
;        constructs a case to invoke a private method, (but not private field)
;        -- because of dynamic binding.
;
; BCV:  
;         
;        
;
; Informal Proof:
;
;---------------------------------------------------------------------
</span>

<span class="comment">;---------------------------------------------------------------------
</span>
(<span class="keyword">defun</span> <span class="function-name">execute-IOR</span> (<a href="../DJVM/INST/inst.lisp.html">inst</a> s)
  (<span class="keyword">let</span> ((v1 (topStack s))
        (v2 (secondStack s)))
    (ADVANCE-PC (pushStack  (logior v1 v2)
                            (popStack (popStack s))))))

<span class="comment">; NOTE:
;
;    nothing special
;
; Defensive: 
;    
;    check op has enough int type input.
;
; BCV:
;
; Informal Proof:
;
;---------------------------------------------------------------------
</span>
<span class="comment">;---------------------------------------------------------------------
; 
</span>(<span class="keyword">defun</span> <span class="function-name">execute-IREM</span> (<a href="../DJVM/INST/inst.lisp.html">inst</a> s)
  (<span class="keyword">let*</span> ((v2 (topStack s))
         (v1 (secondStack s)))
    (<span class="keyword">if</span> (equal v1 0)
        (raise-exception <span class="string">"java.lang.ArithmeticException"</span> s)
      (ADVANCE-PC (pushStack (- v1 (* (truncate v1 v2) v2))
                             (popStack (popStack s)))))))

<span class="comment">; NOTE:
;   like IDIV 
; Defensive: 
;
;
; BCV:
;
; Informal Proof:
;
;;---------------------------------------------------------------------
</span>



<span class="comment">;---------------------------------------------------------------------
;
; IRETURN
</span>
<span class="comment">; NOTE:
;
;    Covered in ARETURN
;
; Defensive: 
;    
;   Check the return value matches the return type of the current method
;   non defensive relies on BCV checked it.
;
; BCV:
;   Check the return type 
;
; Informal Proof:
;
;   Invariant the defensive state is more specific
;
;;---------------------------------------------------------------------
</span>
<span class="comment">;---------------------------------------------------------------------
</span>

(<span class="keyword">defun</span> <span class="function-name">execute-ISHL</span> (<a href="../DJVM/INST/inst.lisp.html">inst</a> s)
  (<span class="keyword">let*</span> ((v2 (topStack s))
         (v1 (secondStack s))
         (shiftval (5-bit-fix v2))
         (rslt (shl v1 shiftval)))
    (ADVANCE-PC (pushStack  (int-fix rslt)
                            (popStack (popStack s))))))

<span class="comment">; NOTE:
;
; Defensive: 
;
;
; BCV:
;
; Informal Proof:
;
;;---------------------------------------------------------------------;
</span>

<span class="comment">;---------------------------------------------------------------------
</span>

(<span class="keyword">defun</span> <span class="function-name">execute-ISHR</span> (<a href="../DJVM/INST/inst.lisp.html">inst</a> s)
  (<span class="keyword">let*</span> ((v2 (topStack s))
         (v1 (secondStack s))
         (shiftval (5-bit-fix v2))
         (rslt (shr v1 shiftval)))
    (ADVANCE-PC (pushStack  (int-fix rslt)
                            (popStack (popStack s))))))

<span class="comment">; NOTE:
;
; Defensive: 
;
;
; BCV:
;
; Informal Proof:
;
;;---------------------------------------------------------------------;
</span>

<span class="comment">;---------------------------------------------------------------------
</span>
(<span class="keyword">defun</span> <span class="function-name">execute-ISTORE</span> (<a href="../DJVM/INST/inst.lisp.html">inst</a> s)
  (<span class="keyword">let*</span> ((index (arg <a href="../DJVM/INST/inst.lisp.html">inst</a>))
         (v1 (topStack s)))
    (ADVANCE-PC (popStack (SET-LP index v1)))))

(<span class="keyword">defun</span> <span class="function-name">execute-ISTORE_0</span> (<a href="../DJVM/INST/inst.lisp.html">inst</a> s)
  (ADVANCE-PC (popStack (SET-LP 0 (topStack s)))))

(<span class="keyword">defun</span> <span class="function-name">execute-ISTORE_1</span> (<a href="../DJVM/INST/inst.lisp.html">inst</a> s)
  (ADVANCE-PC (popStack (SET-LP 1 (topStack s)))))

(<span class="keyword">defun</span> <span class="function-name">execute-ISTORE_2</span> (<a href="../DJVM/INST/inst.lisp.html">inst</a> s)
  (ADVANCE-PC (popStack (SET-LP 2 (topStack s)))))

(<span class="keyword">defun</span> <span class="function-name">execute-ISTORE_3</span> (<a href="../DJVM/INST/inst.lisp.html">inst</a> s)
  (ADVANCE-PC (popStack (SET-LP 3 (topStack s)))))


<span class="comment">; NOTE: 
;
;   how about wide instruction??? Assume translator dealt with it.
;
; Defensive: 
;    check offset in range (&lt;= 0 &lt; maxlocal). need to take care of invalidate
;    any two byte value. 
;
; BCV:
;
;    check range
;
; Informal Proof:
;
;    code won't change 
;
;---------------------------------------------------------------------
</span>

<span class="comment">;---------------------------------------------------------------------
</span>

(<span class="keyword">defun</span> <span class="function-name">execute-ISUB</span> (<a href="../DJVM/INST/inst.lisp.html">inst</a> s)
  (<span class="keyword">let</span> ((v2 (topStack s))
        (v1 (secondStack s)))
    (ADVANCE-PC (pushStack  (int-fix (- v1 v2)) 
                            (popStack (popStack s))))))



<span class="comment">; NOTE:
;
; Defensive: 
;
;
; BCV:
;
; Informal Proof:
;
;;---------------------------------------------------------------------
</span>
<span class="comment">;---------------------------------------------------------------------
</span>
(<span class="keyword">defun</span> <span class="function-name">iushr</span> (val1 shft)
  (<span class="keyword">if</span> (&lt; val1 0)
      (+ (shr val1 shft) (shl 1 (- 32 shft)))
    (shr val1 shft)))


(<span class="keyword">defun</span> <span class="function-name">execute-IUSHR</span> (<a href="../DJVM/INST/inst.lisp.html">inst</a> s)
  (<span class="keyword">let*</span> ((v2 (topStack s))
         (v1 (secondStack s))
         (shiftval (5-bit-fix v2))
         (rslt (iushr v1 shiftval)))
    (ADVANCE-PC (pushStack  (int-fix rslt)
                            (popStack (popStack s))))))

<span class="comment">; NOTE:
;
; Defensive: 
;
;
; BCV:
;
; Informal Proof:
;
;;---------------------------------------------------------------------
</span>

<span class="comment">;---------------------------------------------------------------------
</span>(<span class="keyword">defun</span> <span class="function-name">execute-IXOR</span> (<a href="../DJVM/INST/inst.lisp.html">inst</a> s)
  (<span class="keyword">let</span> ((v1 (topStack s))
        (v2 (secondStack s)))
    (ADVANCE-PC (pushStack  (logxor v1 v2)
                            (popStack (popStack s))))))

<span class="comment">; NOTE:
;
; Defensive: 
;
;
; BCV:
;
; Informal Proof:
;
;;---------------------------------------------------------------------
</span>



<span class="comment">;---------------------------------------------------------------------
;-------------------------        J         --------------------------
;---------------------------------------------------------------------
</span>

<span class="comment">;---------------------------------------------------------------------
</span>
(<span class="keyword">defun</span> <span class="function-name">execute-jsr</span> (<a href="../DJVM/INST/inst.lisp.html">inst</a> s)
  (<span class="keyword">let</span> ((target (arg <a href="../DJVM/INST/inst.lisp.html">inst</a>)))
    (state-set-pc target 
                  (pushStack 
                   (+ (pc s) (<a href="../DJVM/INST/inst.lisp.html">inst</a>-size <a href="../DJVM/INST/inst.lisp.html">inst</a>)) s))))

<span class="comment">; NOTE:
;      NOT PRESENT IN CLDC model 
; Defensive: 
;
;
; BCV:
;
;     not handled. bcv will fail.
;
; Informal Proof:
;
;---------------------------------------------------------------------
</span>
<span class="comment">;---------------------------------------------------------------------
;-------------------------        L         --------------------------
;---------------------------------------------------------------------
</span>
<span class="comment">;---------------------------------------------------------------------
; L2D 
; L2F 
; --- NOT IMPLEMENTED 
;---------------------------------------------------------------------
</span>

<span class="comment">;---------------------------------------------------------------------
</span>(<span class="keyword">defun</span> <span class="function-name">execute-L2I</span> (<a href="../DJVM/INST/inst.lisp.html">inst</a> s)
  (<span class="keyword">let</span> ((v1 (topLong s)))
    (ADVANCE-PC (pushStack  (int-fix v1)
                            (popStack (popStack s))))))

<span class="comment">; NOTE:
;
; Defensive: 
;    CHECK type, 
;
; BCV:
;
; Informal Proof:
;
;---------------------------------------------------------------------
</span>

<span class="comment">;---------------------------------------------------------------------
; LADD
</span>
(<span class="keyword">defun</span> <span class="function-name">execute-LADD</span> (<a href="../DJVM/INST/inst.lisp.html">inst</a> s)
  (<span class="keyword">let</span> ((v1 (topLong s))
        (v2 (topLong (popLong s))))
    (ADVANCE-PC  (pushLong (long-fix (+ v1 v2))
                           (popLong (popLong s))))))

<span class="comment">; NOTE:
;    just check types. 
; Defensive: 
;
;
; BCV:
;
; Informal Proof:
;
;;---------------------------------------------------------------------
</span>
<span class="comment">;---------------------------------------------------------------------
</span>
(<span class="keyword">defun</span> <span class="function-name">execute-LALOAD</span> (<a href="../DJVM/INST/inst.lisp.html">inst</a> s)
  (<span class="keyword">let*</span> ((index (topStack s))
         (array-ref (secondStack s)))
    (<span class="keyword">if</span> (CHECK-NULL array-ref)
        (raise-exception <span class="string">"java.lang.NullPointerException"</span> s)
      (<span class="keyword">if</span> (check-array array-ref index s)
          (ADVANCE-PC (pushLong (element-at-array index array-ref s) 
                                <span class="comment">;; (popStack (popLong s))))
</span>                                (popStack (popStack s)))) <span class="comment">;;; Mon Feb 28
</span>                                  <span class="comment">;;; 16:32:56 2005 qzhang! 
</span>                                  
        (raise-exception <span class="string">"java.lang.ArrayIndexOutOfBoundsException"</span> s)))))

<span class="comment">; NOTE:
;
; Defensive: 
;
;
; BCV:
;
; Informal Proof:
;
;;---------------------------------------------------------------------
</span>
<span class="comment">;---------------------------------------------------------------------
</span>

(<span class="keyword">defun</span> <span class="function-name">execute-LAND</span> (<a href="../DJVM/INST/inst.lisp.html">inst</a> s)
  (<span class="keyword">let</span> ((v1 (topLong s))
        (v2 (topLong (popLong s))))
    (ADVANCE-PC (pushStack  (long-fix (logand v1 v2))
                            (popStack (popStack s))))))


<span class="comment">; NOTE:
;        bitwise AND so no need to have the long-fix
; Defensive: 
;
;
; BCV:
;
; Informal Proof:
;
;;---------------------------------------------------------------------
</span>

<span class="comment">;---------------------------------------------------------------------
</span>(<span class="keyword">defun</span> <span class="function-name">execute-LASTORE</span> (<a href="../DJVM/INST/inst.lisp.html">inst</a> s)
  (<span class="keyword">let*</span> ((value (topLong s))
         (index (topStack (popLong s)))
         (array-ref (secondStack (popLong s))))
    (<span class="keyword">if</span> (CHECK-NULL array-ref)
        (raise-exception <span class="string">"java.lang.NullPointerException"</span> s)
      (<span class="keyword">if</span> (check-array array-ref index s)
          (ADVANCE-PC (popStack 
                       (popStack 
                         (popLong (set-element-at-array index value array-ref s)))))
      (raise-exception <span class="string">"java.lang.ArrayIndexOutOfBoundsException"</span> s)))))


<span class="comment">; NOTE:
;
; Defensive: 
;
;
; BCV:
;
; Informal Proof:
;
;;---------------------------------------------------------------------
</span>

<span class="comment">;---------------------------------------------------------------------
;LCMP
</span>
(<span class="keyword">defun</span> <span class="function-name">execute-LCMP</span> (<a href="../DJVM/INST/inst.lisp.html">inst</a> s)
  (<span class="keyword">let*</span> ((v2 (topLong s))
         (v1 (topLong (popLong s)))
         (rslt (<span class="keyword">cond</span> ((&lt; v1 v2) -1)
                     ((equal v1 v2) 0)
                     (t 1))))
    (ADVANCE-PC (pushLong (long-fix rslt)
                          (popStack (popStack s))))))


<span class="comment">; NOTE:
;
; Defensive: 
;
;
; BCV:
;
; Informal Proof:
;
;;---------------------------------------------------------------------
</span>

<span class="comment">;---------------------------------------------------------------------
;LCONST_0
;LCONST_1
</span>
(<span class="keyword">defun</span> <span class="function-name">execute-LCONST_0</span> (<a href="../DJVM/INST/inst.lisp.html">inst</a> s)
  (ADVANCE-PC (pushLong 0 s)))

(<span class="keyword">defun</span> <span class="function-name">execute-LCONST_1</span> (<a href="../DJVM/INST/inst.lisp.html">inst</a> s)
  (ADVANCE-PC (pushLong 1 s)))

<span class="comment">; NOTE:
;
; Defensive: 
;
;
; BCV:
;
; Informal Proof:
;
;;---------------------------------------------------------------------
</span>

<span class="comment">;---------------------------------------------------------------------
; LDC, LDC_W
;
</span>
<span class="comment">;; should move those around!!
</span>
(<span class="keyword">defun</span> <span class="function-name">cpentry</span> (index cp)
  (cpentry-value (nth index cp)))

(<span class="keyword">defun</span> <span class="function-name">cpentry-at</span> (index s)
  (<span class="keyword">let*</span> ((class-rep (current-class s))
         (cp (constantpool class-rep)))
      (cpentry index cp)))

(<span class="keyword">defun</span> <span class="function-name">execute-LDC</span> (<a href="../DJVM/INST/inst.lisp.html">inst</a> s)
  (ADVANCE-PC (pushStack (cpentry-at (arg <a href="../DJVM/INST/inst.lisp.html">inst</a>) s) s)))


<span class="comment">; NOTE:
;
;    ASSUME LDC_W does not exists after jvm2acl2
;
; Defensive: 
;
;
; BCV: bcv check valid index. runtime check can be avoid.
;      LDC load only int, float, and string reference 
;
; Informal Proof:
;
;---------------------------------------------------------------------
</span>
<span class="comment">;---------------------------------------------------------------------
; LDC2_W 
; LOAD LONG DOUBLE Assume after jvm2ac2 it does not exists.
</span>
(<span class="keyword">defun</span> <span class="function-name">execute-LDC2</span> (<a href="../DJVM/INST/inst.lisp.html">inst</a> s)
  (ADVANCE-PC (pushStack (cpentry-at (arg <a href="../DJVM/INST/inst.lisp.html">inst</a>) s) s)))

<span class="comment">; NOTE:
;
;    need to check the entry really contains a LONG or DOUBLE
;    check the op stack limit
;
; Defensive: 
;
;
; BCV:
;
; Informal Proof:
;
;;---------------------------------------------------------------------
</span>

<span class="comment">;---------------------------------------------------------------------
;LDIV
; To be implemented 
</span>
(<span class="keyword">defun</span> <span class="function-name">execute-LDIV</span> (<a href="../DJVM/INST/inst.lisp.html">inst</a> s)
  (<span class="keyword">let</span> ((v2 (topLong s))
        (v1 (topLong (popLong s))))
    (<span class="keyword">if</span> (equal v2 0)
        (raise-exception <span class="string">"java.lang.ArithmeticException"</span> s)
      (ADVANCE-PC  (pushLong (long-fix (/ v1 v2))
                             (popLong (popLong s)))))))

<span class="comment">; NOTE:
;
; Defensive: 
;
;
; BCV:
;
; Informal Proof:
;
;;---------------------------------------------------------------------
</span>


<span class="comment">;---------------------------------------------------------------------
;LLOAD
;LLOAD_0
;LLOAD_1
;LLOAD_2
;LLOAD_3
</span>

(<span class="keyword">defun</span> <span class="function-name">execute-LLOAD_0</span> (<a href="../DJVM/INST/inst.lisp.html">inst</a> s)
  (ADVANCE-PC (pushLong (LLP 0) s)))

(<span class="keyword">defun</span> <span class="function-name">execute-LLOAD_1</span> (<a href="../DJVM/INST/inst.lisp.html">inst</a> s)
  (ADVANCE-PC (pushLong (LLP 1) s)))

(<span class="keyword">defun</span> <span class="function-name">execute-LLOAD_2</span> (<a href="../DJVM/INST/inst.lisp.html">inst</a> s)
  (ADVANCE-PC (pushLong (LLP 2) s)))

(<span class="keyword">defun</span> <span class="function-name">execute-LLOAD_3</span> (<a href="../DJVM/INST/inst.lisp.html">inst</a> s)
  (ADVANCE-PC (pushLong (LLP 3) s)))

(<span class="keyword">defun</span> <span class="function-name">execute-LLOAD</span> (<a href="../DJVM/INST/inst.lisp.html">inst</a> s)
  (ADVANCE-PC (pushLong (LLP (arg <a href="../DJVM/INST/inst.lisp.html">inst</a>))
                        s)))

<span class="comment">; NOTE:
;
;   In our implementation, long is occupying two slots,
;   however, only the first slot contains the value 
;   LSTORE only write to correct location. 
;   in the defensive 
;   
; Defensive: 
;
;   check the local at the offset are really containing long   
;   
;
; BCV:
;   similar checks 
;
; Informal Proof:
;
;---------------------------------------------------------------------
</span>

<span class="comment">;---------------------------------------------------------------------
</span>
(<span class="keyword">defun</span> <span class="function-name">execute-LMUL</span> (<a href="../DJVM/INST/inst.lisp.html">inst</a> s)
  (<span class="keyword">let</span> ((v2 (topLong s))
        (v1 (topLong (popLong s))))
    (ADVANCE-PC  (pushLong (long-fix (* v1 v2))
                           (popLong (popLong s))))))


<span class="comment">; LMUL
</span>
<span class="comment">; NOTE:
;
; Defensive: 
;
;
; BCV:
;
; Informal Proof:
;
;;---------------------------------------------------------------------
</span>
<span class="comment">;---------------------------------------------------------------------
;LNEG
</span>
(<span class="keyword">defun</span> <span class="function-name">execute-LNEG</span> (<a href="../DJVM/INST/inst.lisp.html">inst</a> s)
  (ADVANCE-PC (pushLong (long-fix (- 0 (topLong s)))
                        (popLong s))))


<span class="comment">; NOTE:
;
; Defensive: 
;
;
; BCV:
;
; Informal Proof:
;
;;---------------------------------------------------------------------
</span>

<span class="comment">;---------------------------------------------------------------------
</span>
(<span class="keyword">defun</span> <span class="function-name">lookupswitch-default-target</span> (lookupswitchinfo)
  (nth 1 lookupswitchinfo))

(<span class="keyword">defun</span> <span class="function-name">lookupswitch-target-pairs</span> (lookupswitchinfo)
  (nth 3 lookupswitchinfo))

(<span class="keyword">defun</span> <span class="function-name">lookupswitch-paircount</span> (lookupswitchinfo)
  (nth 2 lookupswitchinfo))

(<span class="keyword">defun</span> <span class="function-name">lookup-lookupswitch</span> (v lookupswitchinfo)
  (<span class="keyword">if</span> (bound? v (lookupswitch-target-pairs lookupswitchinfo))
      (binding v (lookupswitch-target-pairs lookupswitchinfo))
    (lookupswitch-default-target lookupswitchinfo)))


(<span class="keyword">defun</span> <span class="function-name">execute-lookupswitch</span> (<a href="../DJVM/INST/inst.lisp.html">inst</a> s)
  (state-set-pc (lookup-lookupswitch (topStack s)
                                     (arg <a href="../DJVM/INST/inst.lisp.html">inst</a>))
                (popStack s)))

<span class="comment">; NOTE:
;
;     BCV check the keys are ordered of type int
;     offset point to valid instructions. CP entry exists.
;     
; Defensive: 
;     defensive check the similar things. 
;
; BCV:
;
; Informal Proof:
;
;;---------------------------------------------------------------------
</span>

<span class="comment">;---------------------------------------------------------------------
</span>
<span class="comment">; LOR
</span>

(<span class="keyword">defun</span> <span class="function-name">execute-LOR</span> (<a href="../DJVM/INST/inst.lisp.html">inst</a> s)
  (<span class="keyword">let</span> ((v1 (topLong s))
        (v2 (topLong (popLong s))))
    (ADVANCE-PC (pushLong   (logior v1 v2)
                            (popLong (popLong s))))))

<span class="comment">; NOTE:
;
; Defensive: 
;
;
; BCV:
;
; Informal Proof:
;
;---------------------------------------------------------------------
</span>
<span class="comment">;---------------------------------------------------------------------
</span>
<span class="comment">;LREM
</span>

(<span class="keyword">defun</span> <span class="function-name">execute-LREM</span> (<a href="../DJVM/INST/inst.lisp.html">inst</a> s)
  (<span class="keyword">let</span> ((v2 (topLong s))
        (v1 (topLong (popLong s))))
    (<span class="keyword">if</span> (equal v2 0)
        (raise-exception <span class="string">"java.lang.ArithmeticException"</span> s)
      (ADVANCE-PC  (pushLong (- v1 (* (truncate v1 v2) v2))
                             (popLong (popLong s)))))))

<span class="comment">; NOTE:
;
; Defensive: 
;
;
; BCV:
;
; Informal Proof:
;
;;---------------------------------------------------------------------
</span>

<span class="comment">; LRETURN is handled in ARETURN
</span>


<span class="comment">;---------------------------------------------------------------------
;
</span>
(<span class="keyword">defun</span> <span class="function-name">execute-LSHL</span> (<a href="../DJVM/INST/inst.lisp.html">inst</a> s)
  (<span class="keyword">let*</span> ((v2 (topLong s))
         (v1 (topLong (popLong s)))
         (shiftval (6-bit-fix v2))
         (rslt (shl v1 shiftval)))
    (ADVANCE-PC (pushLong   (long-fix rslt)
                            (popLong (popLong s))))))

<span class="comment">; NOTE:
;
; Defensive: 
;
;
; BCV:
;
; Informal Proof:
;
;---------------------------------------------------------------------
</span>

<span class="comment">;---------------------------------------------------------------------
</span>

(<span class="keyword">defun</span> <span class="function-name">execute-LSHR</span> (<a href="../DJVM/INST/inst.lisp.html">inst</a> s)
  (<span class="keyword">let*</span> ((v2 (topLong s))
         (v1 (topLong (popLong s)))
         (shiftval (6-bit-fix v2))
         (rslt (shr v1 shiftval)))
    (ADVANCE-PC (pushLong   (long-fix rslt)
                            (popLong (popLong s))))))

<span class="comment">; NOTE:
;
; Defensive: 
;
;
; BCV:
;
; Informal Proof:
;
;;---------------------------------------------------------------------
</span>
<span class="comment">;---------------------------------------------------------------------
</span>
<span class="comment">;LSTORE
;LSTORE_0
;LSTORE_1
;LSTORE_2
;LSTORE_3
</span>
(<span class="keyword">defun</span> <span class="function-name">execute-LSTORE_0</span> (<a href="../DJVM/INST/inst.lisp.html">inst</a> s)
  (ADVANCE-PC (popLong (SET-LP 0 (topLong s)))))

(<span class="keyword">defun</span> <span class="function-name">execute-LSTORE_1</span> (<a href="../DJVM/INST/inst.lisp.html">inst</a> s)
  (ADVANCE-PC (popLong (SET-LP 1 (topLong s)))))

(<span class="keyword">defun</span> <span class="function-name">execute-LSTORE_2</span> (<a href="../DJVM/INST/inst.lisp.html">inst</a> s)
  (ADVANCE-PC (popLong (SET-LP 2 (topLong s)))))

(<span class="keyword">defun</span> <span class="function-name">execute-LSTORE_3</span> (<a href="../DJVM/INST/inst.lisp.html">inst</a> s)
  (ADVANCE-PC (popStack (SET-LP 3 (topStack s)))))

(<span class="keyword">defun</span> <span class="function-name">execute-LSTORE</span> (<a href="../DJVM/INST/inst.lisp.html">inst</a> s)
  (ADVANCE-PC (popLong (SET-LP (arg <a href="../DJVM/INST/inst.lisp.html">inst</a>) (topLong s)))))

<span class="comment">; NOTE:
;
;    In this version we do not try to update (arg <a href="../DJVM/INST/inst.lisp.html">inst</a>) + 1 location with `top
;    In defensive version, we will need to do that. or correctly tag the value
;    invalidate the value in (arg <a href="../DJVM/INST/inst.lisp.html">inst</a>) + 1
;
; Defensive: 
;
;
; BCV:
;
; Informal Proof:
;
;---------------------------------------------------------------------
</span>
<span class="comment">;---------------------------------------------------------------------
</span>
<span class="comment">; LSUB
</span>
(<span class="keyword">defun</span> <span class="function-name">execute-LSUB</span> (<a href="../DJVM/INST/inst.lisp.html">inst</a> s)
  (<span class="keyword">let*</span> ((v2 (topLong s))
         (v1 (topLong (popLong s)))
         (rslt (- v1 v2)))
    (ADVANCE-PC (pushLong  (long-fix rslt)
                           (popLong (popLong s))))))


<span class="comment">; NOTE:
;
; Defensive: 
;
;
; BCV:
;
; Informal Proof:
;
;;---------------------------------------------------------------------
</span>

<span class="comment">;---------------------------------------------------------------------
; LUSHR
</span>
(<span class="keyword">defun</span> <span class="function-name">lushr</span> (val1 shft)
  (<span class="keyword">if</span> (&lt; val1 0)
      (+ (shr val1 shft) (shl 1 (- 64 shft)))
    (shr val1 shft)))

(<span class="keyword">defun</span> <span class="function-name">execute-LUSHR</span> (<a href="../DJVM/INST/inst.lisp.html">inst</a> s)
  (<span class="keyword">let*</span> ((v2 (topLong s))
         (v1 (topLong (popLong s)))
         (shiftval (6-bit-fix v2))
         (rslt (lushr v1 shiftval)))
    (ADVANCE-PC (pushLong   (long-fix rslt)
                            (popLong (popLong s))))))

<span class="comment">; NOTE:
;
; Defensive: 
;
;
; BCV:
;
; Informal Proof:
;
;;---------------------------------------------------------------------
</span>
<span class="comment">;---------------------------------------------------------------------
</span>(<span class="keyword">defun</span> <span class="function-name">execute-LXOR</span> (<a href="../DJVM/INST/inst.lisp.html">inst</a> s)
  (<span class="keyword">let*</span> ((v2 (topLong s))
         (v1 (topLong (popLong s)))
         (rslt (logxor v1 v2)))
    (ADVANCE-PC (pushLong  (long-fix rslt)
                           (popLong (popLong s))))))

<span class="comment">; NOTE:
;
; Defensive: 
;
;
; BCV:
;
; Informal Proof:
;
;;---------------------------------------------------------------------
</span>

<span class="comment">;---------------------------------------------------------------------
;-------------------------        M         --------------------------
;---------------------------------------------------------------------
</span>


<span class="comment">;---------------------------------------------------------------------
</span>
(<span class="keyword">defun</span> <span class="function-name">execute-monitorenter</span> (<a href="../DJVM/INST/inst.lisp.html">inst</a> s)
  (<span class="keyword">let*</span> ((obj-ref (topStack s))
         (new-s   (popStack s)))
    (<span class="keyword">if</span> (CHECK-NULL obj-ref)
        (raise-exception <span class="string">"java.lang.NullPointerException"</span> new-s)
      (mv-let (mstatus new-s2)
              (monitorEnter obj-ref (ADVANCE-PC new-s))
              (<span class="keyword">declare</span> (ignore mstatus))
              new-s2))))

<span class="comment">; NOTE: 
;    
; Defensive: 
;   check it is a reference type. + whatever is checked by non-defensive machine
;
; BCV:
;
;   check a reference type (notice, null type is also a reference type)
;   we could check null (however the preverify should allow null be passed)
;
; Informal Proof:
;
;---------------------------------------------------------------------
</span>

<span class="comment">;---------------------------------------------------------------------
</span>
(<span class="keyword">defun</span> <span class="function-name">execute-monitorexit</span> (<a href="../DJVM/INST/inst.lisp.html">inst</a> s)
  (<span class="keyword">let*</span> ((obj-ref (topStack s))
         (new-s   (popStack s)))
    (<span class="keyword">if</span> (CHECK-NULL obj-ref)
        (raise-exception <span class="string">"java.lang.NullPointerException"</span> new-s)
      (mv-let (mstatus exceptionname new-s2)
              (monitorexit obj-ref (ADVANCE-PC new-s))
              (<span class="keyword">if</span> (equal mstatus 'MonitorStatusError)
                  (raise-exception exceptionname s)
              new-s2)))))


<span class="comment">; NOTE:
;
; Defensive: 
;
;
; BCV:
;
; Informal Proof:
;
;;---------------------------------------------------------------------
</span>
<span class="comment">;---------------------------------------------------------------------
;;   (4 (multianewarray (array (array byte)) 2))
;
; FIXME: resolution may raise exception, current ignored.  The new-multiarray
;        may cause exception, however, now it is a fatal error
</span>


(<span class="keyword">defun</span> <span class="function-name">multiarray-measure</span> (counts length)
  (<span class="keyword">if</span> (zp length)
      (cons (cons (+ (len counts) 1) 0) 0)
    (cons (cons (+ (len counts) 1) 0) (+ length 1))))



(mutual-recursion 
 (<span class="keyword">defun</span> <span class="function-name">make-multiarray1</span> (array-type counts s)
   (<span class="keyword">declare</span> (xargs <span class="builtin">:measure</span> (multiarray-measure counts 0)))
   (<span class="keyword">if</span> (endp counts)
       (pushStack -1 s)  
     <span class="comment">;; with the array-ref on the top of the stack
</span>     (mv-let (obj-refs s1)
             (make-multiarray2 (array-base-type array-type)
                               (cdr counts) 
                               (car counts) 
                               s)
             <span class="comment">;; first create all elements of the array
</span>             (<span class="keyword">let*</span> ((s2 (new-array (array-base-type array-type) 
                                   (car counts)
                                   s1))
                    (array-ref (topStack s2))
                    (s3 (set-array-content obj-refs array-ref s2)))
               s3))))

 (<span class="keyword">defun</span> <span class="function-name">make-multiarray2</span> (array-type counts length s)
   (<span class="keyword">declare</span> (xargs <span class="builtin">:measure</span> (multiarray-measure counts length)))
   (<span class="keyword">if</span> (zp length)
       (mv nil s)
     (mv-let (obj-refs new-s)
             (make-multiarray2 array-type counts (- length 1) s)
             (<span class="keyword">let*</span> ((new-s2 (make-multiarray1 array-type counts new-s))
                    (obj-ref (topStack new-s2)))
               (mv (cons obj-ref obj-refs) (popStack new-s2)))))))


<span class="comment">;; bytecode verifier would ensure the array-type is actually has more depths
;; than dim, here we check the runtime data from stack to ensure there are 
</span>(<span class="keyword">defun</span> <span class="function-name">multiarray-stack-non-negative</span> (dim s)
  (<span class="keyword">if</span> (zp dim)
      t
    (<span class="keyword">if</span> (&lt; (topStack s) 0)
        nil
      (multiarray-stack-non-negative (- dim 1) (popStack s)))))
  






<span class="comment">;; similiar to new-array, assume exception is not thrown here.
</span>(<span class="keyword">defun</span> <span class="function-name">new-multiarray</span> (array-type dim s)
  (<span class="keyword">if</span> (multiarray-stack-non-negative dim s)
      (m6-internal-error <span class="string">"new-multiarray precondition violated"</span> s)
    (<span class="keyword">let</span> ((counts (reverse (take dim (operand-stack (current-frame s))))))
      (make-multiarray1 array-type counts s))))
    









(<span class="keyword">defun</span> <span class="function-name">execute-multianewarray</span> (<a href="../DJVM/INST/inst.lisp.html">inst</a> s)
  (<span class="keyword">let*</span> ((type  (normalize-type-rep (arg <a href="../DJVM/INST/inst.lisp.html">inst</a>))) <span class="comment">;; strip off the class
</span>         (dim   (arg2 <a href="../DJVM/INST/inst.lisp.html">inst</a>))
         (new-s (resolveClassReference type s))) <span class="comment">;; load all related classes.
</span>    <span class="comment">;; should check exception. currently ignored
</span>    (ADVANCE-PC (new-multiarray type dim new-s))))

<span class="comment">; NOTE: 
;
;    will access control be checked at runtime??
;    no. always from the current class to ... 
;    how about array access? no runtime.
;    size for each dimension must be positive. (must be checked at runtime)
;    
;    the dim tells how many argument is provided. 
;    while, the type tell the actual dimension of the array.
;   
;    the type can be class, array, interfaces 
;
; Defensive: access control? 
;    
;
; BCV:  
;
; Informal Proof:
;
;---------------------------------------------------------------------
</span>

<span class="comment">;---------------------------------------------------------------------
;-------------------------        N         --------------------------
;---------------------------------------------------------------------
</span>
<span class="comment">;---------------------------------------------------------------------
</span>
(<span class="keyword">defun</span> <span class="function-name">execute-new</span> (<a href="../DJVM/INST/inst.lisp.html">inst</a> s)
  (mylet* ((classname (normalize-type-rep (arg <a href="../DJVM/INST/inst.lisp.html">inst</a>)))
           (new-s     (resolveClassReference classname s))
           (class-rep  (class-by-name classname (instance-class-table new-s)))
           (accessflags (class-accessflags class-rep)))
    (<span class="keyword">if</span> (or (class-rep-in-error-state? class-rep)
            (mem '*interface* accessflags)
            (mem '*abstract*  accessflags))
        (fatalError <span class="string">"bad class can't instantiate"</span> new-s) 
      <span class="comment">;; the conflict between fatal error and exception.
</span>      (<span class="keyword">if</span> (not (class-initialized? classname new-s))
          (reschedule (initializeClass classname new-s))
        (mv-let (new-obj-ref new-s2)
                (new-instance classname new-s)
                (ADVANCE-PC (pushStack new-obj-ref new-s2)))))))


<span class="comment">; NOTE:  
;    non defensive version just assume the class resolved is not array,
;    or interface etc. 
;
;    JVM spec says if the class init failed, execute new may behave like
;    exception are thrown at this instruction. 
;
;    currently class our class initialization implementation won't unroll pass
;    a native call, if class initialization method thrown exception, fail error
;    accurs.
;
; Defensive: 
;
;   check whether it is interface or a array type. 
;   if not accessible, throw error, (access control are the same with non
;   defensive machine)
;   
;
; BCV:
;
;    need to check we are not call new on an array type
;  
; Informal Proof:
;
;    similarity between BCV and defensive and 
;    between defensive and non defensive
;
;;---------------------------------------------------------------------
</span>
<span class="comment">;---------------------------------------------------------------------
</span>          
<span class="comment">;; create primitive array. 
;; assuming primitiveArray types are preloaded.      
;; (newarray CHAR)
;; we could in fact check for that.
</span>(<span class="keyword">defun</span> <span class="function-name">execute-newarray</span> (<a href="../DJVM/INST/inst.lisp.html">inst</a> s)
  (<span class="keyword">let*</span> ((basetype    (arg <a href="../DJVM/INST/inst.lisp.html">inst</a>))
         (arraylength (topStack s)))
    (ADVANCE-PC (new-array basetype arraylength (popStack s)))))

<span class="comment">; NOTE:
;
;     check the count on the op stack 
;
; Defensive: 
;    
;        
;  
; BCV:
; 
;    just make sure the type refered by instruction is a primitive type. 
;
; Informal Proof:
;
;;---------------------------------------------------------------------
</span>

<span class="comment">;---------------------------------------------------------------------
</span>

(<span class="keyword">defun</span> <span class="function-name">execute-NOP</span> (<a href="../DJVM/INST/inst.lisp.html">inst</a> s)
  (ADVANCE-PC s))


<span class="comment">; NOTE:
;
; Defensive: 
;
;
; BCV:
;
; Informal Proof:
;
;;---------------------------------------------------------------------
</span>


<span class="comment">;---------------------------------------------------------------------
;-------------------------        P         --------------------------
;---------------------------------------------------------------------
</span>

<span class="comment">;---------------------------------------------------------------------
;
</span>
(<span class="keyword">defun</span> <span class="function-name">execute-POP</span> (<a href="../DJVM/INST/inst.lisp.html">inst</a> s)
  (ADVANCE-PC (popStack s)))

(<span class="keyword">defun</span> <span class="function-name">execute-POP2</span> (<a href="../DJVM/INST/inst.lisp.html">inst</a> s)
  (ADVANCE-PC (popStack (popStack  s))))


<span class="comment">; NOTE:
;
; Defensive: 
;
;
; BCV:
;
; Informal Proof:
;
;;---------------------------------------------------------------------
</span>

<span class="comment">;---------------------------------------------------------------------
</span>
(<span class="keyword">defun</span> <span class="function-name">execute-putfield1</span> (field-rep s)
  (<span class="keyword">let*</span> ((classname (field-classname field-rep))
         (fieldname (field-fieldname field-rep)))
    (<span class="keyword">if</span> (equal (field-size field-rep) 2)
        (<span class="keyword">let</span> ((obj-ref (topStack (popLong s))))
          (<span class="keyword">if</span> (CHECK-NULL obj-ref)
              (raise-exception <span class="string">"java.lang.NullPointerException"</span> s)
            (m6-putfield classname fieldname 
                         (topLong s) 
                         obj-ref
                         (popStack (popLong s)))))
      (<span class="keyword">let</span> ((obj-ref (topStack (popStack s))))
        (<span class="keyword">if</span> (CHECK-NULL obj-ref)
            (raise-exception <span class="string">"java.lang.NullPointerException"</span> s)
          (m6-putfield classname fieldname 
                         (topStack s) 
                         obj-ref
                         (popStack (popStack s))))))))


(<span class="keyword">defun</span> <span class="function-name">execute-putfield</span> (<a href="../DJVM/INST/inst.lisp.html">inst</a> s)
    (<span class="keyword">let*</span> ((fieldCP (arg <a href="../DJVM/INST/inst.lisp.html">inst</a>)))
    (mv-let (field-rep new-s)
            (resolveFieldReference fieldCP s)
            (<span class="keyword">if</span> (pending-exception s)
                (raise-exception (pending-exception s) s)
              (<span class="keyword">if</span> field-rep
                  (ADVANCE-PC (execute-putfield1 field-rep new-s))
                (fatalSlotError fieldCP new-s))))))



<span class="comment">; NOTE: putfield has the same issue as access control and checking on access to
; the protected fields from the current class.
;
; Needs special handling of assign to a field of type Interface!! WRONG! 
; No special handling of assigning to an variable for type interfaces.
; 
; Defensive: 
;
;
; BCV:
;
; Informal Proof:
;
;;---------------------------------------------------------------------
</span>

<span class="comment">;---------------------------------------------------------------------
</span>


(<span class="keyword">defun</span> <span class="function-name">set-fieldvalue</span> (field-rep s)
  (<span class="keyword">if</span> (equal (static-field-size field-rep) 2)
      (<span class="keyword">let</span> ((value (topStack (popStack s)))) <span class="comment">;; where real value is stored 
</span>        (static-field-set-value value field-rep))
      (<span class="keyword">let</span> ((value (topStack s))) <span class="comment">;; where real value is stored 
</span>        (static-field-set-value value field-rep))))
    


(<span class="keyword">defun</span> <span class="function-name">replace-static-fields-entry</span> (old new tt)
  (<span class="keyword">if</span> (endp tt)
      nil
    (<span class="keyword">if</span> (equal (car tt) old)
        (cons new (cdr tt))
      (cons (car tt) (replace-static-fields-entry old new (cdr tt))))))



<span class="comment">;; this field-rep must be static 
</span>(<span class="keyword">defun</span> <span class="function-name">execute-putstatic1</span> (old-field-rep s)
  (<span class="keyword">let*</span> ((classname (static-field-classname old-field-rep))
         (old-instance-class-table (instance-class-table s))
         (old-class-rep (class-by-name classname old-instance-class-table))
         (old-static-fields (static-fields old-class-rep))
         (new-field-rep  (set-fieldvalue old-field-rep s))
         (new-static-fields (replace-static-fields-entry old-field-rep
                                                         new-field-rep
                                                         old-static-fields))
         (new-class-rep (class-rep-set-static-fields new-static-fields
                                                     old-class-rep))
         (new-instance-class-table (replace-class-table-entry old-class-rep
                                                              new-class-rep
                                                              old-instance-class-table)))
    (<span class="keyword">if</span> (equal (static-field-size old-field-rep) 2)
        (state-set-instance-class-table new-instance-class-table (popLong s))
      (state-set-instance-class-table new-instance-class-table (popStack s)))))
      
                                                              
                                                              
  


(<span class="keyword">defun</span> <span class="function-name">execute-putstatic</span> (<a href="../DJVM/INST/inst.lisp.html">inst</a> s)
  (<span class="keyword">let*</span> ((fieldCP (arg <a href="../DJVM/INST/inst.lisp.html">inst</a>)))
    (mv-let (field-rep new-s)
            (resolveStaticFieldReference fieldCP s)
            (<span class="keyword">if</span> (pending-exception s)
                (raise-exception (pending-exception s) s)
              (<span class="keyword">if</span> field-rep
                  (<span class="keyword">let*</span> ((field-class-rep (static-field-class-rep field-rep s))
                         (fclassname      (classname field-class-rep)))
                    (<span class="keyword">if</span> (not (class-initialized? fclassname  new-s))
                        (reschedule (initializeClass fclassname new-s)) <span class="comment">;; re-execute the same instruction. 
</span>                      (<span class="keyword">if</span> (class-rep-in-error-state? field-class-rep)
                          (fatalError <span class="string">"initialized class expected"</span> new-s)
                        (ADVANCE-PC (execute-putstatic1 field-rep new-s)))))
                   (fatalSlotError fieldCP new-s))))))

<span class="comment">; NOTE:
;    put static can cause class initialization. .. (happening in both defensive
;    and non defensive machine
;
; Defensive: 
;
;
; BCV:
;
; Informal Proof:
;
;;---------------------------------------------------------------------
</span>

<span class="comment">;---------------------------------------------------------------------
;-------------------------        R         --------------------------
;---------------------------------------------------------------------
</span>
<span class="comment">;---------------------------------------------------------------------
</span>
(<span class="keyword">defun</span> <span class="function-name">execute-ret</span> (<a href="../DJVM/INST/inst.lisp.html">inst</a> s)
  (<span class="keyword">let</span> ((retAddrReg (arg <a href="../DJVM/INST/inst.lisp.html">inst</a>)))
    (state-set-pc (LLP retAddrReg) s)))


<span class="comment">; NOTE:
;
;     RET jump to a location of type returnAddress 
;     The only way to create a returnAddress type value is use jsr
;
; Defensive: 
;     
;
; BCV:
;
;     not present in the CLDC version 
;
; Informal Proof:
;
;;---------------------------------------------------------------------
</span>
<span class="comment">;---------------------------------------------------------------------
;-------------------------        S         --------------------------
;---------------------------------------------------------------------
</span>
<span class="comment">;---------------------------------------------------------------------
</span>
(<span class="keyword">defun</span> <span class="function-name">execute-SALOAD</span> (<a href="../DJVM/INST/inst.lisp.html">inst</a> s)
  (<span class="keyword">let*</span> ((index (topStack s))
         (array-ref (secondStack s)))
    (<span class="keyword">if</span> (CHECK-NULL array-ref)
        (raise-exception <span class="string">"java.lang.NullPointerException"</span> s)
      (<span class="keyword">if</span> (check-array array-ref index s)
          (ADVANCE-PC (pushStack (int-fix (element-at-array index array-ref s))
                                 (popStack (popStack s))))
      (raise-exception <span class="string">"java.lang.ArrayIndexOutOfBoundsException"</span> s)))))

<span class="comment">; NOTE:
;   
;  nothing special, only remark is when a value is loaded, it is sign extended
;  to int. 
;
;  Global invariant should say, an array of short always contains a array of
;  values that can be represented in 16 bits 
; 
;  Care must be taken to ensure that satore to preserve the invariant.
;
; Defensive: 
;  
;  
;
; BCV:
;
; Informal Proof:
;
;;---------------------------------------------------------------------
</span>
<span class="comment">;---------------------------------------------------------------------
;; need some n-fix value
</span>(<span class="keyword">defun</span> <span class="function-name">execute-SASTORE</span> (<a href="../DJVM/INST/inst.lisp.html">inst</a> s)
  (<span class="keyword">let*</span> ((value (topStack s))
         (index (secondStack s))
         (array-ref (thirdStack s)))
    (<span class="keyword">if</span> (CHECK-NULL array-ref)
        (raise-exception <span class="string">"java.lang.NullPointerException"</span> s)
      (<span class="keyword">if</span> (check-array array-ref index s)
          (ADVANCE-PC (popStack 
                       (popStack 
                         (popStack (set-element-at-array index (short-fix value) array-ref s)))))
      (raise-exception <span class="string">"java.lang.ArrayIndexOutOfBoundsException"</span> s)))))


<span class="comment">; NOTE:
;
; Defensive: 
;
;
; BCV:
;
; Informal Proof:
;
;;---------------------------------------------------------------------
</span>
<span class="comment">;---------------------------------------------------------------------
</span>(<span class="keyword">defun</span> <span class="function-name">execute-SIPUSH</span> (<a href="../DJVM/INST/inst.lisp.html">inst</a> s)
  (ADVANCE-PC (pushStack (int-fix (arg <a href="../DJVM/INST/inst.lisp.html">inst</a>)) s)))

<span class="comment">; NOTE:
;
;   assume sipush valid <a href="../DJVM/INST/inst.lisp.html">inst</a>ruction. (arg <a href="../DJVM/INST/inst.lisp.html">inst</a>) in range of short
;   int-fix of not does not matter
;
; Defensive: 
;
;
; BCV:
;
; Informal Proof:
;
;;---------------------------------------------------------------------
</span>
<span class="comment">;---------------------------------------------------------------------
</span>
(<span class="keyword">defun</span> <span class="function-name">execute-SWAP</span> (<a href="../DJVM/INST/inst.lisp.html">inst</a> s)
  (ADVANCE-PC (pushStack (secondStack s)
                         (pushStack (topStack s)
                                    (popStack (popStack s))))))

<span class="comment">; NOTE:
;
;   only works when top two are category 1
;   note: in a defensive machine, values are tagged with data. 
;
; Defensive: 
;
;
; BCV:
;
; Informal Proof:
;
;;---------------------------------------------------------------------
</span>
<span class="comment">;---------------------------------------------------------------------
;-------------------------        T         --------------------------
;---------------------------------------------------------------------
</span>
<span class="comment">;---------------------------------------------------------------------
; 
</span>
(<span class="keyword">defun</span> <span class="function-name">tableswitch-default-target</span> (tableswitchinfo)
  (nth 1 tableswitchinfo))

(<span class="keyword">defun</span> <span class="function-name">tableswitch-low-range</span> (tableswitchinfo)
  (car (nth 2 tableswitchinfo)))

(<span class="keyword">defun</span> <span class="function-name">tableswitch-high-range</span> (tableswitchinfo)
  (cdr (nth 2 tableswitchinfo)))

(<span class="keyword">defun</span> <span class="function-name">tableswitch-table</span> (tableswitchinfo)
  (nth 3 tableswitchinfo))

(<span class="keyword">defun</span> <span class="function-name">lookup-tableswitch</span> (index tableswitchinfo)
  (<span class="keyword">let*</span> ((default (tableswitch-default-target tableswitchinfo))
         (low     (tableswitch-low-range tableswitchinfo))
         (high    (tableswitch-high-range tableswitchinfo)))
    (<span class="keyword">cond</span> ((and (&lt;= low index)
                (&lt;= index high))
           (nth (- index low) (tableswitch-table tableswitchinfo)))
          (t default))))


(<span class="keyword">defun</span> <span class="function-name">execute-tableswitch</span> (<a href="../DJVM/INST/inst.lisp.html">inst</a> s)
  (state-set-pc (lookup-tableswitch (topStack s)
                                    (arg <a href="../DJVM/INST/inst.lisp.html">inst</a>))
                (popStack s)))


<span class="comment">; NOTE:
;
; Defensive: 
;
; BCV:
;
; Informal Proof:
;
;;---------------------------------------------------------------------
</span>

<span class="comment">;---------------------------------------------------------------------
;-------------------------        W         --------------------------
;---------------------------------------------------------------------
</span>
<span class="comment">;
; WIDE is eliminated by jvm2acl2 
;
</span>
<span class="comment">;====================== OLD STUFF ====================
</span>

<span class="comment">;;; use top to indicate long value.
</span>
(<span class="keyword">defun</span> <span class="function-name">execute-CUSTOMCODE</span> (<a href="../DJVM/INST/inst.lisp.html">inst</a> s)
  (<span class="keyword">declare</span> (ignore <a href="../DJVM/INST/inst.lisp.html">inst</a>))
  (invoke-CUSTOMCODE s))


<span class="comment">;;---
</span>

<span class="comment">;; assume already resolved the offset into absolute addresses.
;; 
</span>


<span class="comment">;; The purpose of VMSAVE and VMSTORE is to use model context switches before
;; invoking a method that might cause context switch, we need to store the
;; current context. 
</span>
<span class="comment">;; VMSAVE and VMSTORE is used for debug purprose? have local ip, global ip.
;;
;; save the current addresses, when we pop_off the frame, VMRESTORE will
;; reloaded the 
</span>


<span class="comment">;; in real jvm a alivethread count is maintained.  in ours, which cares little
;; about performance, will search through the thread-table.
;; 
</span>
(<span class="keyword">defun</span> <span class="function-name">isThreadAlive</span> (thread)
  (or (mem 'thread_suspended (thread-state thread))
      (mem 'thread_active    (thread-state thread))))

(<span class="keyword">defun</span> <span class="function-name">areAliveThreads1</span> (threads)
  (<span class="keyword">if</span> (endp threads)
      nil
    (or (isThreadAlive (car threads))
        (areAliveThreads1 (cdr threads)))))

<span class="comment">;; it is possible to have suspended thread, but no active thread.
</span>
(<span class="keyword">defun</span> <span class="function-name">areAliveThreads</span> (s)
  (<span class="keyword">let</span> ((tt (thread-table s)))
    (areAliveThreads1 tt)))



<span class="comment">;;
;; I think we don't need VMSAVE and VMRESTORE ?? VMSAVE and VMRESTORE is for debugger.
;; but how about a context switch happens? 
;;
;; only when we do context switches, we need to save the current pc to
;; saved-pc, when we switch back, we need to do load Execution Env.
;; 
;; we need to record the current PC we are at to re-excute the instruction.
;; Because when context switch happens, we pushed a new frame on to call-stack
;; the return address of that frame natually recorded the 
;; 
</span>

<span class="comment">;; have a big problem of handling exception.  currently, if A calls B and B
;; raises an exception, because we don't check for exception in A, we
;; procceed.  However as required by JVM spec, we need to abruptly return from
;; A. 
</span>
<span class="comment">;; we need to add some exception detect test on any function, so that if some
;; callee return a state with exception flags on, we should return the
;; exception state until we read the top-level interpreter loop to handle it.
</span>
<span class="comment">;; let me proceed to define invokevirtua, when we add exception
;; handling. remember to change...
</span>

<span class="comment">;; this method won't cause class loading. or method initialization.
</span>
<span class="comment">;; don't check access now. 
</span>

    


 
</pre>
  </body>
</html>
