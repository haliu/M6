<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01//EN">
<!-- Created by htmlize-1.16 in css mode. -->
<html>
  <head>
    <title>ADD1-program-correct.improved.lisp</title>
    <style type="text/css">
    <!--
      body {
        color: #f5deb3;
        background-color: #000000;
      }
      .builtin {
        /* font-lock-builtin-face */
        color: #b0c4de;
      }
      .comment {
        /* font-lock-comment-face */
        color: #ff7f24;
      }
      .function-name {
        /* font-lock-function-name-face */
        color: #87cefa;
      }
      .keyword {
        /* font-lock-keyword-face */
        color: #00ffff;
      }
      .string {
        /* font-lock-string-face */
        color: #ffa07a;
      }
      a {
        color: inherit;
        background-color: inherit;
        font: inherit;
        text-decoration: inherit;
      }
      a:hover {
        text-decoration: underline;
      }
    -->
    </style>
  </head>
  <body>
    <pre>
<span class="comment">#|
public class First { 
    public static void main(String[] args) {
        int i=1; // modified to i=j 
        int j=i+1;
        i=j;
        return;
    };

};

(defconst *First*
 (make-class-def
      '(class "First"
            "java.lang.Object"
            (constant_pool)
            (fields)
            (methods
                        (method "&lt;init&gt;"
                              (parameters )
                              (returntype void)
                              (accessflags  *class*  *public* )
                              (code
                                   (max_stack 1) (max_locals 1) (code_length 5)
                                   (parsedcode
                                      (0 (aload_0))
                                      (1 (invokespecial
                                        (methodCP "&lt;init&gt;" "java.lang.Object" () void)))
                                      (4 (return))
                                      (endofcode 5))
                                   (Exceptions )
                                   (StackMap )))
                        (method "main"
                              (parameters (array (class "java.lang.String")))
                              (returntype void)
                              (accessflags  *class*  *public*  *static* )
                              (code
                                   (max_stack 2) (max_locals 3) (code_length 9)
                                   (parsedcode
                                      (0 (iconst_1)) ;; (0 (iload_2)) 
                                      (1 (istore_1))
                                      (2 (iload_1))
                                      (3 (iconst_1))
                                      (4 (iadd))
                                      (5 (istore_2))
                                      (6 (iload_2))
                                      (7 (istore_1))
                                      (8 (return))
                                      (endofcode 9))
                                   (Exceptions )
                                   (StackMap ))))
            (interfaces)
            (accessflags  *class*  *public*  *super*  *synchronized* )
            (attributes
              (attribute "SourceFile")))))
|#</span>

(<span class="keyword">in-package</span> <span class="string">"M6"</span>)


(include-book <span class="string"><a href="m6-start-jvm.lisp.html">"../M6/m6-start-jvm"</a></span>)

<span class="comment">;;; After proving the following theorem, we disable the definition of m6step.
;;; In some sense to make the only fact ACL2 know about the m6step is the
;;; following. Thus ACL2 will not be side tracked into expanding the definition
;;; of m6step all the time
;;;
;;; The following theorem says: If we know (next-inst s) is a "constant"
;;; already, we know m6step can be expanded in the following ways. 
;;;  
</span>
<span class="comment">;; (i-am-here) ;; Tue Jul  4 19:14:05 2006
</span>
(defthm do-inst-opener
  (implies (consp (next-inst s))
           (equal (m6step s)
                  (<span class="keyword">let*</span> ((<a href="../DJVM/INST/inst.lisp.html">inst</a> (next-<a href="../DJVM/INST/inst.lisp.html">inst</a> s))
                         (op   (<a href="../DJVM/INST/inst.lisp.html">inst</a>-opcode <a href="../DJVM/INST/inst.lisp.html">inst</a>)))
                    (<span class="keyword">if</span> (no-fatal-error? s)
                        (prog2$ (acl2::cw <span class="string">"thread ~p0 executing <a href="../DJVM/INST/inst.lisp.html">inst</a> ~p1~%Current pc ~p2~%"</span>
                                                   (current-thread s) <a href="../DJVM/INST/inst.lisp.html">inst</a> (pc s))
                                (<span class="keyword">if</span> (equal op 'invalid-op-code) <span class="comment">;; shouldn't happen if verified.
</span>                                    (fatalError  <span class="string">"impossible: opcode invalid"</span> s)
                                  (<span class="keyword">if</span> (equal op 'JVM::INVALID-INST-OFFSET)
                                      (fatalError  <span class="string">"impossible: fall off the method"</span> s)
                                    (<span class="keyword">case</span>  op 
                                      (NOP        (execute-NOP        <a href="../DJVM/INST/inst.lisp.html">inst</a> s))
                                      (ICONST_M1  (execute-ICONST_M1  <a href="../DJVM/INST/inst.lisp.html">inst</a> s))
                                      (ICONST_0   (execute-ICONST_0   <a href="../DJVM/INST/inst.lisp.html">inst</a> s))
                                      (ICONST_1   (execute-ICONST_1   <a href="../DJVM/INST/inst.lisp.html">inst</a> s))
                                      (ICONST_2   (execute-ICONST_2   <a href="../DJVM/INST/inst.lisp.html">inst</a> s))
                                      (ICONST_3   (execute-ICONST_3   <a href="../DJVM/INST/inst.lisp.html">inst</a> s))
                                      (ICONST_4   (execute-ICONST_4   <a href="../DJVM/INST/inst.lisp.html">inst</a> s))
                                      (ICONST_5   (execute-ICONST_5   <a href="../DJVM/INST/inst.lisp.html">inst</a> s))
                                      (LCONST_0   (execute-LCONST_0   <a href="../DJVM/INST/inst.lisp.html">inst</a> s))
                                      (LCONST_1   (execute-LCONST_1   <a href="../DJVM/INST/inst.lisp.html">inst</a> s))
                                    
                                      (<a href="../DJVM/INST/ACONST_NULL.lisp.html">ACONST_NULL</a> (execute-<a href="../DJVM/INST/ACONST_NULL.lisp.html">ACONST_NULL</a> <a href="../DJVM/INST/inst.lisp.html">inst</a> s))
                                      (BIPUSH     (execute-BIPUSH     <a href="../DJVM/INST/inst.lisp.html">inst</a> s))
                                      (SIPUSH     (execute-SIPUSH     <a href="../DJVM/INST/inst.lisp.html">inst</a> s))
                                      (LDC        (execute-LDC        <a href="../DJVM/INST/inst.lisp.html">inst</a> s))             
                                      (ILOAD      (execute-ILOAD      <a href="../DJVM/INST/inst.lisp.html">inst</a> s))
                                      (LLOAD      (execute-LLOAD      <a href="../DJVM/INST/inst.lisp.html">inst</a> s))
                                      (<a href="../DJVM/INST/ALOAD.lisp.html">ALOAD</a>      (execute-<a href="../DJVM/INST/ALOAD.lisp.html">ALOAD</a>      <a href="../DJVM/INST/inst.lisp.html">inst</a> s))
                                      (ILOAD_0    (execute-ILOAD_0    <a href="../DJVM/INST/inst.lisp.html">inst</a> s))
                                      (ILOAD_1    (execute-ILOAD_1    <a href="../DJVM/INST/inst.lisp.html">inst</a> s))
                                      (ILOAD_2    (execute-ILOAD_2    <a href="../DJVM/INST/inst.lisp.html">inst</a> s))             
                                      (ILOAD_3    (execute-ILOAD_3    <a href="../DJVM/INST/inst.lisp.html">inst</a> s))             
                                      (ALOAD_0    (execute-ALOAD_0    <a href="../DJVM/INST/inst.lisp.html">inst</a> s))
                                      (ALOAD_1    (execute-ALOAD_1    <a href="../DJVM/INST/inst.lisp.html">inst</a> s))
                                      (ALOAD_2    (execute-ALOAD_2    <a href="../DJVM/INST/inst.lisp.html">inst</a> s))
                                      (ALOAD_3    (execute-ALOAD_3    <a href="../DJVM/INST/inst.lisp.html">inst</a> s))
                                      (IALOAD     (execute-IALOAD     <a href="../DJVM/INST/inst.lisp.html">inst</a> s))
                                      (LALOAD     (execute-LALOAD     <a href="../DJVM/INST/inst.lisp.html">inst</a> s))
                                      (<a href="../DJVM/INST/AALOAD.lisp.html">AALOAD</a>     (execute-<a href="../DJVM/INST/AALOAD.lisp.html">AALOAD</a>     <a href="../DJVM/INST/inst.lisp.html">inst</a> s))
                                      (BALOAD     (execute-BALOAD     <a href="../DJVM/INST/inst.lisp.html">inst</a> s))
                                      (ISTORE     (execute-ISTORE     <a href="../DJVM/INST/inst.lisp.html">inst</a> s))
                                      (LSTORE     (execute-LSTORE     <a href="../DJVM/INST/inst.lisp.html">inst</a> s))
                                      (<a href="../DJVM/INST/ASTORE.lisp.html">ASTORE</a>     (execute-<a href="../DJVM/INST/ASTORE.lisp.html">ASTORE</a>     <a href="../DJVM/INST/inst.lisp.html">inst</a> s))
                                      (ISTORE_0   (execute-ISTORE_0   <a href="../DJVM/INST/inst.lisp.html">inst</a> s))
                                      (ISTORE_1   (execute-ISTORE_1   <a href="../DJVM/INST/inst.lisp.html">inst</a> s))
                                      (ISTORE_2   (execute-ISTORE_2   <a href="../DJVM/INST/inst.lisp.html">inst</a> s))
                                      (ISTORE_3   (execute-ISTORE_3   <a href="../DJVM/INST/inst.lisp.html">inst</a> s))
                                      (LSTORE_0   (execute-LSTORE_0   <a href="../DJVM/INST/inst.lisp.html">inst</a> s))
                                      (LSTORE_1   (execute-LSTORE_1   <a href="../DJVM/INST/inst.lisp.html">inst</a> s))
                                      (LSTORE_2   (execute-LSTORE_2   <a href="../DJVM/INST/inst.lisp.html">inst</a> s))
                                      (LSTORE_3   (execute-LSTORE_3   <a href="../DJVM/INST/inst.lisp.html">inst</a> s))
                                      (ASTORE_0   (execute-ASTORE_0   <a href="../DJVM/INST/inst.lisp.html">inst</a> s))
                                      (ASTORE_1   (execute-ASTORE_1   <a href="../DJVM/INST/inst.lisp.html">inst</a> s))
                                      (ASTORE_2   (execute-ASTORE_2   <a href="../DJVM/INST/inst.lisp.html">inst</a> s))
                                      (ASTORE_3   (execute-ASTORE_3   <a href="../DJVM/INST/inst.lisp.html">inst</a> s))

                                      (IASTORE    (execute-IASTORE    <a href="../DJVM/INST/inst.lisp.html">inst</a> s))
                                    
                                      (LASTORE    (execute-LASTORE    <a href="../DJVM/INST/inst.lisp.html">inst</a> s))
                                      (<a href="../DJVM/INST/AASTORE.lisp.html">AASTORE</a>    (execute-<a href="../DJVM/INST/AASTORE.lisp.html">AASTORE</a>    <a href="../DJVM/INST/inst.lisp.html">inst</a> s))
                                      (BASTORE    (execute-BASTORE    <a href="../DJVM/INST/inst.lisp.html">inst</a> s))
             
                                      (CALOAD     (execute-CALOAD     <a href="../DJVM/INST/inst.lisp.html">inst</a> s))
                                      (CASTORE    (execute-CASTORE    <a href="../DJVM/INST/inst.lisp.html">inst</a> s))
                                      (SASTORE    (execute-SASTORE    <a href="../DJVM/INST/inst.lisp.html">inst</a> s))
                                      (POP        (execute-POP        <a href="../DJVM/INST/inst.lisp.html">inst</a> s))
                                      (POP2       (execute-POP2       <a href="../DJVM/INST/inst.lisp.html">inst</a> s))
                                      (DUP        (execute-DUP        <a href="../DJVM/INST/inst.lisp.html">inst</a> s))             
                                      (DUP_X1     (execute-DUP_X1     <a href="../DJVM/INST/inst.lisp.html">inst</a> s))             
                                      (DUP_X2     (execute-DUP_X2     <a href="../DJVM/INST/inst.lisp.html">inst</a> s))
                                      (DUP2       (execute-DUP2       <a href="../DJVM/INST/inst.lisp.html">inst</a> s))             
                                      (DUP2_X1    (execute-DUP2_X1    <a href="../DJVM/INST/inst.lisp.html">inst</a> s))             
                                      (DUP2_X2    (execute-DUP2_X2    <a href="../DJVM/INST/inst.lisp.html">inst</a> s))
                                      (SWAP       (execute-SWAP       <a href="../DJVM/INST/inst.lisp.html">inst</a> s))
                                      (IADD       (execute-IADD       <a href="../DJVM/INST/inst.lisp.html">inst</a> s))             
                                      (LADD       (execute-LADD       <a href="../DJVM/INST/inst.lisp.html">inst</a> s))             
                                      (LCMP       (execute-LCMP       <a href="../DJVM/INST/inst.lisp.html">inst</a> s))             
                                      (ISUB       (execute-ISUB       <a href="../DJVM/INST/inst.lisp.html">inst</a> s))             
                                      (IMUL       (execute-IMUL       <a href="../DJVM/INST/inst.lisp.html">inst</a> s))             
                                      (IDIV       (execute-IDIV       <a href="../DJVM/INST/inst.lisp.html">inst</a> s))             
                                      (IREM       (execute-IREM       <a href="../DJVM/INST/inst.lisp.html">inst</a> s))
                                      (INEG       (execute-INEG       <a href="../DJVM/INST/inst.lisp.html">inst</a> s))             
                                      (IINC       (execute-IINC       <a href="../DJVM/INST/inst.lisp.html">inst</a> s))
                                    
                                      (NEWARRAY    (execute-NEWARRAY    <a href="../DJVM/INST/inst.lisp.html">inst</a> s))
                                      (ARRAYLENGTH (execute-ARRAYLENGTH <a href="../DJVM/INST/inst.lisp.html">inst</a> s))
             
             
                                      (MONITORENTER (execute-MONITORENTER <a href="../DJVM/INST/inst.lisp.html">inst</a> s))
                                      (MONITOREXIT  (execute-MONITOREXIT  <a href="../DJVM/INST/inst.lisp.html">inst</a> s))
                                    
                                      (CHECKCAST    (execute-CHECKCAST    <a href="../DJVM/INST/inst.lisp.html">inst</a> s))
                                    
                                      (CUSTOMCODE (execute-CUSTOMCODE <a href="../DJVM/INST/inst.lisp.html">inst</a> s))

                                      (ISTORE_1   (execute-ISTORE_1   <a href="../DJVM/INST/inst.lisp.html">inst</a> s))
                                    
                                      (ISTORE_2   (execute-ISTORE_2   <a href="../DJVM/INST/inst.lisp.html">inst</a> s))

                                      (IADD       (execute-IADD       <a href="../DJVM/INST/inst.lisp.html">inst</a> s))
                                      (NEW        (execute-NEW        <a href="../DJVM/INST/inst.lisp.html">inst</a> s))

                                      (LDC        (execute-LDC        <a href="../DJVM/INST/inst.lisp.html">inst</a> s))
                                      (INVOKESPECIAL  (execute-INVOKESPECIAL <a href="../DJVM/INST/inst.lisp.html">inst</a> s))
                                      (INVOKESTATIC   (execute-INVOKESTATIC <a href="../DJVM/INST/inst.lisp.html">inst</a> s))
                                      (INVOKEVIRTUAL   (execute-INVOKEVIRTUAL <a href="../DJVM/INST/inst.lisp.html">inst</a> s))
                                      (INVOKEINTERFACE (execute-INVOKEINTERFACE <a href="../DJVM/INST/inst.lisp.html">inst</a> s))
                                      (ASTORE_3     (execute-ASTORE_3   <a href="../DJVM/INST/inst.lisp.html">inst</a> s))
                                      (ALOAD_0    (execute-ALOAD_0 <a href="../DJVM/INST/inst.lisp.html">inst</a> s))

                                      (PUTFIELD   (execute-PUTFIELD <a href="../DJVM/INST/inst.lisp.html">inst</a> s))
                                      (<a href="../DJVM/INST/GETFIELD.lisp.html">GETFIELD</a>   (execute-<a href="../DJVM/INST/GETFIELD.lisp.html">GETFIELD</a> <a href="../DJVM/INST/inst.lisp.html">inst</a> s))

                                      (GETSTATIC  (execute-GETSTATIC <a href="../DJVM/INST/inst.lisp.html">inst</a> s))
                                      (PUTSTATIC  (execute-PUTSTATIC <a href="../DJVM/INST/inst.lisp.html">inst</a> s))

                                      (CASTORE    (execute-CASTORE   <a href="../DJVM/INST/inst.lisp.html">inst</a> s))
                                      (PUTSTATIC  (execute-PUTSTATIC <a href="../DJVM/INST/inst.lisp.html">inst</a> s))
                                      (IFNULL     (execute-IFNULL      <a href="../DJVM/INST/inst.lisp.html">inst</a> s))
                                      (IFNONNULL  (execute-IFNONNULL   <a href="../DJVM/INST/inst.lisp.html">inst</a> s))
                                      (<a href="../DJVM/INST/IFEQ.lisp.html">IFEQ</a>       (execute-<a href="../DJVM/INST/IFEQ.lisp.html">IFEQ</a>        <a href="../DJVM/INST/inst.lisp.html">inst</a> s))
                                      (IFNE       (execute-IFNE        <a href="../DJVM/INST/inst.lisp.html">inst</a> s))
                                      (IFLT      (execute-IFLT        <a href="../DJVM/INST/inst.lisp.html">inst</a> s))
                                      (IFGE      (execute-IFGE        <a href="../DJVM/INST/inst.lisp.html">inst</a> s))
                                      (IFGT      (execute-IFGT        <a href="../DJVM/INST/inst.lisp.html">inst</a> s))
                                      (IFLE      (execute-IFLE        <a href="../DJVM/INST/inst.lisp.html">inst</a> s))
                                      (IF_ICMPEQ  (execute-IF_ICMPEQ    <a href="../DJVM/INST/inst.lisp.html">inst</a> s))
                                      (IF_ICMPNE  (execute-IF_ICMPNE    <a href="../DJVM/INST/inst.lisp.html">inst</a> s))
                                      (IF_ICMPLT  (execute-IF_ICMPLT    <a href="../DJVM/INST/inst.lisp.html">inst</a> s))
                                      (IF_ICMPGE  (execute-IF_ICMPGE    <a href="../DJVM/INST/inst.lisp.html">inst</a> s))
                                      (IF_ICMPGT  (execute-IF_ICMPGT    <a href="../DJVM/INST/inst.lisp.html">inst</a> s))
                                      (IF_ICMPLE  (execute-IF_ICMPLE    <a href="../DJVM/INST/inst.lisp.html">inst</a> s))
                                      (GOTO       (execute-GOTO         <a href="../DJVM/INST/inst.lisp.html">inst</a> s))
                                      (IRETURN    (execute-RETURN       <a href="../DJVM/INST/inst.lisp.html">inst</a> s 1))  
                                      (RETURN     (execute-RETURN       <a href="../DJVM/INST/inst.lisp.html">inst</a> s 0))
                                      (ARETURN    (execute-RETURN       <a href="../DJVM/INST/inst.lisp.html">inst</a> s 1))
                                      (ATHROW     (execute-ATHROW       <a href="../DJVM/INST/inst.lisp.html">inst</a> s))
                                      (JSR        (execute-JSR          <a href="../DJVM/INST/inst.lisp.html">inst</a> s))
                                      (RET        (execute-RET          <a href="../DJVM/INST/inst.lisp.html">inst</a> s))
                                      (t s)))))
                      s))))
                  <span class="builtin">:hints</span> ((<span class="string">"Goal"</span> <span class="builtin">:in-theory</span> (cons 'm6step (disable   
                                    execute-NOP       
                                    execute-ICONST_M1 
                                    execute-ICONST_0  
                                    execute-ICONST_1  
                                    execute-ICONST_2  
                                    execute-ICONST_3  
                                    execute-ICONST_4  
                                    execute-ICONST_5  
                                    execute-LCONST_0   
                                    execute-LCONST_1   
                                                       
                                    execute-ACONST_NULL
                                                       
                                    execute-BIPUSH     
                                    execute-SIPUSH     
                                    execute-LDC           
                                    execute-ILOAD      
                                    execute-LLOAD      
                                    execute-ALOAD      
                                    execute-ILOAD_0    
                                    execute-ILOAD_1    
                                    execute-ILOAD_2       
                                    execute-ILOAD_3       
                                    execute-ALOAD_0    
                                    execute-ALOAD_1    
                                    execute-ALOAD_2    
                                    execute-ALOAD_3    
                                    execute-CALOAD
                                    execute-IALOAD     
                                    execute-LALOAD     
                                    execute-AALOAD     
                                    execute-BALOAD     
                                    execute-ISTORE     
                                    execute-LSTORE     
                                    execute-ASTORE     
                                    execute-ISTORE_0   
                                    execute-ISTORE_1   
                                    execute-ISTORE_2   
                                    execute-ISTORE_3   
                                    execute-LSTORE_0   
                                    execute-LSTORE_1   
                                    execute-LSTORE_2   
                                    execute-LSTORE_3   
                                    execute-ASTORE_0   
                                    execute-ASTORE_1   
                                    execute-ASTORE_2   
                                    execute-ASTORE_3   
                                    execute-IASTORE    
                                    execute-LASTORE    
                                    execute-AASTORE    
                                    execute-BASTORE    
                                    execute-CASTORE    
                                    execute-SASTORE    
                                    execute-POP        
                                    execute-POP2       
                                    execute-DUP           
                                    execute-DUP_X1        
                                    execute-DUP_X2     
                                    execute-DUP2          
                                    execute-DUP2_X1       
                                    execute-DUP2_X2    
                                    execute-SWAP       
                                    execute-IADD          
                                    execute-LADD          
                                    execute-LCMP
                                    execute-ISUB          
                                    execute-IMUL          
                                    execute-IDIV          
                                    execute-INEG          
                                    execute-IINC       
                                                       
                                    execute-NEWARRAY   
                                    execute-ARRAYLENGTH
                                                       
                                                       
                                    execute-MONITORENTER
                                    execute-MONITOREXIT
                                                       
                                    execute-CHECKCAST  
                                                       
                                    execute-CUSTOMCODE 
                                                       
                                    execute-ISTORE_1   
                                                       
                                    execute-ISTORE_2   
                                                       
                                    execute-IADD       
                                    execute-NEW        
                                                       
                                    execute-LDC        
                                    execute-INVOKESPECIAL
                                    execute-INVOKESTATIC
                                    execute-INVOKEVIRTUAL
                                    execute-INVOKEINTERFACE
                                    execute-ASTORE_3   
                                    execute-ALOAD_0 
                                                       
                                    execute-PUTFIELD 
                                    execute-GETFIELD
                                                       
                                    execute-GETSTATIC 
                                    execute-PUTSTATIC 
                                                       
                                    execute-CASTORE   
                                    execute-PUTSTATIC 
                                    execute-IFNULL     
                                    execute-IFNONNULL  
                                    execute-IFEQ       
                                    execute-IFNE       
                                    execute-IFLT       
                                    execute-IFGE       
                                    execute-IFGT       
                                    execute-IFLE       
                                    execute-IF_ICMPEQ  
                                    execute-IF_ICMPNE  
                                    execute-IF_ICMPLT  
                                    execute-IF_ICMPGE  
                                    execute-IF_ICMPGT  
                                    execute-IF_ICMPLE  
                                    execute-GOTO       
                                    execute-RETURN     
                                    execute-RETURN     
                                    execute-RETURN     
                                    execute-ATHROW     
                                    execute-JSR    
                                    execute-IREM
                                    execute-RET)))))

(in-theory (disable m6step))

<span class="comment">;----------------------------------------------------------------------
</span>
<span class="comment">; Now we need to effectively reduce the complicated (next-inst s) into our
; intuitive understanding of it. We need to identify under what condition the
; next-inst is simply what we tend to think it is. 
</span>

<span class="comment">;;; Define a equivalence relation so that we could relatively easily talk about
;;; the next instruction, current-method-ptr, we could succinctly talk about the
;;;  initial condition 
</span>
<span class="comment">; The definition starts from call frame then going upward until we can define
; an equivalence of state. Because most of our <a href="../common/primitives.lisp.html">primitives</a> works on state, we
; need such a equivalence to characterize what does NOT change.
</span>
(<span class="keyword">defun</span> <span class="function-name">equiv-frame</span> (f1 f0)
  (and (equal (return-pc f1) (return-pc f0))
       (equal (method-ptr f1) (method-ptr f0))
       (equal (sync-obj-ref f1) (sync-obj-ref f0))))

<span class="comment">;;;  equal except for opstack and locals
</span>
(defequiv equiv-frame)   <span class="comment">;; equiv-frame is a equivalence
</span>(defcong equiv-frame equal (return-pc f) 1)
(defcong equiv-frame equal (method-ptr f) 1)
(defcong equiv-frame equal (sync-obj-ref f) 1)

(in-theory (disable equiv-frame))

<span class="comment">;----------------------------------------------------------------------
</span>
(<span class="keyword">defun</span> <span class="function-name">top-frame</span> (thread)
  (top (thread-call-stack thread)))

<span class="comment">; We define the concept of top-frame of a thread
; It allows us to take about the concept directly as an primitive.
</span>
<span class="comment">;;; It would be best if we write our JVM definition in terms of top-frame in
;;; the first place.
;;;
;;; Currently, we add this rewrite rule, so that we don't have to modify the
;;; defintions, else where.
;;; 
;;; ACL2 will handle the conversion "on the fly"
</span>
(defthm top-thread-call-stack-rewrite 
  (equal (top (thread-call-stack thread)) (top-frame thread)))

(in-theory (disable top-frame))


<span class="comment">; similarly non-top-frame, which we do not care in this proof. 
</span>
(<span class="keyword">defun</span> <span class="function-name">non-top-frames</span> (thread)
  (pop (thread-call-stack thread)))

(defthm pop-thread-call-stack-rewrite 
  (equal (pop (thread-call-stack thread)) (non-top-frames thread)))

(in-theory (disable non-top-frames))

<span class="comment">;----------------------------------------------------------------------
</span>
<span class="comment">; thread equivalence. 
</span>
(<span class="keyword">defun</span> <span class="function-name">equiv-thread-except-topframe</span> (t1 t2)
  (and (equal (thread-saved-pc t1) (thread-saved-pc t2))
       (equal (thread-mref t1) (thread-mref t2))
       (equal (thread-mdepth t1) (thread-mdepth t2))
       (equal (thread-ref t1) (thread-ref t2))
       (equal (thread-id t1) (thread-id t2))
       (equal (thread-state t1) (thread-state t2))
       (equiv-frame (top-frame t1)
                    (top-frame t2))))

<span class="comment">;; Note: We do not need to assert anything about non-top-frame!  We are only
;; talking about a straightline code that runs in one frame.
;;
</span>
(defequiv equiv-thread-except-topframe)

(defcong equiv-thread-except-topframe equiv-frame (top-frame t1) 1)
(defcong equiv-thread-except-topframe equal (thread-id t1) 1)
(defcong equiv-thread-except-topframe equal (thread-state t1) 1)
(defcong equiv-thread-except-topframe equal (thread-saved-pc t1) 1)
(defcong equiv-thread-except-topframe equal (thread-mref t1) 1)
(defcong equiv-thread-except-topframe equal (thread-mdepth t1) 1)
(defcong equiv-thread-except-topframe equal (thread-ref t1) 1)

(in-theory (disable equiv-thread-except-topframe thread-mref thread-state
                    thread-id thread-saved-pc))


(<span class="keyword">defun</span> <span class="function-name">equiv-thread-table</span> (tl1 tl2)
  (<span class="keyword">cond</span> ((endp tl1) (endp tl2))
        ((endp tl2) nil)
        ((equiv-thread-except-topframe (car tl1) (car tl2))
         (equiv-thread-table (cdr tl1) (cdr tl2)))
        (t nil)))

(defequiv equiv-thread-table)


(defcong equiv-thread-table equiv-thread-except-topframe (thread-by-id id tt)
  2)


(defcong equiv-thread-table equal (search-active-thread-in-range s e tt) 3)
<span class="comment">;;;  This is used for proving round-robin run return the same result on the
;;;  equiv-state
</span>

(<span class="keyword">defun</span> <span class="function-name">equiv-state</span> (s1 s0)
  (and (equiv-thread-table (thread-table s1) (thread-table s0))
       (equal (current-thread s1) (current-thread s0))
       (equal (error-flag s1)     (error-flag s0))
       (equal (class-table s1)    (class-table s0))
       (equal (env s1)            (env s0))
       (equal (aux s1)            (aux s0))))

(defequiv equiv-state)
(defcong equiv-state equiv-thread-table (thread-table t1) 1)
(defcong equiv-state equal (current-thread t1) 1)
(defcong equiv-state equal (error-flag t1) 1)
(defcong equiv-state equal (env t1) 1)
(defcong equiv-state equal (aux t1) 1)
(defcong equiv-state equal (instance-class-table t1) 1
  <span class="builtin">:hints</span> ((<span class="string">"Goal"</span> <span class="builtin">:in-theory</span> (enable instance-class-table))))
(defcong equiv-state equal (array-class-table t1) 1
  <span class="builtin">:hints</span> ((<span class="string">"Goal"</span> <span class="builtin">:in-theory</span> (enable array-class-table))))


(defcong equiv-state equiv-frame (current-frame s) 1
  <span class="builtin">:hints</span> ((<span class="string">"Goal"</span> <span class="builtin">:in-theory</span> (enable current-frame))))

(defcong equiv-state equal (no-fatal-error? s) 1
  <span class="builtin">:hints</span> ((<span class="string">"Goal"</span> <span class="builtin">:in-theory</span> (enable no-fatal-error?))))


(in-theory (disable equiv-state))

(defcong equiv-state equal (current-method-ptr s) 1
  <span class="builtin">:hints</span> ((<span class="string">"Goal"</span> <span class="builtin">:in-theory</span> (enable current-method-ptr))))


<span class="comment">;----------------------------------------------------------------------
</span>
(defthm non-top-frame-make-thread
  (equal (non-top-frames (make-thread id pc (cons new-frame frames) status mref
                                      mdep th-ref))
         frames)
  <span class="builtin">:hints</span> ((<span class="string">"Goal"</span> <span class="builtin">:in-theory</span> (list* 'non-top-frames 
                                    (disable POP-THREAD-CALL-STACK-REWRITE)))))

(defthm  top-frame-make-thread
  (equal (top-frame (make-thread id pc (cons new-frame frames) status mref
                                      mdep th-ref))
         new-frame)
  <span class="builtin">:hints</span> ((<span class="string">"Goal"</span> <span class="builtin">:in-theory</span> (list* 'top-frame 
                                    (disable TOP-THREAD-CALL-STACK-REWRITE)))))

(in-theory (disable aux))


(in-theory (disable thread-mdepth thread-ref))

(defthm equiv-thread-except-topframe-thread-primitives
  (and (equiv-thread-except-topframe (push-stack-of-thread v thread)
                                     thread)
       (equiv-thread-except-topframe (popStack-of-thread thread)
                                     thread)
       (equiv-thread-except-topframe (set-local-at-of-thread i v thread)
                                     thread))
  <span class="builtin">:hints</span> ((<span class="string">"Goal"</span> <span class="builtin">:in-theory</span> (enable equiv-thread-except-topframe
                                     push-stack-of-thread
                                     popStack-of-thread
                                     set-local-at-of-thread
                                     equiv-frame))))

<span class="comment">; We introduced the push-stack-of-thread, popStack-of-thread as an immediate
; <a href="../common/primitives.lisp.html">primitives</a> as a bridge between pushStack with push, popStack with pop.
</span>


(defthm equiv-thread-except-topframe-thread-primitives-2
  (and (equal (equiv-thread-except-topframe (push-stack-of-thread v thread)
                                            thread) t)
       (equal (equiv-thread-except-topframe (popStack-of-thread thread)
                                            thread) t)
       (equal (equiv-thread-except-topframe (set-local-at-of-thread i v thread)
                                            thread) t)))


<span class="comment">;;;  Ideally we may define another equivalence relation to exactly capture the 
;;;  effect of push-stack-of-thread, so property as follows will be expressed
;;;  as congruence rules on that equivalence. 
;;;
;;;  This means that we need a hierachy of equivalence. 
</span>
(defthm equal-non-top-frames-frame-op-no-change
  (and (equal (non-top-frames (push-stack-of-thread v thread))
              (non-top-frames thread))
      (equal (non-top-frames (popStack-of-thread thread))
             (non-top-frames thread))
      (equal (non-top-frames (set-local-at-of-thread i v thread))
             (non-top-frames thread)))
  <span class="builtin">:hints</span> ((<span class="string">"Goal"</span> <span class="builtin">:in-theory</span> (e/d (non-top-frames push-stack-of-thread
                                   popStack-of-thread set-local-at-of-thread)               
                                  (POP-THREAD-CALL-STACK-REWRITE
                                   top-thread-call-stack-rewrite)))))

                         

(in-theory (disable push-stack-of-thread))
(in-theory (disable popStack-of-thread))
(in-theory (disable set-local-at-of-thread))

<span class="comment">; Disable those definitions. Now to ACL2, those become <a href="../common/primitives.lisp.html">primitives</a> (just like
; those to the operator of ACL2 ---  us user)
</span>
(defthm equiv-thread-table-replace-thread-table-entry
  (implies (equiv-thread-except-topframe new-thread old-thread)
           (equiv-thread-table (replace-thread-table-entry old-thread
                                                           new-thread tt)
                               tt)))

(defthm opstack-local-primitives-preserve-equiv-state-2
  (and (equiv-state (pushStack v s) s)
       (equiv-state (popStack s) s)
       (equiv-state (state-set-local-at i v s) s)
       (equiv-state (state-set-pc npc s) s))
  <span class="builtin">:hints</span> ((<span class="string">"Goal"</span> <span class="builtin">:in-theory</span> (enable equiv-state))))



(defthm opstack-local-primitives-preserve-equiv-state-3
   (and (implies (equiv-state s1 s0)
                 (equal (equiv-state (pushStack v s1) s0) t))

        (implies (equiv-state s1 s0)
                 (equal (equiv-state (popStack s1) s0) t))

        (implies (equiv-state s1 s0)
                 (equal (equiv-state (state-set-local-at i v s1) s0) t))
        
        (implies (equiv-state s1 s0)
                 (equal (equiv-state (state-set-pc npc s1) s0) t))))

<span class="comment">;;;;; This above is some workaround for the limitation of ACL2.
</span>

(defthm pc-state-set-pc
  (equal (pc (state-set-pc ip s))
         ip))

(defthm pc-popStack
  (equal (pc (popStack s))
         (pc s)))

(defthm pc-pushStack
  (equal (pc (pushStack v s))
         (pc s)))

(defthm pc-state-set-local-at
  (equal (pc (state-set-local-at i v s))
         (pc s)))


(defthm pc-popStackN
  (equal (pc (popStackN n s))
         (pc s)))


(defthm state-set-pc-state-set-pc
  (equal (state-set-pc pc1 (state-set-pc pc2 s))
         (state-set-pc pc1 s))
  <span class="builtin">:hints</span> ((<span class="string">"Goal"</span> <span class="builtin">:in-theory</span> (enable state-set-pc))))


(in-theory (disable pushStack popStack state-set-local-at state-set-pc))

(in-theory (disable inst-opcode)) 

(defthm no-fatal-error?-state-set
  (and (equal (no-fatal-error? (popStack s))
              (no-fatal-error? s))
       (equal (no-fatal-error? (pushStack v s))
              (no-fatal-error? s))
       (equal (no-fatal-error? (state-set-local-at i v s))
              (no-fatal-error? s))
       (equal (no-fatal-error? (state-set-pc npc s))
              (no-fatal-error? s))))

<span class="comment">;----------------------------------------------------------------------
</span>
<span class="comment">;; (program)
;; (acl2::set-guard-checking nil)
</span>
<span class="comment">;; (include-book <a href="../M6-DJVM-shared/cldc-classtable.lisp.html">"../M6-DJVM-shared/cldc-classtable"</a>)
;; ; (acl2::set-guard-checking t)
</span>
<span class="comment">;; (defconst *ip* 0)
;; (defconst *th* 0)
;; (defconst *h*  nil)
;; (defconst *tt* nil)
;; (defconst *dcl* nil)
;; (defconst *s* (make-state *ip* *th* *h* *tt* *dcl* (make-env
;;                                                     JVM::|*OUT/CLDC-CLASS-TABLE*|)
;;                           nil
;;                           nil))
</span>
<span class="comment">;; (acl2::set-guard-checking nil)
;; (defconst *s1* (round-robin-run (setup-initial-state "First" '() *s*) 6))
</span>
<span class="comment">;; (acl2::set-guard-checking t)
;; (logic)
;; (defun init-state ()
;;   *s1*)
</span>

(include-book <span class="string"><a href="../M6-DJVM-shared/cldc-classtable.lisp.html">"../M6-DJVM-shared/cldc-classtable"</a></span>)

(include-book <span class="string"><a href="ADD1-init-state.lisp.html">"ADD1-init-state"</a></span>)

<span class="comment">; define the init-state
; In fact this is not the state that we want to property on. 
; Our proof is about all states that is in some sense equivalent to this
; initial state. 
;
; Thus the init-state is only a way to specified the states that we want to
; prove properties on. 
</span>
<span class="comment">;----------------------------------------------------------------------
;
; Start reasoning about the next-inst.  
;
; The goal to reduce the next instruction to the intuitive idea of "next"
; instruction in the code stream.
;
</span>
<span class="comment">;;; property of initial state.
</span>(<span class="keyword">defun</span> <span class="function-name">first-method-ptr</span> ()
  '(METHOD-PTR <span class="string">"First"</span>
               <span class="string">"main"</span> ((ARRAY <span class="string">"java.lang.String"</span>))
               VOID))


(<span class="keyword">defun</span> <span class="function-name">theMethod</span> ()
  '(METHOD <span class="string">"First"</span> <span class="string">"main"</span>
           (JVM::PARAMETERS (ARRAY <span class="string">"java.lang.String"</span>))
           (JVM::RETURNTYPE . VOID)
           (JVM::ACCESSFLAGS *CLASS* *PUBLIC* *STATIC*)
           (JVM::CODE (JVM::MAX_STACK . 2)
                      (JVM::MAX_LOCAL . 3)
                      (JVM::CODE_LENGTH . 9)
                      (JVM::PARSEDCODE 
                                      <span class="comment">;;(0 (iconst_1))
</span>                                      (0 (iload_2))
                                      (1 (istore_1))
                                      (2 (iload_1))
                                      (3 (iconst_1))
                                      (4 (iadd))
                                      (5 (istore_2))
                                      (6 (iload_2))
                                      (7 (istore_1))
                                      (8 (<span class="keyword">return</span>))
                                      (JVM::ENDOFCODE 9))
                      (JVM::EXCEPTIONS)
                      (JVM::STACKMAP))))

(defthm deref-method-first-method-ptr
  (equal (deref-method (first-method-ptr) (instance-class-table (init-state)))
         (theMethod)))

<span class="comment">;----------------------------------------------------------------------
</span>
(defthm init-state-current-thread
  (equal (current-thread (init-state)) 0))

(defthm init-state-current-method-ptr
  (equal (current-method-ptr (init-state))
         (first-method-ptr))
  <span class="builtin">:hints</span> ((<span class="string">"Goal"</span> <span class="builtin">:in-theory</span> (enable (init-state)))))

(defthm init-state-no-fatal-error?
  (no-fatal-error? (init-state))
  <span class="builtin">:hints</span> ((<span class="string">"Goal"</span> <span class="builtin">:in-theory</span> (enable (init-state)))))

<span class="comment">; property of the "initial state"
</span>
<span class="comment">;----------------------------------------------------------------------
</span>
(in-theory (disable init-state (init-state) (first-method-ptr)
                    first-method-ptr no-fatal-error?))


<span class="comment">;----------------------------------------------------------------------
</span>
(in-theory (disable next-inst))

<span class="comment">;----------------------------------------------------------------------
</span>

(defthm equiv-state-init-state-next-inst
  (implies (equiv-state s (init-state))
           (equal (next-inst s)
                  (inst-by-offset (pc s) (theMethod))))
  <span class="builtin">:hints</span> ((<span class="string">"Goal"</span> <span class="builtin">:in-theory</span> (enable next-inst))))

<span class="comment">; this is the first example theorem refered in the paper 
;        "Java Program Verification via a JVM Deep Embedding in ACL2"
</span>
<span class="comment">;----------------------------------------------------------------------
</span>


(defthm first-is-correct-lemma
  (implies (and (equiv-state  s1 (init-state))
                (equal (pc s1) 2))
           (equiv-state (m6step (m6step (m6step s1)))
                        (init-state))))

(defthm first-is-correct
  (implies (and (equiv-state  s1 (init-state))
                (equal (pc s1) 2))
           (equiv-state (m6step s1)
                        (init-state))))

(defthm simple-run-opener
  (implies (syntaxp (quotep n))
           (equal (simple-run s n)
                  (IF (ZP N)
                      S (SIMPLE-RUN (M6STEP S) (- N 1))))))

(in-theory (disable int-fix))

(defthm first-is-correct-1
  (implies (and (equiv-state  s1 (init-state))
                (equal (pc s1) 0))
           (equiv-state (simple-run s1 7)
                        (init-state))))

<span class="comment">;; Some show case theorems: during proof development. Those above are used to
;; guide the search for a proper set of lemma to "train" ACL2.
</span>
<span class="comment">;; Wed Jan  7 23:33:15 2004
;; 
;; Basically says that straight line code's exeuction perserve the equiv-state
;; From equiv-state we could derive a lot of properties --- What is not changing!!
;; 
;;;;;;;;;;;;;;
</span>

<span class="comment">;----------------------------------------------------------------------
</span>
(defthm round-robin-run-opener
  (implies (or (equal (round-robin-schedule s) 0) 
               (zp n))
           (equal (round-robin-run s n)
                  (<span class="keyword">if</span> (zp n)
                      s
                    (<span class="keyword">let</span> ((cid (current-thread s)))
                      (<span class="keyword">if</span> (equal cid -1)
                          (prog2$ (acl2::cw <span class="string">"NO ACTIVE THREAD!~%"</span>) s)
                        (prog2$ (acl2::cw <span class="string">"Executing Thread ~p0 Instruction ~p1~%"</span> cid (next-inst s))
                                (<span class="keyword">let*</span> ((sn (m6step s))
                                       (nid  (round-robin-schedule sn))
                                       (ccid (current-thread sn)))
                                  (<span class="keyword">if</span> (equal nid -1)
                                      (prog2$ (acl2::cw <span class="string">"Continue executing ~p0~%"</span> ccid)
                                              (round-robin-run sn (- n 1)))
                                    (<span class="keyword">if</span> (not (equal nid cid))
                                        (prog2$ (acl2::cw 
                                                 <span class="string">"~%~%***************~%switch from THREAD ~p0 to THREAD~p1 ~%**************~%~%"</span> 
                                                 cid nid )
                                                (round-robin-run 
                                                 (loadExecutionEnvironment nid 
                                                                           (storeExecutionEnvironment
                                                                            (state-set-current-thread cid sn))) (- n 1)))
                                      (round-robin-run sn (- n 1)))))))))))
  <span class="builtin">:hints</span> ((<span class="string">"Goal"</span> <span class="builtin">:in-theory</span> (disable loadexecutionenvironment
                                      storeexecutionenvironment
                                      inst-opcode do-inst-opener)
           <span class="builtin">:expand</span> (round-robin-run s n))))

(in-theory (disable round-robin-run))

<span class="comment">; Like Do-instr-opener, Decide when should ACL2 should use the definition of
; round-robin-run
</span>
<span class="comment">;----------------------------------------------------------------------
</span>
<span class="comment">;; about round robin schedule.
</span>(defthm round-robin-schedule-init-state
  (equal (round-robin-schedule (init-state)) 0)
  <span class="builtin">:hints</span> ((<span class="string">"Goal"</span> <span class="builtin">:in-theory</span> (enable (init-state)))))

(defcong equiv-thread-table equal (len s1) 1
  <span class="builtin">:hints</span> ((<span class="string">"Goal"</span> <span class="builtin">:in-theory</span> (enable equiv-thread-table))))


<span class="comment">;----------------------------------------------------------------------
</span>
<span class="comment">;; we need this to prove round-robin-schedule 
</span>(defcong equiv-state equal (round-robin-schedule s) 1
  <span class="builtin">:hints</span> ((<span class="string">"Goal"</span> <span class="builtin">:in-theory</span> (enable round-robin-schedule))))

(in-theory (disable loadexecutionenvironment storeexecutionenvironment round-robin-schedule))

(in-theory (disable int-fix))

(defthm equal-round-robin-schedule-0
  (implies (equiv-state s (init-state))
           (equal (round-robin-schedule s) 0)))



(defthm first-is-correct-3
  (implies (and (equiv-state  s1 (init-state))
                (equal (pc s1) 2))
           (equiv-state (round-robin-run s1 4)
                        (init-state))))

<span class="comment">;----------------------------------------------------------------------
</span>
<span class="comment">;; Note (round-robin-run s1 4)
;; is expanded into 
;;            (STATE-SET-PC
;;                 6
;;                    (POPSTACK
;;                     (STATE-SET-LOCAL-AT
;;                      2
;;                      (pop (OPERAND-STACK
;;                            (CURRENT-FRAME
;;                             (STATE-SET-PC
;;                              5
;;                              (PUSHSTACK
;;                               (INT-FIX
;;                                (+
;;                                 (pop  (OPERAND-STACK
;;                                        (CURRENT-FRAME
;;                                         (STATE-SET-PC
;;                                          4
;;                                          (PUSHSTACK
;;                                           1
;;                                           (STATE-SET-PC 3
;;                                                         (PUSHSTACK (NTH 1 (LOCALS (CURRENT-FRAME S1)))
;;                                                                    S1)))))))
;;                                 (CAR
;;                                  (OPERAND-STACK
;;                                   (CURRENT-FRAME
;;                                    (POPSTACK
;;                                     (STATE-SET-PC
;;                                      4
;;                                      (PUSHSTACK
;;                                       1
;;                                       (STATE-SET-PC
;;                                        3
;;                                        (PUSHSTACK (NTH 1 (LOCALS (CURRENT-FRAME S1)))
;;                                                   S1))))))))))
;;                               (POPSTACK
;;                                (POPSTACK
;;                                 (STATE-SET-PC
;;                                  4
;;                                  (PUSHSTACK
;;                                   1
;;                                   (STATE-SET-PC 3
;;                                                 (PUSHSTACK (NTH 1 (LOCALS (CURRENT-FRAME S1)))
;;                                                            S1)))))))))))
;;                      (STATE-SET-PC
;;                       5
;;                       (PUSHSTACK
;;                        (INT-FIX
;;                         (+
;;                          (CAR
;;                           (OPERAND-STACK
;;                            (CURRENT-FRAME
;;                             (STATE-SET-PC
;;                              4
;;                              (PUSHSTACK
;;                               1
;;                               (STATE-SET-PC 3
;;                                             (PUSHSTACK (NTH 1 (LOCALS (CURRENT-FRAME S1)))
;;                                                        S1)))))))
;;                          (CAR
;;                           (OPERAND-STACK
;;                            (CURRENT-FRAME
;;                             (POPSTACK
;;                              (STATE-SET-PC
;;                               4
;;               (PUSHSTACK
;;                  1
;;                  (STATE-SET-PC 3
;;                                (PUSHSTACK (NTH 1 (LOCALS (CURRENT-FRAME S1)))
;;                                           S1))))))))))
;;        (POPSTACK
;;         (POPSTACK
;;          (STATE-SET-PC
;;             4
;;             (PUSHSTACK
;;                  1
;;                  (STATE-SET-PC 3
;;                                (PUSHSTACK (NTH 1 (LOCALS (CURRENT-FRAME S1)))
;;                                           S1)))))))))))
</span>

<span class="comment">;----------------------------------------------------------------------
</span>
<span class="comment">;; Fri Jan  9 00:12:15 2004
;; Why this? 
;; We need the following to prove 
;; (topStack (state-set-pc ....)) is (topStack s)
</span>
<span class="comment">;;; Theorems about  what is not changing. The proofs are trival. 
;;; ACL2 learns the "quick" facts.
</span>
(defthm current-frame-state-set
  (and (equal (current-frame (state-set-pc npc s))
              (current-frame s))
       (equal (current-frame (state-set-heap heap s))
              (current-frame s))
       (equal (current-frame (state-set-error-flag errflg s))
              (current-frame s))
       (equal (current-frame (state-set-class-table classtable s))
              (current-frame s))
       (equal (current-frame (state-set-aux aux s))
              (current-frame s)))
  <span class="builtin">:hints</span> ((<span class="string">"Goal"</span> <span class="builtin">:in-theory</span> (enable state-set-pc))))


(defthm current-thread-exists?-state-set
  (and (equal (current-thread-exists? (state-set-pc npc s))
              (current-thread-exists? s))
       (equal (current-thread-exists? (state-set-heap heap s))
              (current-thread-exists? s))
       (equal (current-thread-exists? (state-set-error-flag errflg s))
              (current-thread-exists? s))
       (equal (current-thread-exists?(state-set-class-table classtable s))
              (current-thread-exists? s))
       (equal (current-thread-exists? (state-set-aux aux s))
              (current-thread-exists? s)))
  <span class="builtin">:hints</span> ((<span class="string">"Goal"</span> <span class="builtin">:in-theory</span> (enable state-set-pc))))


<span class="comment">;----------------------------------------------------------------------
;;; A failed attempt in characterizing the proof efforts 
</span>
<span class="comment">;; 
;;
;;  ...
;; Wed Jan  7 23:35:22 2004 
;; ;;; 
;; ;;; Why wff-state??
</span>
<span class="comment">;; (defthm wff-state-state-set-pc
;;   (implies (wff-state s)
;;            (wff-state (state-set-pc npc s)))
;;   :hints (("Goal" :in-theory (enable state-set-pc))))
</span>

(defthm topStack-of-pushStack-of-thread
  (equal (car (operand-stack (top-frame (push-stack-of-thread v thread))))
         v)
  <span class="builtin">:hints</span> ((<span class="string">"Goal"</span> <span class="builtin">:in-theory</span> (enable push-stack-of-thread))))


(defthm topStack-of-thread-set-local-at
  (equal (car (operand-stack (top-frame (set-local-at-of-thread i v thread))))
         (car (operand-stack (top-frame thread))))
  <span class="builtin">:hints</span> ((<span class="string">"Goal"</span> <span class="builtin">:in-theory</span> (enable set-local-at-of-thread))))


<span class="comment">;----------------------------------------------------------------------
;
;  Some counter intuitive cases from the our choice of implementation 
;
;
;; the following should be true!
;;; 
;;; Some counter intuitive cases from the our choice of implementation 
;;;
;; (skip-proofs
;;  (defthm topStack-state-set-local
;;    (equal (topStack (state-set-local-at i v s))
;;           (topStack s))
;;    :hints (("Goal" :in-theory (enable state-set-local-at)))))
</span>
<span class="comment">;; 
;; But we may want to limit ourselves to only talking about 'valid cases'
;; 
</span>
<span class="comment">;;; this is not true!! because we need unique-id-thread-table!!
</span>

<span class="comment">;; (defthm replace-thread-table-entry-thread-by-id
;;   (implies (and (wff-thread-table tt)
;;                 (unique-id-thread-table tt)
;;                 (equal (thread-id old-thread) id)
;;                 (equal (thread-id new-thread) id)
;;                 (thread-exists? id tt))
;;            (equal (thread-by-id id (replace-thread-table-entry
;;                                      old-thread
;;                                      new-thread tt))
;;                   new-thread))
;;   :hints (("Goal" :in-theory (enable wff-thread-table wff-thread))))
</span>
<span class="comment">;----------------------------------------------------------------------
</span>
(defcong equiv-thread-except-topframe
         equiv-thread-except-topframe (set-local-at-of-thread i v thread) 3)


(defthm thread-by-id-replace-thread-table-entry
  (<span class="keyword">let</span> ((old-thread (thread-by-id tid tt)))
  (implies (and (equal (thread-id new-thread)  tid)
                (thread-exists? tid tt))
           (equal (thread-by-id tid
                                (replace-thread-table-entry 
                                 old-thread new-thread tt))
                  new-thread))))

(defthm thread-id-wff-thread-table
  (implies (and (wff-thread-table tt)
                (thread-exists? id tt))
           (equal (thread-id (thread-by-id id tt))
                  id)))

(defthm thread-id-is-set-local-at-of-thread
  (equal (thread-id (set-local-at-of-thread i v thread))
         (thread-id thread)))



<span class="comment">;;; Thu Jan  8 16:23:15 2004
;;
;; problemetic that 
;; 
;; Without the explicit rewrite rule, ACL2 will not prove the following. 
;; WHY? congruence rule should rewrite ....
</span>
(defthm not-thread-exists?-thread-by-id-nil
  (implies (not (thread-exists? id tt))
           (equal (thread-by-id id tt) nil)))


(defthm wff-thread-table-replace-nil-not-changed
  (implies (wff-thread-table tt)
           (equal (thread-by-id id (replace-thread-table-entry nil any tt))
                  (thread-by-id id tt)))
  <span class="builtin">:hints</span> ((<span class="string">"Goal"</span> <span class="builtin">:in-theory</span> (enable wff-thread-table))))


(defthm topStack-state-set-local
  (implies (wff-thread-table (thread-table s))
           (equal (topStack (state-set-local-at i v s))
                  (topStack s)))
  <span class="builtin">:hints</span> ((<span class="string">"Goal"</span> <span class="builtin">:in-theory</span> (e/d (state-set-local-at current-frame current-thread-exists?)
                                  (set-local-at-of-thread thread-exists?))
           <span class="builtin">:cases</span> ((current-thread-exists? s)))))

(defthm topStack-state-set-pc 
  (equal (topStack (state-set-pc npc s))
         (topStack s)))


<span class="comment">;; (defthm topStack-of-pushStack 
;;   (equal (topStack (pushStack v s))
;;          v)
;;   :hints (("Goal" :in-theory (enable pushStack current-frame))))
;;
;;; Thu Jan  8 00:07:33 2004 this is not true!!
;;;
;;; because the way we wrote our replace-thread-table-entry 
;;;
</span>

(defthm topStack-of-pushStack 
   (implies (and (current-thread-exists? s)
                 (wff-thread-table (thread-table s)))
            (equal (topStack (pushStack v s))
                   v))
   <span class="builtin">:hints</span> ((<span class="string">"Goal"</span> <span class="builtin">:in-theory</span> (enable pushStack current-frame current-thread-exists?))))

<span class="comment">;; now we need to prove other operations perserve wff-thread-table and
;; current-thread-exists?
</span>

(in-theory (disable  POP-THREAD-CALL-STACK-REWRITE
                     TOP-THREAD-CALL-STACK-REWRITE))


<span class="comment">;; Why we need the following??
</span>
<span class="comment">;; ;; (defthm wff-thread-implies-push-top-frame-non-top-frames
;; ;;   (implies (wff-thread thread)
;; ;;            (equal (cons  (top-frame thread)
;; ;;                          (non-top-frames thread))
;; ;;                   (thread-call-stack thread)))
;; ;;   :hints (("Goal" :in-theory (enable top-frame non-top-frames
;; ;;                                      wff-thread))))
</span>                 

<span class="comment">;; ;; (defthm wff-thread-implies-top-frame
;; ;;   (implies (wff-thread thread)
;; ;;            (wff-call-frame (top-frame thread)))
;; ;;   :hints (("Goal" :in-theory (list* 'topx-frame 'wff-thread 'topx
;; ;;                                    (disable top-thread-call-stack-rewrite)))))
</span>

<span class="comment">;; ;; (defthm wff-call-frame-implies-equal
;; ;;   (implies (wff-call-frame frame)
;; ;;            (EQUAL (MAKE-FRAME (RETURN-PC FRAME)
;; ;;                               (OPERAND-STACK FRAME)
;; ;;                               (LOCALS FRAME)
;; ;;                               (METHOD-PTR FRAME)
;; ;;                               (SYNC-OBJ-REF FRAME))
;; ;;                   FRAME)))
</span>
<span class="comment">;; ;; (in-theory (disable wff-call-frame))
</span>


<span class="comment">;; ;; (in-theory (enable  POP-THREAD-CALL-STACK-REWRITE
;; ;;                     TOP-THREAD-CALL-STACK-REWRITE))
</span>
<span class="comment">;; Because we want the following to be exactly equal?
</span>

<span class="comment">;; (skip-proofs
;;  (defthm pop-stack-of-thread-push-stack-of-thread
;;    (implies (wff-thread thread)
;;             (equal (popStack-of-thread (push-stack-of-thread v thread))
;;                    thread))
;;    :hints (("Goal" :in-theory (enable popStack-of-thread 
;;                                       push-stack-of-thread
;;                                       wff-thread)))))
</span>



<span class="comment">;; (defun th-mem (th tt)
;;   (mem th tt))
</span>
<span class="comment">;; (defthm not-thread-id-equal-implies-not-mem
;;   (implies (and (not (mem (thread-id thread) 
;;                           (collect-thread-id tt))))
;;            (not (mem thread tt)))))
</span>
<span class="comment">;; ;; (in-theory (disable id-mem))
</span>
<span class="comment">;; (defthm mem-not-mem-thread
;;   (let ((id (thread-id new-thread)))
;;     (implies (and (unique-id-thread-table tt)
;;                   (thread-exists? (thread-id new-thread) tt)
;;                   (not (equal (thread-by-id id tt)
;;                               new-thread)))
;;              (not (mem new-thread tt))))
;;     :hints (("Goal" :in-theory (enable thread-exists?))))
</span>
<span class="comment">;; (in-theory (disable not-thread-id-equal-implies-not-mem))
</span>
<span class="comment">;; (defthm mem-not-th-mem-thread
;;   (let ((id (thread-id new-thread)))
;;     (implies (and (unique-id-thread-table tt)
;;                   (thread-exists? (thread-id new-thread) tt)
;;                   (not (equal (thread-by-id id tt)
;;                               new-thread)))
;;              (not (th-mem new-thread tt))))
;;   :hints (("Goal" :in-theory (disable unique-id-thread-table))))
</span>
<span class="comment">;; (in-theory (disable mem-not-mem-thread th-mem))
</span>

<span class="comment">;; (defthm thread-exists?-mem-thread-by-id
;;   (implies (thread-exists? id tt)
;;            (th-mem (thread-by-id id tt)
;;                    tt))
;;   :hints (("Goal" :in-theory (enable thread-exists? th-mem))))
</span>


<span class="comment">;; (defthm replace-thread-table-entry-replace-thread-table-entry
;;   (implies (and (not (th-mem c tt))
;;                 (th-mem a tt)
;;                 (not (equal a c)))
;;            (equal (replace-thread-table-entry c b 
;;                                               (replace-thread-table-entry a c tt))
;;                   (replace-thread-table-entry a b tt)))
;;   :hints (("Goal" :in-theory (enable th-mem))))
</span>
<span class="comment">;; (defthm replace-thread-table-entry-replace-thread-table-entry-2
;;   (equal (replace-thread-table-entry c c tt) 
;;          tt))
</span>
<span class="comment">;; (defthm replace-thread-table-entry-replace-thread-table-entry-x
;;   (implies (and (equal c a)
;;                 (th-mem a tt))
;;            (equal (replace-thread-table-entry c b 
;;                                               (replace-thread-table-entry a c tt))
;;                   (replace-thread-table-entry a b tt)))
;;   :hints (("Goal" :in-theory (enable th-mem))))
</span>

<span class="comment">;; (defthm not-equal-thread-call-stack-implies-not-equal
;;   (implies (not (equal (operand-stack (top (thread-call-stack s2)))
;;                        (operand-stack (top (thread-call-stack s1)))))
;;            (not (equal s2 s1))))
</span>

<span class="comment">;; (defthm not-equal-pushStack-of-thread
;;   (not (equal (push-stack-of-thread v thread)
;;               thread))
;;   :hints (("Goal" :in-theory (enable push-stack-of-thread)
;;            :use ((:instance  not-equal-thread-call-stack-implies-not-equal
;;                              (s2 (push-stack-of-thread v thread))
;;                              (s1 thread))))))
</span>



<span class="comment">;; (skip-proofs
;;  (defthm popStack-pushStack-1
;;    (implies (wff-state s)
;;             (equal (popStack (pushStack v s))
;;                    s))
;;    :hints (("Goal" :cases ((current-thread-exists? s))
;;             :in-theory (enable popStack pushStack))
;;            ("Subgoal 1''" :in-theory (enable current-thread-exists?)))))
</span>

(defthm thread-primitives-state-set-pc
  (and (equal (popStack (state-set-pc npc s))
              (state-set-pc npc (popStack s)))
       (equal (pushStack v  (state-set-pc npc s))
              (state-set-pc npc (pushStack v s)))
       (equal (state-set-local-at i v (state-set-pc npc s))
              (state-set-pc npc (state-set-local-at i v s))))
  <span class="builtin">:hints</span> ((<span class="string">"Goal"</span> <span class="builtin">:in-theory</span> (enable state-set-pc popStack pushStack
                                     state-set-local-at
                                     state-set-thread-table))))

<span class="comment">;;; move pushStack, popStack inside ....
</span>

<span class="comment">;; this is not true, because of the norm-state.
;; Maybe I should introduce a normal state predicate.
</span>
(defthm locals-unchanged-by
  (and (equal (locals (top-frame (push-stack-of-thread v thread)))
              (locals (top-frame thread)))
       (equal (locals (top-frame (popStack-of-thread  thread)))
              (locals (top-frame thread))))
  <span class="builtin">:hints</span> ((<span class="string">"Goal"</span> <span class="builtin">:in-theory</span> (enable push-stack-of-thread
                                     top-frame
                                     popStack-of-thread))))


(defthm locals-of-set-local-at
  (equal (locals (top-frame (set-local-at-of-thread i v thread)))
         (update-nth i v (locals (top-frame thread))))
  <span class="builtin">:hints</span> ((<span class="string">"Goal"</span> <span class="builtin">:in-theory</span> (enable set-local-at-of-thread top-frame))))


(in-theory (enable  POP-THREAD-CALL-STACK-REWRITE
                     TOP-THREAD-CALL-STACK-REWRITE))

(defthm local-at-accessor-2
  (implies (and (wff-thread-table (thread-table s))
                (current-thread-exists? s))
           (equal (local-at i (state-set-local-at j v s))
                  (<span class="keyword">if</span> (equal (nfix i) (nfix j))
                      v
                    (local-at i s))))
  <span class="builtin">:hints</span> ((<span class="string">"Goal"</span> <span class="builtin">:in-theory</span> (enable state-set-local-at local-at current-frame 
                                     current-thread-exists?))))
          

<span class="comment">;; (defthm local-at-accessor-2
;;   (implies (and (current-thread-exists? s)
;;                 (wff-thread-table (thread-table s)))
;;            (equal (local-at i (state-set-local-at j v s))
;;                   (if (equal (nfix i) (nfix j))
;;                       v
;;                     (local-at i s))))
;;   :hints (("Goal" :in-theory (enable state-set-local-at local-at current-frame 
;;                                      current-thread-exists?))))
</span>
(defthm local-at-accessor-1
  (and (implies (wff-thread-table (thread-table s))
                (equal (local-at i (popStack s)) 
                       (local-at i s)))
       (implies (wff-thread-table (thread-table s))
                (equal (local-at i (pushStack v s))
                       (local-at i s)))
       (implies (wff-thread-table (thread-table s))
                (equal (local-at i (state-set-pc npc s))
                       (local-at i s))))
       <span class="builtin">:hints</span> ((<span class="string">"Goal"</span> <span class="builtin">:in-theory</span> (enable popStack pushStack 
                                          current-frame current-thread-exists?)
                <span class="builtin">:cases</span> ((current-thread-exists? s)))))


(in-theory (disable local-at topStack int-fix))

(in-theory (disable wff-state init-state m6step round-robin-run (init-state)))


<span class="comment">; (acl2::set-match-free-error nil)
</span>
(defcong equiv-state equiv-state (pushStack v s) 2)
(defcong equiv-state equiv-state (popStack s) 1)
(defcong equiv-state equiv-state (state-set-local-at i v s) 3)

<span class="comment">;----------------------------------------------------------------------
</span>

(include-book <span class="string"><a href="../M6-DJVM-shared/wff-data-structure.lisp.html">"../M6-DJVM-shared/wff-data-structure"</a></span>)

<span class="comment">;; Identify the domain
</span>
<span class="comment">;----------------------------------------------------------------------
</span>


(defthm wff-thread-push-stack-of-thread
  (wff-thread (push-stack-of-thread v thread))
  <span class="builtin">:hints</span> ((<span class="string">"Goal"</span> <span class="builtin">:in-theory</span> (enable push-stack-of-thread))))

(defthm wff-call-frame-top-frame-push-stack-of-thread
  (implies (wff-call-frame-regular (top-frame thread))
           (wff-call-frame-regular (top-frame (push-stack-of-thread v thread))))
  <span class="builtin">:hints</span> ((<span class="string">"Goal"</span> <span class="builtin">:in-theory</span> (enable push-stack-of-thread make-frame
                                     wff-call-frame return-pc operand-stack
                                     locals method-ptr sync-obj-ref))))


(defthm wff-thread-table-prevserved-by-pushStack
  (implies (wff-thread-table (thread-table s))
           (wff-thread-table (thread-table (pushStack v s))))
  <span class="builtin">:hints</span> ((<span class="string">"Goal"</span> <span class="builtin">:in-theory</span> (enable pushStack))))

(defthm wff-call-frame-current-frame-prevserved-by-pushStack
  (implies (and (wff-call-frame-regular (current-frame s))
                (wff-thread-table (thread-table s))
                (current-thread-exists? s))
           (wff-call-frame-regular (current-frame (pushStack v s))))
  <span class="builtin">:hints</span> ((<span class="string">"Goal"</span> <span class="builtin">:in-theory</span> (enable pushStack current-thread-exists? current-frame))))

(defthm wff-thread-pop-stack-of-thread
  (wff-thread (popStack-of-thread  thread))
  <span class="builtin">:hints</span> ((<span class="string">"Goal"</span> <span class="builtin">:in-theory</span> (enable popStack-of-thread))))


(defthm wff-call-frame-top-frame-pop-stack-of-thread
  (implies (wff-call-frame-regular (top-frame thread))
           (wff-call-frame-regular (top-frame (popStack-of-thread thread))))
  <span class="builtin">:hints</span> ((<span class="string">"Goal"</span> <span class="builtin">:in-theory</span> (enable popStack-of-thread make-frame
                                     wff-call-frame return-pc operand-stack
                                     locals method-ptr sync-obj-ref))))


(defthm wff-call-frame-current-frame-prevserved-by-popStack
  (implies (and (wff-call-frame-regular (current-frame s))
                (wff-thread-table (thread-table s))
                (current-thread-exists? s))
           (wff-call-frame-regular (current-frame (popStack s))))
  <span class="builtin">:hints</span> ((<span class="string">"Goal"</span> <span class="builtin">:in-theory</span> (enable popStack current-thread-exists? current-frame))))


(defthm wff-thread-table-prevserved-by-popStack
  (implies (wff-thread-table (thread-table s))
           (wff-thread-table (thread-table (popStack s))))
  <span class="builtin">:hints</span> ((<span class="string">"Goal"</span> <span class="builtin">:in-theory</span> (enable popStack))))


(defthm wff-thread-set-local-at-of-thread
  (wff-thread (set-local-at-of-thread i v  thread))
  <span class="builtin">:hints</span> ((<span class="string">"Goal"</span> <span class="builtin">:in-theory</span> (enable set-local-at-of-thread))))


(defthm wff-call-frame-top-frame-set-local-at-of-thread
  (implies (wff-call-frame-regular (top-frame thread))
           (wff-call-frame-regular (top-frame (set-local-at-of-thread i v  thread))))
  <span class="builtin">:hints</span> ((<span class="string">"Goal"</span> <span class="builtin">:in-theory</span> (enable set-local-at-of-thread make-frame
                                     wff-call-frame return-pc operand-stack
                                     locals method-ptr sync-obj-ref))))


(defthm wff-call-frame-current-frame-prevserved-by-state-set-local-at
  (implies (and (wff-call-frame-regular (current-frame s))
                (wff-thread-table (thread-table s))
                (current-thread-exists? s))
           (wff-call-frame-regular (current-frame (state-set-local-at i v  s))))
  <span class="builtin">:hints</span> ((<span class="string">"Goal"</span> <span class="builtin">:in-theory</span> (enable state-set-local-at current-thread-exists? current-frame))))


(defthm wff-thread-table-prevserved-by-set-local
   (implies (wff-thread-table (thread-table s))
            (wff-thread-table (thread-table (state-set-local-at i v s))))
   <span class="builtin">:hints</span> ((<span class="string">"Goal"</span> <span class="builtin">:in-theory</span> (enable state-set-local-at))))


(defthm current-thread-exists-prevserved-by-pushStack
  (implies (current-thread-exists? s)
           (current-thread-exists? (pushStack v s)))
  <span class="builtin">:hints</span> ((<span class="string">"Goal"</span> <span class="builtin">:in-theory</span> (enable current-thread-exists? 
                                     pushStack))))

(defthm current-thread-exists-prevserved-by-popStack
   (implies (current-thread-exists? s)
            (current-thread-exists? (popStack s)))
   <span class="builtin">:hints</span> ((<span class="string">"Goal"</span> <span class="builtin">:in-theory</span> (enable current-thread-exists? popStack))))

(defthm current-thread-exists-prevserved-by-set-local
   (implies (current-thread-exists? s)
            (current-thread-exists? (state-set-local-at i v s)))
   <span class="builtin">:hints</span> ((<span class="string">"Goal"</span> <span class="builtin">:in-theory</span> (enable current-thread-exists? state-set-local-at))))

<span class="comment">;----------------------------------------------------------------------
</span>   
<span class="comment">;; We really want this (popStack (pushStack v s)) == s!
;; However this is not always true. Only if s is wff-state-strong in some sense.!!
</span>
<span class="comment">;----------------------------------------------------------------------
</span>

(defthm consp-call-stack-implies-cons-top-frame-non-top-frame
  (implies (consp (thread-call-stack thread))
           (equal (cons (top-frame thread)
                        (non-top-frames thread))
                  (thread-call-stack thread)))
  <span class="builtin">:hints</span> ((<span class="string">"Goal"</span> <span class="builtin">:in-theory</span> (e/d (top-frame non-top-frames)
                                  (top-thread-call-stack-rewrite
                                   pop-thread-call-stack-rewrite)))))


(defthm wff-thread-implies-push-top-frame-non-top-frames
  (implies (wff-call-frame (top-frame thread))
           (consp (thread-call-stack thread)))
  <span class="builtin">:hints</span> ((<span class="string">"Goal"</span> <span class="builtin">:in-theory</span> (e/d (top-frame wff-call-frame)
                                  (top-thread-call-stack-rewrite)))))
                 

(defthm pop-stack-of-thread-push-stack-of-thread
  (implies (and (wff-call-frame-regular (top-frame thread))
                (wff-thread-regular thread))
           (equal (popStack-of-thread (push-stack-of-thread v thread))
                  thread))
  <span class="builtin">:hints</span> ((<span class="string">"Goal"</span> <span class="builtin">:in-theory</span> (enable popStack-of-thread 
                                     push-stack-of-thread
                                     wff-call-frame
                                     wff-thread))))


<span class="comment">;; (defthm wff-state-regular-set-tt
;;   (implies (and (equal tt (thread-table s))
;;                 (wff-state-regular s))
;;            (equal (state-set-thread-table tt s)
;;                   s))
;;   :hints (("Goal" :in-theory (enable state-set-thread-table wff-state 
;;                                      make-state pc current-thread  heap
;;                                      thread-table class-table error-flag aux env))))
</span>
<span class="comment">;; ;; this proof is hard because the our implementation of
;; ;; replace-thread-table-entry 
</span>
<span class="comment">;; (defthm state-set-thread-table-set-tt
;;   (equal (state-set-thread-table tt1 (state-set-thread-table tt2 s))
;;          (state-set-thread-table tt1 s))
;;   :hints (("Goal" :in-theory (enable state-set-thread-table))))
</span>

(in-theory (disable wff-call-frame-regular thread-exists?))


(defthm thread-by-id-wff-thread-table
  (implies (and (thread-exists? id tt)
               (wff-thread-table tt))
          (wff-thread (thread-by-id id tt)))
  <span class="builtin">:hints</span> ((<span class="string">"Goal"</span> <span class="builtin">:in-theory</span> (enable wff-thread-table thread-exists?))))


(defthm thread-by-id-wff-thread-table-regular
  (implies (and (thread-exists? id tt)
               (wff-thread-table-regular tt))
           (wff-thread-regular (thread-by-id id tt)))
  <span class="builtin">:hints</span> ((<span class="string">"Goal"</span> <span class="builtin">:in-theory</span> (enable wff-thread-table-regular thread-exists?))))



<span class="comment">;; (defthm current-thread-exists-wff-thread-table
;;   (implies (and (current-thread-exists? s)
;;                 (wff-thread-table (thread-table s)))
;;            (wff-thread (thread-by-id (current-thread s)
;;                                      (thread-table s))))
;;   :hints (("Goal" :in-theory (enable current-thread-exists?))))
</span>



(defthm collect-thread-id-replace-is-not-changed
  (implies (equal (thread-id new) (thread-id old))
           (equal (collect-thread-id (replace-thread-table-entry old new tt))
                  (collect-thread-id tt))))

(defthm unique-id-thread-table-replace-entry
  (implies (and (unique-id-thread-table tt)
                (equal (thread-id new) (thread-id old)))
           (unique-id-thread-table (replace-thread-table-entry old new tt))))

<span class="comment">;----------------------------------------------------------------------
</span>
(defthm replace-replace-is-replace
  (implies (and (unique-id-thread-table tt)
                (equal (thread-id thread2) id)
                (equal (thread-id thread1) id)
                (thread-by-id id tt))
           (equal (replace-thread-table-entry thread1 thread2
                       (replace-thread-table-entry (thread-by-id id tt) thread1 tt))
                  (replace-thread-table-entry (thread-by-id id tt) thread2 tt))))



(defthm replace-equal-is-equal
  (equal (replace-thread-table-entry old old tt)
         tt))

<span class="comment">;----------------------------------------------------------------------
</span>
(in-theory (disable unique-id-thread-table))

(defthm wff-thread-table-regular-implies-wff-thread-table
  (implies (wff-thread-table-regular tt)
           (wff-thread-table tt))
  <span class="builtin">:hints</span> ((<span class="string">"Goal"</span> <span class="builtin">:in-theory</span> (enable wff-thread-table))))


(defthm popStack-pushStack-is
   (implies (and (current-thread-exists? s)
                 (wff-state-regular s)
                 (unique-id-thread-table    (thread-table s))
                 (wff-call-frame-regular    (current-frame s))
                 (wff-thread-table-regular  (thread-table s)))
            (equal (popStack (pushStack v s))
                    s))
  <span class="builtin">:hints</span> ((<span class="string">"Goal"</span> <span class="builtin">:in-theory</span> (enable current-frame
                                     thread-exists?
                                     current-thread-exists? 
                                     state-set-thread-table
                                     pushStack popStack topStack))))

<span class="comment">; finally, we have what I wanted. 
;
;----------------------------------------------------------------------
</span>
(defthm wff-state-regular-pushStack
  (implies (wff-state-regular s)
           (wff-state-regular (pushStack v s)))
  <span class="builtin">:hints</span> ((<span class="string">"Goal"</span> <span class="builtin">:in-theory</span> (enable pushStack state-set-thread-table wff-state
                                     make-state pc aux current-thread heap
                                     thread-table class-table env
                                     error-flag))))

(defthm unique-id-thread-table-pushStack
  (implies (unique-id-thread-table (thread-table s))
           (unique-id-thread-table (thread-table (pushStack v s))))
  <span class="builtin">:hints</span> ((<span class="string">"Goal"</span> <span class="builtin">:in-theory</span> (enable pushStack state-set-thread-table))))



(defthm wff-state-regular-popStack
  (implies (wff-state-regular s)
           (wff-state-regular (popStack s)))
  <span class="builtin">:hints</span> ((<span class="string">"Goal"</span> <span class="builtin">:in-theory</span> (enable popStack state-set-thread-table wff-state
                                     make-state pc aux current-thread heap
                                     thread-table class-table env error-flag))))

(defthm unique-id-thread-table-popStack
  (implies (unique-id-thread-table (thread-table s))
           (unique-id-thread-table (thread-table (popStack s))))
  <span class="builtin">:hints</span> ((<span class="string">"Goal"</span> <span class="builtin">:in-theory</span> (enable popStack state-set-thread-table))))



(defthm wff-state-regular-state-set-local
  (implies (wff-state-regular s)
           (wff-state-regular (state-set-local-at i v s)))
  <span class="builtin">:hints</span> ((<span class="string">"Goal"</span> <span class="builtin">:in-theory</span> (enable state-set-local-at state-set-thread-table wff-state
                                     make-state pc aux current-thread heap
                                     thread-table class-table env error-flag))))

(defthm unique-id-thread-table-state-set-local
  (implies (unique-id-thread-table (thread-table s))
           (unique-id-thread-table (thread-table (state-set-local-at i v s))))
  <span class="builtin">:hints</span> ((<span class="string">"Goal"</span> <span class="builtin">:in-theory</span> (enable state-set-local-at state-set-thread-table))))


(defthm wff-thread-table-regular-replace-regular
  (implies (and (wff-thread-table-regular tt)
                (wff-thread-regular new))
           (wff-thread-table-regular (replace-thread-table-entry old new tt))))


(defthm wff-thread-regular-push-stack-of-thread
  (implies (wff-thread-regular thread)
           (wff-thread-regular (push-stack-of-thread v thread)))
  <span class="builtin">:hints</span> ((<span class="string">"Goal"</span> <span class="builtin">:in-theory</span> (enable push-stack-of-thread))))

(defthm wff-thread-regular-pop-stack-of-thread
  (implies (wff-thread-regular thread)
           (wff-thread-regular (popstack-of-thread thread)))
  <span class="builtin">:hints</span> ((<span class="string">"Goal"</span> <span class="builtin">:in-theory</span> (enable popstack-of-thread))))

(defthm wff-thread-regular-state-set-local-at
  (implies (wff-thread-regular thread)
           (wff-thread-regular (set-local-at-of-thread i v thread)))
  <span class="builtin">:hints</span> ((<span class="string">"Goal"</span> <span class="builtin">:in-theory</span> (enable set-local-at-of-thread))))

(defthm wff-thread-table-regular-pushStack
  (implies (and (wff-thread-table-regular (thread-table s))
                (current-thread-exists? s))
           (wff-thread-table-regular (thread-table (pushStack v s))))
  <span class="builtin">:hints</span> ((<span class="string">"Goal"</span> <span class="builtin">:in-theory</span> (enable pushStack current-thread-exists?))))


(defthm wff-thread-table-regular-popStack
  (implies (and (wff-thread-table-regular (thread-table s))
                (current-thread-exists? s))
           (wff-thread-table-regular (thread-table (popStack s))))
  <span class="builtin">:hints</span> ((<span class="string">"Goal"</span> <span class="builtin">:in-theory</span> (enable popStack current-thread-exists?))))



(defthm wff-thread-table-regular-state-set-local-at
  (implies (and (wff-thread-table-regular (thread-table s))
                (current-thread-exists? s))
           (wff-thread-table-regular (thread-table (state-set-local-at i v s))))
  <span class="builtin">:hints</span> ((<span class="string">"Goal"</span> <span class="builtin">:in-theory</span> (enable state-set-local-at current-thread-exists?))))

<span class="comment">;----------------------------------------------------------------------
</span>
(defthm first-is-correct-4
  (<span class="keyword">let</span> ((old (local-at 2 s1)))
  (implies (and (equiv-state s1 (init-state))
                (current-thread-exists? s1)
                (wff-state-regular s1)
                (wff-thread-table-regular (thread-table s1))
                (wff-call-frame-regular (current-frame s1))
                (unique-id-thread-table (thread-table s1))
                (equal (pc s1) 0)
                (integerp old))
           (equal (local-at 2 (round-robin-run s1 7))
                  (int-fix (+ 1 old)))))
  <span class="builtin">:hints</span> ((<span class="string">"Goal"</span> <span class="builtin">:in-theory</span> (disable unique-id-thread-table))))


<span class="comment">;----------------------------------------------------------------------
</span>

<span class="comment">;----------------------------------------------------------------------
</span>
<span class="comment">;; EXTENDED DEMO: STRAIGHT LINE CODE!!
</span>
<span class="comment">#|
(defconst *FirstX*
 (make-class-def
      '(class "FirstX"
            "java.lang.Object"
            (constant_pool)
            (fields)
            (methods
                        (method "&lt;init&gt;"
                              (parameters )
                              (returntype void)
                              (accessflags  *class*  *public* )
                              (code
                                   (max_stack 1) (max_locals 1) (code_length 5)
                                   (parsedcode
                                      (0 (aload_0))
                                      (1 (invokespecial
                                        (methodCP "&lt;init&gt;" "java.lang.Object" () void)))
                                      (4 (return))
                                      (endofcode 5))
                                   (Exceptions )
                                   (StackMap )))
                        (method "main"
                              (parameters (array (class "java.lang.String")))
                              (returntype void)
                              (accessflags  *class*  *public*  *static* )
                              (code
                                   (max_stack 2) (max_locals 3) (code_length 14)
                                   (parsedcode
                                      (0 (iload_2)) 
                                      (1 (istore_1))
                                      (2 (iload_1))
                                      (3 (iconst_1))
                                      (4 (iadd))
                                      (5 (istore_2))
                                      (6 (iload_2))
                                      (7 (istore_1))
                                      (8 (iconst_2))
                                      (9 (iload_2))
                                      (10 (iload_1))
                                      (11 (iadd))
                                      (12 (iadd))
                                      (13 (istore_2))
                                      (14 (return))
                                      (endofcode 14))
                                   (Exceptions )
                                   (StackMap ))))
            (interfaces)
            (accessflags  *class*  *public*  *super*  *synchronized* )
            (attributes
              (attribute "SourceFile")))))

|#</span>
<span class="comment">;----------------------------------------------------------------------
</span>
<span class="comment">;----------------------------------------------------------------------
</span>
(<span class="keyword">defun</span> <span class="function-name">first-method-ptr-x</span> ()
  '(METHOD-PTR <span class="string">"FirstX"</span>
               <span class="string">"main"</span> ((ARRAY <span class="string">"java.lang.String"</span>))
               VOID))


(<span class="keyword">defun</span> <span class="function-name">theMethod-x</span> ()
  '(METHOD <span class="string">"FirstX"</span> <span class="string">"main"</span>
        (PARAMETERS (ARRAY <span class="string">"java.lang.String"</span>))
        (RETURNTYPE . VOID)
        (ACCESSFLAGS *CLASS* *PUBLIC* *STATIC*)
        (CODE (MAX_STACK . 2)
              (MAX_LOCAL . 3)
              (CODE_LENGTH . 14)
              (PARSEDCODE (0 (ILOAD_2))
                          (1 (ISTORE_1))
                          (2 (ILOAD_1))
                          (3 (ICONST_1))
                          (4 (IADD))
                          (5 (ISTORE_2))
                          (6 (ILOAD_2))
                          (7 (ISTORE_1))
                          (8 (ICONST_2))
                          (9 (ILOAD_2))
                          (10 (ILOAD_1))
                          (11 (IADD))
                          (12 (IADD))
                          (13 (ISTORE_2))
                          (14 (RETURN))
                          (ENDOFCODE 14))
              (EXCEPTIONS)
              (STACKMAP))))

(defthm deref-method-first-method-ptr-x
  (equal (deref-method (first-method-ptr-x) (instance-class-table (init-state-x)))
         (theMethod-x)))

<span class="comment">;----------------------------------------------------------------------
</span>

(defthm init-state-current-thread-x
  (equal (current-thread (init-state-x)) 0))

(defthm init-state-current-method-ptr-x
  (equal (current-method-ptr (init-state-x))
         (first-method-ptr-x))
  <span class="builtin">:hints</span> ((<span class="string">"Goal"</span> <span class="builtin">:in-theory</span> (enable (init-state-x)))))

(defthm init-state-no-fatal-error?-x
  (no-fatal-error? (init-state-x))
  <span class="builtin">:hints</span> ((<span class="string">"Goal"</span> <span class="builtin">:in-theory</span> (enable (init-state-x)))))

<span class="comment">;----------------------------------------------------------------------
</span>(in-theory (disable first-method-ptr-x (first-method-ptr-x) theMethod-x init-state-x (init-state-x)))
<span class="comment">;----------------------------------------------------------------------
</span>
(defthm round-robin-schedule-init-state-x
  (equal (round-robin-schedule (init-state-x)) 0)
  <span class="builtin">:hints</span> ((<span class="string">"Goal"</span> <span class="builtin">:in-theory</span> (enable (init-state-x)))))


(defthm equal-round-robin-schedule-0-x
  (implies (equiv-state s (init-state-x))
           (equal (round-robin-schedule s) 0)))


<span class="comment">;----------------------------------------------------------------------
</span>

(defthm equiv-state-init-state-next-inst-x
  (implies (equiv-state s (init-state-x))
           (equal (next-inst s)
                  (inst-by-offset (pc s) (theMethod-x))))
  <span class="builtin">:hints</span> ((<span class="string">"Goal"</span> <span class="builtin">:in-theory</span> (enable next-inst))))

<span class="comment">;; ;----------------------------------------------------------------------
;;
;; (defthm first-is-correct-4-x
;;   (let ((old (local-at 2 s1)))
;;   (implies (and (equiv-state s1 (init-state-x))
;;                 (current-thread-exists? s1)
;;                 (wff-state-regular s1)
;;                 (wff-thread-table-regular (thread-table s1))
;;                 (wff-call-frame-regular (current-frame s1))
;;                 (unique-id-thread-table (thread-table s1))
;;                 (equal (pc s1) 0)
;;                 (integerp old))
;;            (equal (local-at 2 (round-robin-run s1 7))
;;                   (int-fix (+ 1 old)))))
;;   :hints (("Goal" :in-theory (disable unique-id-thread-table))))
;;
;; ;----------------------------------------------------------------------
</span>
(include-book <span class="string">"arithmetic-2/meta/top"</span> <span class="builtin">:dir</span> <span class="builtin">:system</span>)

(include-book <span class="string">"arithmetic-2/floor-mod/floor-mod"</span> <span class="builtin">:dir</span> <span class="builtin">:system</span>)

(defthm int-fix-int-fix-plus
  (implies (and (integerp x)
                (integerp y))
           (equal (int-fix (+ x (int-fix y)))
                  (int-fix (+ x y))))
   <span class="builtin">:hints</span> ((<span class="string">"Goal"</span> <span class="builtin">:in-theory</span> (enable int-fix))))


(defthm mod-n-a-multpliy-n
  (implies (and (integerp n)
                (integerp y))
           (equal (mod (* n y) n)
                  0))
  <span class="builtin">:hints</span> ((<span class="string">"Goal"</span> <span class="builtin">:in-theory</span> (enable mod))))


(defthm mod-plus
  (implies (and (integerp x)
                (integerp n)
                (integerp y))
           (equal (mod (+ x (mod y n)) n)
                  (mod (+ x y) n))))


(defthm mod-plus-collorary
  (implies (and (integerp x)
                (integerp n)
                (integerp y))
           (equal (mod (+ (mod x n) (mod y n)) n)
                  (mod (+ x y) n))))


(defthm mod-n-multiply-y-plus
  (implies (and (integerp x)
                (integerp n)
                (integerp y))
           (equal (mod (+ x (* n y)) n)
                  (mod x n))))

<span class="comment">;; (defthm mod-n-multiply-specific
;;   (implies (and (integerp x)
;;                 (integerp i)
;;                 (integerp i0))
;;            (equal (mod (* x (+ I (* 4294967296 i0))) 4294967296)
;;                   (mod (* x i) 4294967296))))
</span>
(defthm integerp-multiply
  (implies (and (integerp i)
                (integerp x))
           (integerp (* i x))))

(defthm int-fix-multiply
  (implies (and (integerp x)
                (integerp y))
           (equal (int-fix (* x (int-fix y)))
                  (int-fix (* x y))))
  <span class="builtin">:hints</span> ((<span class="string">"Goal"</span> <span class="builtin">:in-theory</span> (e/d (int-fix)))))



<span class="comment">;; (skip-proofs
;;  (defthm int-fix-int-fix-plus
;;    (equal (int-fix (+ x (int-fix y)))
;;           (int-fix (+ x y)))
;;    :hints (("Goal" :in-theory (enable int-fix)))))
</span>
<span class="comment">;; (skip-proofs
;;  (defthm int-fix-multiply
;;    (equal (int-fix (* x (int-fix y)))
;;           (int-fix (* x y)))
;;    :hints (("Goal" :in-theory (enable int-fix)))))
</span>


(defthm first-is-correct-5-x
  (<span class="keyword">let</span> ((old (local-at 2 s1)))
  (implies (and (equiv-state s1 (init-state-x))
                (current-thread-exists? s1)
                (wff-state-regular s1)
                (wff-thread-table-regular (thread-table s1))
                (wff-call-frame-regular (current-frame s1))
                (unique-id-thread-table (thread-table s1))
                (equal (pc s1) 0)
                (integerp old))
           (equal (local-at 2 (round-robin-run s1 14))
                  (INT-FIX (+ 4 (* 2 old))))))
  <span class="builtin">:hints</span> ((<span class="string">"Goal"</span> <span class="builtin">:in-theory</span> (disable unique-id-thread-table))))

</pre>
  </body>
</html>
